"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_node_modules_thirdweb-dev_wallets_evm_connectors_token-bound-smart-wallet_-8e471e"],{

/***/ "(app-pages-browser)/./node_modules/@thirdweb-dev/wallets/dist/http-rpc-client-0a079e80.browser.esm.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@thirdweb-dev/wallets/dist/http-rpc-client-0a079e80.browser.esm.js ***!
  \*****************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   D: function() { return /* binding */ DEBUG; },\n/* harmony export */   H: function() { return /* binding */ HttpRpcClient; },\n/* harmony export */   g: function() { return /* binding */ getUserOpHashV06; },\n/* harmony export */   h: function() { return /* binding */ hexlifyUserOp; },\n/* harmony export */   r: function() { return /* binding */ randomNonce; }\n/* harmony export */ });\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/./node_modules/@ethersproject/properties/lib.esm/index.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/./node_modules/@ethersproject/bytes/lib.esm/index.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/./node_modules/@ethersproject/keccak256/lib.esm/index.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/./node_modules/@ethersproject/abi/lib.esm/abi-coder.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/./node_modules/@ethersproject/bignumber/lib.esm/bignumber.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/./node_modules/@ethersproject/providers/lib.esm/url-json-rpc-provider.js\");\n/* harmony import */ var _url_a45219bd_browser_esm_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./url-a45219bd.browser.esm.js */ \"(app-pages-browser)/./node_modules/@thirdweb-dev/wallets/dist/url-a45219bd.browser.esm.js\");\n/* harmony import */ var _headers_733a8199_browser_esm_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./headers-733a8199.browser.esm.js */ \"(app-pages-browser)/./node_modules/@thirdweb-dev/wallets/dist/headers-733a8199.browser.esm.js\");\n/* harmony import */ var _utils_f58e7acc_browser_esm_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./utils-f58e7acc.browser.esm.js */ \"(app-pages-browser)/./node_modules/@thirdweb-dev/wallets/dist/utils-f58e7acc.browser.esm.js\");\n\n\n\n\n\nasync function hexlifyUserOp(\n// TODO: types\nop) {\n  const userOp = await ethers__WEBPACK_IMPORTED_MODULE_0__.resolveProperties(op);\n  return Object.keys(userOp).map(key => {\n    let val = userOp[key];\n    if (typeof val !== \"string\" || !val.startsWith(\"0x\")) {\n      val = ethers__WEBPACK_IMPORTED_MODULE_1__.hexValue(val);\n    }\n    return [key, val];\n  }).reduce((set, _ref) => {\n    let [k, v] = _ref;\n    return {\n      ...set,\n      [k]: v\n    };\n  }, {});\n}\n\n// v0.6 userOpHash calculation\nasync function getUserOpHashV06(userOp, entryPoint, chainId) {\n  const op = await ethers__WEBPACK_IMPORTED_MODULE_0__.resolveProperties(userOp);\n  const hashedUserOp = {\n    sender: op.sender,\n    nonce: op.nonce,\n    initCodeHash: ethers__WEBPACK_IMPORTED_MODULE_2__.keccak256(op.initCode),\n    callDataHash: ethers__WEBPACK_IMPORTED_MODULE_2__.keccak256(op.callData),\n    callGasLimit: op.callGasLimit,\n    verificationGasLimit: op.verificationGasLimit,\n    preVerificationGas: op.preVerificationGas,\n    maxFeePerGas: op.maxFeePerGas,\n    maxPriorityFeePerGas: op.maxPriorityFeePerGas,\n    paymasterAndDataHash: ethers__WEBPACK_IMPORTED_MODULE_2__.keccak256(op.paymasterAndData)\n  };\n  const userOpType = {\n    components: [{\n      type: \"address\",\n      name: \"sender\"\n    }, {\n      type: \"uint256\",\n      name: \"nonce\"\n    }, {\n      type: \"bytes32\",\n      name: \"initCodeHash\"\n    }, {\n      type: \"bytes32\",\n      name: \"callDataHash\"\n    }, {\n      type: \"uint256\",\n      name: \"callGasLimit\"\n    }, {\n      type: \"uint256\",\n      name: \"verificationGasLimit\"\n    }, {\n      type: \"uint256\",\n      name: \"preVerificationGas\"\n    }, {\n      type: \"uint256\",\n      name: \"maxFeePerGas\"\n    }, {\n      type: \"uint256\",\n      name: \"maxPriorityFeePerGas\"\n    }, {\n      type: \"bytes32\",\n      name: \"paymasterAndDataHash\"\n    }],\n    name: \"hashedUserOp\",\n    type: \"tuple\"\n  };\n  const encoded = ethers__WEBPACK_IMPORTED_MODULE_3__.defaultAbiCoder.encode([userOpType], [{\n    ...hashedUserOp\n  }]);\n  // remove leading word (total length) and trailing word (zero-length signature)\n\n  const userOpHash = ethers__WEBPACK_IMPORTED_MODULE_2__.keccak256(encoded);\n  const enc = ethers__WEBPACK_IMPORTED_MODULE_3__.defaultAbiCoder.encode([\"bytes32\", \"address\", \"uint256\"], [userOpHash, entryPoint, chainId]);\n  return ethers__WEBPACK_IMPORTED_MODULE_2__.keccak256(enc);\n}\nconst generateRandomUint192 = () => {\n  const rand1 = BigInt(Math.floor(Math.random() * 0x100000000));\n  const rand2 = BigInt(Math.floor(Math.random() * 0x100000000));\n  const rand3 = BigInt(Math.floor(Math.random() * 0x100000000));\n  const rand4 = BigInt(Math.floor(Math.random() * 0x100000000));\n  const rand5 = BigInt(Math.floor(Math.random() * 0x100000000));\n  const rand6 = BigInt(Math.floor(Math.random() * 0x100000000));\n  return rand1 << BigInt(160) | rand2 << BigInt(128) | rand3 << BigInt(96) | rand4 << BigInt(64) | rand5 << BigInt(32) | rand6;\n};\nconst randomNonce = () => {\n  let hexString = generateRandomUint192().toString(16);\n  if (hexString.length % 2 !== 0) {\n    hexString = \"0\" + hexString;\n  }\n  hexString = \"0x\" + hexString;\n  return ethers__WEBPACK_IMPORTED_MODULE_4__.BigNumber.from(ethers__WEBPACK_IMPORTED_MODULE_1__.concat([hexString, \"0x0000000000000000\"]));\n};\n\nconst DEBUG = false; // TODO set as public flag\n\nclass HttpRpcClient {\n  constructor(bundlerUrl, entryPointAddress, chainId, clientId, secretKey) {\n    this.bundlerUrl = bundlerUrl;\n    this.entryPointAddress = entryPointAddress;\n    this.chainId = chainId;\n    const headers = {};\n    if ((0,_url_a45219bd_browser_esm_js__WEBPACK_IMPORTED_MODULE_5__.i)(this.bundlerUrl)) {\n      const bundleId = typeof globalThis !== \"undefined\" && \"APP_BUNDLE_ID\" in globalThis ? globalThis.APP_BUNDLE_ID : undefined;\n      if (secretKey) {\n        headers[\"x-secret-key\"] = secretKey;\n      } else if (clientId) {\n        headers[\"x-client-id\"] = clientId;\n        if (bundleId) {\n          headers[\"x-bundle-id\"] = bundleId;\n        }\n      }\n\n      // Dashboard token\n      if (typeof globalThis !== \"undefined\" && \"TW_AUTH_TOKEN\" in globalThis && typeof globalThis.TW_AUTH_TOKEN === \"string\") {\n        headers[\"authorization\"] = `Bearer ${globalThis.TW_AUTH_TOKEN}`;\n      }\n\n      // CLI token\n      if (typeof globalThis !== \"undefined\" && \"TW_CLI_AUTH_TOKEN\" in globalThis && typeof globalThis.TW_CLI_AUTH_TOKEN === \"string\") {\n        headers[\"authorization\"] = `Bearer ${globalThis.TW_CLI_AUTH_TOKEN}`;\n        headers[\"x-authorize-wallet\"] = \"true\";\n      }\n      (0,_headers_733a8199_browser_esm_js__WEBPACK_IMPORTED_MODULE_6__.s)(headers);\n    }\n    this.userOpJsonRpcProvider = new ethers__WEBPACK_IMPORTED_MODULE_7__.StaticJsonRpcProvider({\n      url: this.bundlerUrl,\n      headers\n    }, {\n      name: \"Connected bundler network\",\n      chainId\n    });\n    this.initializing = this.validateChainId();\n  }\n  async validateChainId() {\n    if (await (0,_utils_f58e7acc_browser_esm_js__WEBPACK_IMPORTED_MODULE_8__.e)(this.chainId)) {\n      return;\n    }\n    // validate chainId is in sync with expected chainid\n    const chain = await this.userOpJsonRpcProvider.send(\"eth_chainId\", []);\n    const bundlerChain = parseInt(chain);\n    if (bundlerChain !== this.chainId) {\n      throw new Error(`bundler ${this.bundlerUrl} is on chainId ${bundlerChain}, but provider is on chainId ${this.chainId}`);\n    }\n  }\n\n  /**\n   * send a UserOperation to the bundler\n   * @param userOp1 - The UserOperation to send\n   * @returns userOpHash the id of this operation, for getUserOperationTransaction\n   */\n  async sendUserOpToBundler(userOp1) {\n    await this.initializing;\n    const hexifiedUserOp = await hexlifyUserOp(userOp1);\n    const jsonRequestData = [hexifiedUserOp, this.entryPointAddress];\n    await this.printUserOperation(\"eth_sendUserOperation\", jsonRequestData);\n    return await this.userOpJsonRpcProvider.send(\"eth_sendUserOperation\", [hexifiedUserOp, this.entryPointAddress]);\n  }\n  async estimateUserOpGas(userOp) {\n    await this.initializing;\n    const hexifiedUserOp = await hexlifyUserOp(userOp);\n    const jsonRequestData = [hexifiedUserOp, this.entryPointAddress];\n    await this.printUserOperation(\"eth_estimateUserOperationGas\", jsonRequestData);\n    const data = await this.userOpJsonRpcProvider.send(\"eth_estimateUserOperationGas\", [hexifiedUserOp, this.entryPointAddress]);\n    // adds gas buffer to callGasLimit to account for ManagedAccountFactory delegate calls\n    return {\n      preVerificationGas: ethers__WEBPACK_IMPORTED_MODULE_4__.BigNumber.from(data.preVerificationGas),\n      verificationGas: ethers__WEBPACK_IMPORTED_MODULE_4__.BigNumber.from(data.verificationGas),\n      verificationGasLimit: ethers__WEBPACK_IMPORTED_MODULE_4__.BigNumber.from(data.verificationGasLimit),\n      callGasLimit: ethers__WEBPACK_IMPORTED_MODULE_4__.BigNumber.from(data.callGasLimit).add(_utils_f58e7acc_browser_esm_js__WEBPACK_IMPORTED_MODULE_8__.M)\n    };\n  }\n  async getUserOperationGasPrice() {\n    await this.initializing;\n    return await this.userOpJsonRpcProvider.send(\"thirdweb_getUserOperationGasPrice\", []);\n  }\n  async getUserOperationReceipt(userOpHash) {\n    await this.initializing;\n    return await this.userOpJsonRpcProvider.send(\"eth_getUserOperationReceipt\", [userOpHash]);\n  }\n  async zkPaymasterData(transactionInput) {\n    await this.initializing;\n    return await this.userOpJsonRpcProvider.send(\"zk_paymasterData\", [await hexlifyUserOp({\n      ...transactionInput,\n      gas: transactionInput.gasLimit\n    })]);\n  }\n  async zkBroadcastTransaction(transactionInput) {\n    await this.initializing;\n    return await this.userOpJsonRpcProvider.send(\"zk_broadcastTransaction\", [transactionInput]);\n  }\n  async printUserOperation(method, _ref) {\n    {\n      return;\n    }\n  }\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AdGhpcmR3ZWItZGV2L3dhbGxldHMvZGlzdC9odHRwLXJwYy1jbGllbnQtMGEwNzllODAuYnJvd3Nlci5lc20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBcUQ7QUFDUTtBQUNnQjtBQUN5Qjs7QUFFdEc7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHFEQUF1QjtBQUM5QztBQUNBO0FBQ0E7QUFDQSxZQUFZLDRDQUFjO0FBQzFCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsSUFBSTtBQUNQOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIscURBQXVCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiw2Q0FBZTtBQUNqQyxrQkFBa0IsNkNBQWU7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiw2Q0FBZTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixtREFBcUI7QUFDdkM7QUFDQSxHQUFHO0FBQ0g7O0FBRUEscUJBQXFCLDZDQUFlO0FBQ3BDLGNBQWMsbURBQXFCO0FBQ25DLFNBQVMsNkNBQWU7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLDZDQUFTLE1BQU0sMENBQVk7QUFDcEM7O0FBRUEscUJBQXFCOztBQUVyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLCtEQUFPO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDZDQUE2Qyx5QkFBeUI7QUFDdEU7O0FBRUE7QUFDQTtBQUNBLDZDQUE2Qyw2QkFBNkI7QUFDMUU7QUFDQTtBQUNBLE1BQU0sbUVBQW1CO0FBQ3pCO0FBQ0EscUNBQXFDLHlEQUErQjtBQUNwRTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsY0FBYyxpRUFBYTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsaUJBQWlCLGdCQUFnQixhQUFhLCtCQUErQixhQUFhO0FBQzNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiw2Q0FBUztBQUNuQyx1QkFBdUIsNkNBQVM7QUFDaEMsNEJBQTRCLDZDQUFTO0FBQ3JDLG9CQUFvQiw2Q0FBUyw2QkFBNkIsNkRBQTBCO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUV1RyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHRoaXJkd2ViLWRldi93YWxsZXRzL2Rpc3QvaHR0cC1ycGMtY2xpZW50LTBhMDc5ZTgwLmJyb3dzZXIuZXNtLmpzP2Q0ZTUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdXRpbHMsIEJpZ051bWJlciwgcHJvdmlkZXJzIH0gZnJvbSAnZXRoZXJzJztcbmltcG9ydCB7IGkgYXMgaXNUd1VybCB9IGZyb20gJy4vdXJsLWE0NTIxOWJkLmJyb3dzZXIuZXNtLmpzJztcbmltcG9ydCB7IHMgYXMgc2V0QW5hbHl0aWNzSGVhZGVycyB9IGZyb20gJy4vaGVhZGVycy03MzNhODE5OS5icm93c2VyLmVzbS5qcyc7XG5pbXBvcnQgeyBlIGFzIGlzWmtTeW5jQ2hhaW4sIE0gYXMgTUFOQUdFRF9BQ0NPVU5UX0dBU19CVUZGRVIgfSBmcm9tICcuL3V0aWxzLWY1OGU3YWNjLmJyb3dzZXIuZXNtLmpzJztcblxuYXN5bmMgZnVuY3Rpb24gaGV4bGlmeVVzZXJPcChcbi8vIFRPRE86IHR5cGVzXG5vcCkge1xuICBjb25zdCB1c2VyT3AgPSBhd2FpdCB1dGlscy5yZXNvbHZlUHJvcGVydGllcyhvcCk7XG4gIHJldHVybiBPYmplY3Qua2V5cyh1c2VyT3ApLm1hcChrZXkgPT4ge1xuICAgIGxldCB2YWwgPSB1c2VyT3Bba2V5XTtcbiAgICBpZiAodHlwZW9mIHZhbCAhPT0gXCJzdHJpbmdcIiB8fCAhdmFsLnN0YXJ0c1dpdGgoXCIweFwiKSkge1xuICAgICAgdmFsID0gdXRpbHMuaGV4VmFsdWUodmFsKTtcbiAgICB9XG4gICAgcmV0dXJuIFtrZXksIHZhbF07XG4gIH0pLnJlZHVjZSgoc2V0LCBfcmVmKSA9PiB7XG4gICAgbGV0IFtrLCB2XSA9IF9yZWY7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnNldCxcbiAgICAgIFtrXTogdlxuICAgIH07XG4gIH0sIHt9KTtcbn1cblxuLy8gdjAuNiB1c2VyT3BIYXNoIGNhbGN1bGF0aW9uXG5hc3luYyBmdW5jdGlvbiBnZXRVc2VyT3BIYXNoVjA2KHVzZXJPcCwgZW50cnlQb2ludCwgY2hhaW5JZCkge1xuICBjb25zdCBvcCA9IGF3YWl0IHV0aWxzLnJlc29sdmVQcm9wZXJ0aWVzKHVzZXJPcCk7XG4gIGNvbnN0IGhhc2hlZFVzZXJPcCA9IHtcbiAgICBzZW5kZXI6IG9wLnNlbmRlcixcbiAgICBub25jZTogb3Aubm9uY2UsXG4gICAgaW5pdENvZGVIYXNoOiB1dGlscy5rZWNjYWsyNTYob3AuaW5pdENvZGUpLFxuICAgIGNhbGxEYXRhSGFzaDogdXRpbHMua2VjY2FrMjU2KG9wLmNhbGxEYXRhKSxcbiAgICBjYWxsR2FzTGltaXQ6IG9wLmNhbGxHYXNMaW1pdCxcbiAgICB2ZXJpZmljYXRpb25HYXNMaW1pdDogb3AudmVyaWZpY2F0aW9uR2FzTGltaXQsXG4gICAgcHJlVmVyaWZpY2F0aW9uR2FzOiBvcC5wcmVWZXJpZmljYXRpb25HYXMsXG4gICAgbWF4RmVlUGVyR2FzOiBvcC5tYXhGZWVQZXJHYXMsXG4gICAgbWF4UHJpb3JpdHlGZWVQZXJHYXM6IG9wLm1heFByaW9yaXR5RmVlUGVyR2FzLFxuICAgIHBheW1hc3RlckFuZERhdGFIYXNoOiB1dGlscy5rZWNjYWsyNTYob3AucGF5bWFzdGVyQW5kRGF0YSlcbiAgfTtcbiAgY29uc3QgdXNlck9wVHlwZSA9IHtcbiAgICBjb21wb25lbnRzOiBbe1xuICAgICAgdHlwZTogXCJhZGRyZXNzXCIsXG4gICAgICBuYW1lOiBcInNlbmRlclwiXG4gICAgfSwge1xuICAgICAgdHlwZTogXCJ1aW50MjU2XCIsXG4gICAgICBuYW1lOiBcIm5vbmNlXCJcbiAgICB9LCB7XG4gICAgICB0eXBlOiBcImJ5dGVzMzJcIixcbiAgICAgIG5hbWU6IFwiaW5pdENvZGVIYXNoXCJcbiAgICB9LCB7XG4gICAgICB0eXBlOiBcImJ5dGVzMzJcIixcbiAgICAgIG5hbWU6IFwiY2FsbERhdGFIYXNoXCJcbiAgICB9LCB7XG4gICAgICB0eXBlOiBcInVpbnQyNTZcIixcbiAgICAgIG5hbWU6IFwiY2FsbEdhc0xpbWl0XCJcbiAgICB9LCB7XG4gICAgICB0eXBlOiBcInVpbnQyNTZcIixcbiAgICAgIG5hbWU6IFwidmVyaWZpY2F0aW9uR2FzTGltaXRcIlxuICAgIH0sIHtcbiAgICAgIHR5cGU6IFwidWludDI1NlwiLFxuICAgICAgbmFtZTogXCJwcmVWZXJpZmljYXRpb25HYXNcIlxuICAgIH0sIHtcbiAgICAgIHR5cGU6IFwidWludDI1NlwiLFxuICAgICAgbmFtZTogXCJtYXhGZWVQZXJHYXNcIlxuICAgIH0sIHtcbiAgICAgIHR5cGU6IFwidWludDI1NlwiLFxuICAgICAgbmFtZTogXCJtYXhQcmlvcml0eUZlZVBlckdhc1wiXG4gICAgfSwge1xuICAgICAgdHlwZTogXCJieXRlczMyXCIsXG4gICAgICBuYW1lOiBcInBheW1hc3RlckFuZERhdGFIYXNoXCJcbiAgICB9XSxcbiAgICBuYW1lOiBcImhhc2hlZFVzZXJPcFwiLFxuICAgIHR5cGU6IFwidHVwbGVcIlxuICB9O1xuICBjb25zdCBlbmNvZGVkID0gdXRpbHMuZGVmYXVsdEFiaUNvZGVyLmVuY29kZShbdXNlck9wVHlwZV0sIFt7XG4gICAgLi4uaGFzaGVkVXNlck9wXG4gIH1dKTtcbiAgLy8gcmVtb3ZlIGxlYWRpbmcgd29yZCAodG90YWwgbGVuZ3RoKSBhbmQgdHJhaWxpbmcgd29yZCAoemVyby1sZW5ndGggc2lnbmF0dXJlKVxuXG4gIGNvbnN0IHVzZXJPcEhhc2ggPSB1dGlscy5rZWNjYWsyNTYoZW5jb2RlZCk7XG4gIGNvbnN0IGVuYyA9IHV0aWxzLmRlZmF1bHRBYmlDb2Rlci5lbmNvZGUoW1wiYnl0ZXMzMlwiLCBcImFkZHJlc3NcIiwgXCJ1aW50MjU2XCJdLCBbdXNlck9wSGFzaCwgZW50cnlQb2ludCwgY2hhaW5JZF0pO1xuICByZXR1cm4gdXRpbHMua2VjY2FrMjU2KGVuYyk7XG59XG5jb25zdCBnZW5lcmF0ZVJhbmRvbVVpbnQxOTIgPSAoKSA9PiB7XG4gIGNvbnN0IHJhbmQxID0gQmlnSW50KE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDB4MTAwMDAwMDAwKSk7XG4gIGNvbnN0IHJhbmQyID0gQmlnSW50KE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDB4MTAwMDAwMDAwKSk7XG4gIGNvbnN0IHJhbmQzID0gQmlnSW50KE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDB4MTAwMDAwMDAwKSk7XG4gIGNvbnN0IHJhbmQ0ID0gQmlnSW50KE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDB4MTAwMDAwMDAwKSk7XG4gIGNvbnN0IHJhbmQ1ID0gQmlnSW50KE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDB4MTAwMDAwMDAwKSk7XG4gIGNvbnN0IHJhbmQ2ID0gQmlnSW50KE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDB4MTAwMDAwMDAwKSk7XG4gIHJldHVybiByYW5kMSA8PCBCaWdJbnQoMTYwKSB8IHJhbmQyIDw8IEJpZ0ludCgxMjgpIHwgcmFuZDMgPDwgQmlnSW50KDk2KSB8IHJhbmQ0IDw8IEJpZ0ludCg2NCkgfCByYW5kNSA8PCBCaWdJbnQoMzIpIHwgcmFuZDY7XG59O1xuY29uc3QgcmFuZG9tTm9uY2UgPSAoKSA9PiB7XG4gIGxldCBoZXhTdHJpbmcgPSBnZW5lcmF0ZVJhbmRvbVVpbnQxOTIoKS50b1N0cmluZygxNik7XG4gIGlmIChoZXhTdHJpbmcubGVuZ3RoICUgMiAhPT0gMCkge1xuICAgIGhleFN0cmluZyA9IFwiMFwiICsgaGV4U3RyaW5nO1xuICB9XG4gIGhleFN0cmluZyA9IFwiMHhcIiArIGhleFN0cmluZztcbiAgcmV0dXJuIEJpZ051bWJlci5mcm9tKHV0aWxzLmNvbmNhdChbaGV4U3RyaW5nLCBcIjB4MDAwMDAwMDAwMDAwMDAwMFwiXSkpO1xufTtcblxuY29uc3QgREVCVUcgPSBmYWxzZTsgLy8gVE9ETyBzZXQgYXMgcHVibGljIGZsYWdcblxuY2xhc3MgSHR0cFJwY0NsaWVudCB7XG4gIGNvbnN0cnVjdG9yKGJ1bmRsZXJVcmwsIGVudHJ5UG9pbnRBZGRyZXNzLCBjaGFpbklkLCBjbGllbnRJZCwgc2VjcmV0S2V5KSB7XG4gICAgdGhpcy5idW5kbGVyVXJsID0gYnVuZGxlclVybDtcbiAgICB0aGlzLmVudHJ5UG9pbnRBZGRyZXNzID0gZW50cnlQb2ludEFkZHJlc3M7XG4gICAgdGhpcy5jaGFpbklkID0gY2hhaW5JZDtcbiAgICBjb25zdCBoZWFkZXJzID0ge307XG4gICAgaWYgKGlzVHdVcmwodGhpcy5idW5kbGVyVXJsKSkge1xuICAgICAgY29uc3QgYnVuZGxlSWQgPSB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBcIkFQUF9CVU5ETEVfSURcIiBpbiBnbG9iYWxUaGlzID8gZ2xvYmFsVGhpcy5BUFBfQlVORExFX0lEIDogdW5kZWZpbmVkO1xuICAgICAgaWYgKHNlY3JldEtleSkge1xuICAgICAgICBoZWFkZXJzW1wieC1zZWNyZXQta2V5XCJdID0gc2VjcmV0S2V5O1xuICAgICAgfSBlbHNlIGlmIChjbGllbnRJZCkge1xuICAgICAgICBoZWFkZXJzW1wieC1jbGllbnQtaWRcIl0gPSBjbGllbnRJZDtcbiAgICAgICAgaWYgKGJ1bmRsZUlkKSB7XG4gICAgICAgICAgaGVhZGVyc1tcIngtYnVuZGxlLWlkXCJdID0gYnVuZGxlSWQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gRGFzaGJvYXJkIHRva2VuXG4gICAgICBpZiAodHlwZW9mIGdsb2JhbFRoaXMgIT09IFwidW5kZWZpbmVkXCIgJiYgXCJUV19BVVRIX1RPS0VOXCIgaW4gZ2xvYmFsVGhpcyAmJiB0eXBlb2YgZ2xvYmFsVGhpcy5UV19BVVRIX1RPS0VOID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGhlYWRlcnNbXCJhdXRob3JpemF0aW9uXCJdID0gYEJlYXJlciAke2dsb2JhbFRoaXMuVFdfQVVUSF9UT0tFTn1gO1xuICAgICAgfVxuXG4gICAgICAvLyBDTEkgdG9rZW5cbiAgICAgIGlmICh0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBcIlRXX0NMSV9BVVRIX1RPS0VOXCIgaW4gZ2xvYmFsVGhpcyAmJiB0eXBlb2YgZ2xvYmFsVGhpcy5UV19DTElfQVVUSF9UT0tFTiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBoZWFkZXJzW1wiYXV0aG9yaXphdGlvblwiXSA9IGBCZWFyZXIgJHtnbG9iYWxUaGlzLlRXX0NMSV9BVVRIX1RPS0VOfWA7XG4gICAgICAgIGhlYWRlcnNbXCJ4LWF1dGhvcml6ZS13YWxsZXRcIl0gPSBcInRydWVcIjtcbiAgICAgIH1cbiAgICAgIHNldEFuYWx5dGljc0hlYWRlcnMoaGVhZGVycyk7XG4gICAgfVxuICAgIHRoaXMudXNlck9wSnNvblJwY1Byb3ZpZGVyID0gbmV3IHByb3ZpZGVycy5TdGF0aWNKc29uUnBjUHJvdmlkZXIoe1xuICAgICAgdXJsOiB0aGlzLmJ1bmRsZXJVcmwsXG4gICAgICBoZWFkZXJzXG4gICAgfSwge1xuICAgICAgbmFtZTogXCJDb25uZWN0ZWQgYnVuZGxlciBuZXR3b3JrXCIsXG4gICAgICBjaGFpbklkXG4gICAgfSk7XG4gICAgdGhpcy5pbml0aWFsaXppbmcgPSB0aGlzLnZhbGlkYXRlQ2hhaW5JZCgpO1xuICB9XG4gIGFzeW5jIHZhbGlkYXRlQ2hhaW5JZCgpIHtcbiAgICBpZiAoYXdhaXQgaXNaa1N5bmNDaGFpbih0aGlzLmNoYWluSWQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIHZhbGlkYXRlIGNoYWluSWQgaXMgaW4gc3luYyB3aXRoIGV4cGVjdGVkIGNoYWluaWRcbiAgICBjb25zdCBjaGFpbiA9IGF3YWl0IHRoaXMudXNlck9wSnNvblJwY1Byb3ZpZGVyLnNlbmQoXCJldGhfY2hhaW5JZFwiLCBbXSk7XG4gICAgY29uc3QgYnVuZGxlckNoYWluID0gcGFyc2VJbnQoY2hhaW4pO1xuICAgIGlmIChidW5kbGVyQ2hhaW4gIT09IHRoaXMuY2hhaW5JZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBidW5kbGVyICR7dGhpcy5idW5kbGVyVXJsfSBpcyBvbiBjaGFpbklkICR7YnVuZGxlckNoYWlufSwgYnV0IHByb3ZpZGVyIGlzIG9uIGNoYWluSWQgJHt0aGlzLmNoYWluSWR9YCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIHNlbmQgYSBVc2VyT3BlcmF0aW9uIHRvIHRoZSBidW5kbGVyXG4gICAqIEBwYXJhbSB1c2VyT3AxIC0gVGhlIFVzZXJPcGVyYXRpb24gdG8gc2VuZFxuICAgKiBAcmV0dXJucyB1c2VyT3BIYXNoIHRoZSBpZCBvZiB0aGlzIG9wZXJhdGlvbiwgZm9yIGdldFVzZXJPcGVyYXRpb25UcmFuc2FjdGlvblxuICAgKi9cbiAgYXN5bmMgc2VuZFVzZXJPcFRvQnVuZGxlcih1c2VyT3AxKSB7XG4gICAgYXdhaXQgdGhpcy5pbml0aWFsaXppbmc7XG4gICAgY29uc3QgaGV4aWZpZWRVc2VyT3AgPSBhd2FpdCBoZXhsaWZ5VXNlck9wKHVzZXJPcDEpO1xuICAgIGNvbnN0IGpzb25SZXF1ZXN0RGF0YSA9IFtoZXhpZmllZFVzZXJPcCwgdGhpcy5lbnRyeVBvaW50QWRkcmVzc107XG4gICAgYXdhaXQgdGhpcy5wcmludFVzZXJPcGVyYXRpb24oXCJldGhfc2VuZFVzZXJPcGVyYXRpb25cIiwganNvblJlcXVlc3REYXRhKTtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy51c2VyT3BKc29uUnBjUHJvdmlkZXIuc2VuZChcImV0aF9zZW5kVXNlck9wZXJhdGlvblwiLCBbaGV4aWZpZWRVc2VyT3AsIHRoaXMuZW50cnlQb2ludEFkZHJlc3NdKTtcbiAgfVxuICBhc3luYyBlc3RpbWF0ZVVzZXJPcEdhcyh1c2VyT3ApIHtcbiAgICBhd2FpdCB0aGlzLmluaXRpYWxpemluZztcbiAgICBjb25zdCBoZXhpZmllZFVzZXJPcCA9IGF3YWl0IGhleGxpZnlVc2VyT3AodXNlck9wKTtcbiAgICBjb25zdCBqc29uUmVxdWVzdERhdGEgPSBbaGV4aWZpZWRVc2VyT3AsIHRoaXMuZW50cnlQb2ludEFkZHJlc3NdO1xuICAgIGF3YWl0IHRoaXMucHJpbnRVc2VyT3BlcmF0aW9uKFwiZXRoX2VzdGltYXRlVXNlck9wZXJhdGlvbkdhc1wiLCBqc29uUmVxdWVzdERhdGEpO1xuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCB0aGlzLnVzZXJPcEpzb25ScGNQcm92aWRlci5zZW5kKFwiZXRoX2VzdGltYXRlVXNlck9wZXJhdGlvbkdhc1wiLCBbaGV4aWZpZWRVc2VyT3AsIHRoaXMuZW50cnlQb2ludEFkZHJlc3NdKTtcbiAgICAvLyBhZGRzIGdhcyBidWZmZXIgdG8gY2FsbEdhc0xpbWl0IHRvIGFjY291bnQgZm9yIE1hbmFnZWRBY2NvdW50RmFjdG9yeSBkZWxlZ2F0ZSBjYWxsc1xuICAgIHJldHVybiB7XG4gICAgICBwcmVWZXJpZmljYXRpb25HYXM6IEJpZ051bWJlci5mcm9tKGRhdGEucHJlVmVyaWZpY2F0aW9uR2FzKSxcbiAgICAgIHZlcmlmaWNhdGlvbkdhczogQmlnTnVtYmVyLmZyb20oZGF0YS52ZXJpZmljYXRpb25HYXMpLFxuICAgICAgdmVyaWZpY2F0aW9uR2FzTGltaXQ6IEJpZ051bWJlci5mcm9tKGRhdGEudmVyaWZpY2F0aW9uR2FzTGltaXQpLFxuICAgICAgY2FsbEdhc0xpbWl0OiBCaWdOdW1iZXIuZnJvbShkYXRhLmNhbGxHYXNMaW1pdCkuYWRkKE1BTkFHRURfQUNDT1VOVF9HQVNfQlVGRkVSKVxuICAgIH07XG4gIH1cbiAgYXN5bmMgZ2V0VXNlck9wZXJhdGlvbkdhc1ByaWNlKCkge1xuICAgIGF3YWl0IHRoaXMuaW5pdGlhbGl6aW5nO1xuICAgIHJldHVybiBhd2FpdCB0aGlzLnVzZXJPcEpzb25ScGNQcm92aWRlci5zZW5kKFwidGhpcmR3ZWJfZ2V0VXNlck9wZXJhdGlvbkdhc1ByaWNlXCIsIFtdKTtcbiAgfVxuICBhc3luYyBnZXRVc2VyT3BlcmF0aW9uUmVjZWlwdCh1c2VyT3BIYXNoKSB7XG4gICAgYXdhaXQgdGhpcy5pbml0aWFsaXppbmc7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMudXNlck9wSnNvblJwY1Byb3ZpZGVyLnNlbmQoXCJldGhfZ2V0VXNlck9wZXJhdGlvblJlY2VpcHRcIiwgW3VzZXJPcEhhc2hdKTtcbiAgfVxuICBhc3luYyB6a1BheW1hc3RlckRhdGEodHJhbnNhY3Rpb25JbnB1dCkge1xuICAgIGF3YWl0IHRoaXMuaW5pdGlhbGl6aW5nO1xuICAgIHJldHVybiBhd2FpdCB0aGlzLnVzZXJPcEpzb25ScGNQcm92aWRlci5zZW5kKFwiemtfcGF5bWFzdGVyRGF0YVwiLCBbYXdhaXQgaGV4bGlmeVVzZXJPcCh7XG4gICAgICAuLi50cmFuc2FjdGlvbklucHV0LFxuICAgICAgZ2FzOiB0cmFuc2FjdGlvbklucHV0Lmdhc0xpbWl0XG4gICAgfSldKTtcbiAgfVxuICBhc3luYyB6a0Jyb2FkY2FzdFRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uSW5wdXQpIHtcbiAgICBhd2FpdCB0aGlzLmluaXRpYWxpemluZztcbiAgICByZXR1cm4gYXdhaXQgdGhpcy51c2VyT3BKc29uUnBjUHJvdmlkZXIuc2VuZChcInprX2Jyb2FkY2FzdFRyYW5zYWN0aW9uXCIsIFt0cmFuc2FjdGlvbklucHV0XSk7XG4gIH1cbiAgYXN5bmMgcHJpbnRVc2VyT3BlcmF0aW9uKG1ldGhvZCwgX3JlZikge1xuICAgIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IHsgREVCVUcgYXMgRCwgSHR0cFJwY0NsaWVudCBhcyBILCBnZXRVc2VyT3BIYXNoVjA2IGFzIGcsIGhleGxpZnlVc2VyT3AgYXMgaCwgcmFuZG9tTm9uY2UgYXMgciB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@thirdweb-dev/wallets/dist/http-rpc-client-0a079e80.browser.esm.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@thirdweb-dev/wallets/evm/connectors/smart-wallet/dist/thirdweb-dev-wallets-evm-connectors-smart-wallet.browser.esm.js":
/*!*********************************************************************************************************************************************!*\
  !*** ./node_modules/@thirdweb-dev/wallets/evm/connectors/smart-wallet/dist/thirdweb-dev-wallets-evm-connectors-smart-wallet.browser.esm.js ***!
  \*********************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SmartWalletConnector: function() { return /* binding */ SmartWalletConnector; }\n/* harmony export */ });\n/* harmony import */ var _dist_connector_05689d68_browser_esm_js__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ../../../../dist/connector-05689d68.browser.esm.js */ \"(app-pages-browser)/./node_modules/@thirdweb-dev/wallets/dist/connector-05689d68.browser.esm.js\");\n/* harmony import */ var _dist_http_rpc_client_0a079e80_browser_esm_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../../dist/http-rpc-client-0a079e80.browser.esm.js */ \"(app-pages-browser)/./node_modules/@thirdweb-dev/wallets/dist/http-rpc-client-0a079e80.browser.esm.js\");\n/* harmony import */ var _dist_url_a45219bd_browser_esm_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../../dist/url-a45219bd.browser.esm.js */ \"(app-pages-browser)/./node_modules/@thirdweb-dev/wallets/dist/url-a45219bd.browser.esm.js\");\n/* harmony import */ var _dist_headers_733a8199_browser_esm_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../../dist/headers-733a8199.browser.esm.js */ \"(app-pages-browser)/./node_modules/@thirdweb-dev/wallets/dist/headers-733a8199.browser.esm.js\");\n/* harmony import */ var _account_abstraction_contracts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @account-abstraction/contracts */ \"(app-pages-browser)/./node_modules/@account-abstraction/contracts/dist/index.js\");\n/* harmony import */ var _account_abstraction_contracts__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_account_abstraction_contracts__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/./node_modules/@ethersproject/abi/lib.esm/abi-coder.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/./node_modules/@ethersproject/abstract-signer/lib.esm/index.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/./node_modules/@ethersproject/properties/lib.esm/index.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/./node_modules/@ethersproject/hash/lib.esm/message.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/./node_modules/@ethersproject/providers/lib.esm/url-json-rpc-provider.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/./node_modules/@ethersproject/contracts/lib.esm/index.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/./node_modules/@ethersproject/providers/lib.esm/base-provider.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/./node_modules/@ethersproject/bignumber/lib.esm/bignumber.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/./node_modules/@ethersproject/bytes/lib.esm/index.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/./node_modules/@ethersproject/constants/lib.esm/addresses.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/./node_modules/@ethersproject/wallet/lib.esm/index.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/./node_modules/@ethersproject/address/lib.esm/index.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/./node_modules/@ethersproject/strings/lib.esm/utf8.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/./node_modules/@ethersproject/units/lib.esm/index.js\");\n/* harmony import */ var _dist_defineProperty_350fc508_browser_esm_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../../dist/defineProperty-350fc508.browser.esm.js */ \"(app-pages-browser)/./node_modules/@thirdweb-dev/wallets/dist/defineProperty-350fc508.browser.esm.js\");\n/* harmony import */ var _thirdweb_dev_sdk__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @thirdweb-dev/sdk */ \"(app-pages-browser)/./node_modules/@thirdweb-dev/sdk/dist/index-33cd3415.browser.esm.js\");\n/* harmony import */ var _thirdweb_dev_sdk__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! @thirdweb-dev/sdk */ \"(app-pages-browser)/./node_modules/@thirdweb-dev/sdk/dist/transactions-72f9603c.browser.esm.js\");\n/* harmony import */ var _thirdweb_dev_sdk__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! @thirdweb-dev/sdk */ \"(app-pages-browser)/./node_modules/@thirdweb-dev/sdk/dist/sdk-3e21fc5c.browser.esm.js\");\n/* harmony import */ var _wallets_abstract_dist_thirdweb_dev_wallets_evm_wallets_abstract_browser_esm_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../wallets/abstract/dist/thirdweb-dev-wallets-evm-wallets-abstract.browser.esm.js */ \"(app-pages-browser)/./node_modules/@thirdweb-dev/wallets/evm/wallets/abstract/dist/thirdweb-dev-wallets-evm-wallets-abstract.browser.esm.js\");\n/* harmony import */ var _dist_utils_f58e7acc_browser_esm_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../../../../dist/utils-f58e7acc.browser.esm.js */ \"(app-pages-browser)/./node_modules/@thirdweb-dev/wallets/dist/utils-f58e7acc.browser.esm.js\");\n/* harmony import */ var _thirdweb_dev_chains__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! @thirdweb-dev/chains */ \"(app-pages-browser)/./node_modules/@thirdweb-dev/chains/dist/thirdweb-dev-chains.esm.js\");\n/* harmony import */ var eventemitter3__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! eventemitter3 */ \"(app-pages-browser)/./node_modules/eventemitter3/index.mjs\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * @internal\n */\n\n/**\n * @internal\n */\n\n/**\n * an API to external a UserOperation with paymaster info\n */\nclass PaymasterAPI {}\n\nclass VerifyingPaymasterAPI extends PaymasterAPI {\n  constructor(paymasterUrl, entryPoint, clientId, secretKey) {\n    super();\n    this.paymasterUrl = paymasterUrl;\n    this.entryPoint = entryPoint;\n    this.clientId = clientId;\n    this.secretKey = secretKey;\n  }\n  async getPaymasterAndData(userOp) {\n    const headers = {\n      \"Content-Type\": \"application/json\"\n    };\n    if ((0,_dist_url_a45219bd_browser_esm_js__WEBPACK_IMPORTED_MODULE_3__.i)(this.paymasterUrl)) {\n      if (this.secretKey && this.clientId) {\n        throw new Error(\"Cannot use both secret key and client ID. Please use secretKey for server-side applications and clientId for client-side applications.\");\n      }\n      if (this.secretKey) {\n        headers[\"x-secret-key\"] = this.secretKey;\n      } else if (this.clientId) {\n        headers[\"x-client-id\"] = this.clientId;\n        const bundleId = typeof globalThis !== \"undefined\" && \"APP_BUNDLE_ID\" in globalThis ? globalThis.APP_BUNDLE_ID : undefined;\n        if (bundleId) {\n          headers[\"x-bundle-id\"] = bundleId;\n        }\n      }\n\n      // Dashboard token.\n      if (typeof globalThis !== \"undefined\" && \"TW_AUTH_TOKEN\" in globalThis && typeof globalThis.TW_AUTH_TOKEN === \"string\") {\n        headers[\"authorization\"] = `Bearer ${globalThis.TW_AUTH_TOKEN}`;\n      }\n\n      // CLI token.\n      if (typeof globalThis !== \"undefined\" && \"TW_CLI_AUTH_TOKEN\" in globalThis && typeof globalThis.TW_CLI_AUTH_TOKEN === \"string\") {\n        headers[\"authorization\"] = `Bearer ${globalThis.TW_CLI_AUTH_TOKEN}`;\n        headers[\"x-authorize-wallet\"] = \"true\";\n      }\n      (0,_dist_headers_733a8199_browser_esm_js__WEBPACK_IMPORTED_MODULE_4__.s)(headers);\n    }\n\n    // Ask the paymaster to sign the transaction and return a valid paymasterAndData value.\n    const response = await fetch(this.paymasterUrl, {\n      method: \"POST\",\n      headers,\n      body: JSON.stringify({\n        jsonrpc: \"2.0\",\n        id: 1,\n        method: \"pm_sponsorUserOperation\",\n        params: [await (0,_dist_http_rpc_client_0a079e80_browser_esm_js__WEBPACK_IMPORTED_MODULE_5__.h)(userOp), this.entryPoint]\n      })\n    });\n    const res = await response.json();\n    if (!response.ok) {\n      const error = res.error || response.statusText;\n      const code = res.code || \"UNKNOWN\";\n      throw new Error(`Paymaster error: ${error}\nStatus: ${response.status}\nCode: ${code}`);\n    }\n    if (_dist_http_rpc_client_0a079e80_browser_esm_js__WEBPACK_IMPORTED_MODULE_5__.D) {\n      console.debug(\"Paymaster result:\", res);\n    }\n    if (res.result) {\n      // some paymasters return a string, some return an object with more data\n      if (typeof res.result === \"string\") {\n        return {\n          paymasterAndData: res.result\n        };\n      } else {\n        return res.result;\n      }\n    } else {\n      const error = res.error?.message || res.error || response.statusText || \"unknown error\";\n      throw new Error(`Paymaster error from ${this.paymasterUrl}: ${error}`);\n    }\n  }\n}\nconst getVerifyingPaymaster = (paymasterUrl, entryPoint, clientId, secretKey) => new VerifyingPaymasterAPI(paymasterUrl, entryPoint, clientId, secretKey);\n\n/**\n * This class encapsulates Ethers.js listener function and necessary UserOperation details to\n * discover a TransactionReceipt for the operation.\n *\n * TODO refactor this to a simple event listener on the entry point\n */\nclass UserOperationEventListener {\n  constructor(resolve, reject, entryPoint, sender, userOpHash, nonce, timeout) {\n    this.resolve = resolve;\n    this.reject = reject;\n    this.entryPoint = entryPoint;\n    this.sender = sender;\n    this.userOpHash = userOpHash;\n    this.nonce = nonce;\n    this.timeout = timeout;\n    (0,_dist_defineProperty_350fc508_browser_esm_js__WEBPACK_IMPORTED_MODULE_6__._)(this, \"resolved\", false);\n    // eslint-disable-next-line @typescript-eslint/no-misused-promises\n    this.boundLisener = this.listenerCallback.bind(this);\n  }\n  start() {\n    // eslint-disable-next-line @typescript-eslint/no-misused-promises\n    const filter = this.entryPoint.filters.UserOperationEvent(this.userOpHash);\n    // listener takes time... first query directly:\n    // eslint-disable-next-line @typescript-eslint/no-misused-promises\n    setTimeout(async () => {\n      const res = await this.entryPoint.queryFilter(filter, -10); // look at last 10 blocks\n      if (res.length > 0) {\n        void this.listenerCallback(res[0]);\n      } else {\n        this.entryPoint.once(filter, this.boundLisener);\n      }\n    }, 100);\n  }\n  stop() {\n    // eslint-disable-next-line @typescript-eslint/no-misused-promises\n    this.entryPoint.off(\"UserOperationEvent\", this.boundLisener);\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  async listenerCallback() {\n    for (var _len = arguments.length, param = new Array(_len), _key = 0; _key < _len; _key++) {\n      param[_key] = arguments[_key];\n    }\n    // TODO clean this up..\n    // eslint-disable-next-line prefer-rest-params\n    const event = arguments[arguments.length - 1];\n    if (!event.args) {\n      console.error(\"got event without args\", event);\n      return;\n    }\n    // TODO: can this happen? we register to event by userOpHash..\n    if (event.args.userOpHash !== this.userOpHash) {\n      console.log(`== event with wrong userOpHash: sender/nonce: event.${event.args.sender}@${event.args.nonce.toString()}!= userOp.${this.sender}@${parseInt(this.nonce?.toString())}`);\n      return;\n    }\n    const transactionReceipt = await event.getTransactionReceipt();\n\n    // before returning the receipt, update the status from the event.\n    // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n    if (!event.args.success) {\n      await this.extractFailureReason(transactionReceipt);\n    }\n    this.stop();\n    this.resolve(transactionReceipt);\n    this.resolved = true;\n  }\n  async extractFailureReason(receipt) {\n    receipt.status = 0;\n    const revertReasonEvents = await this.entryPoint.queryFilter(this.entryPoint.filters.UserOperationRevertReason(this.userOpHash, this.sender), receipt.blockHash);\n    if (revertReasonEvents[0]) {\n      let message = revertReasonEvents[0].args.revertReason;\n      if (message.startsWith(\"0x08c379a0\")) {\n        // Error(string)\n        message = ethers__WEBPACK_IMPORTED_MODULE_7__.defaultAbiCoder.decode([\"string\"], \"0x\" + message.substring(10)).toString();\n      }\n      this.reject(new Error(`UserOp failed with reason: ${message}`));\n    }\n  }\n}\n\nclass ERC4337EthersSigner extends ethers__WEBPACK_IMPORTED_MODULE_8__.Signer {\n  // TODO: we have 'erc4337provider', remove shared dependencies or avoid two-way reference\n  constructor(config, originalSigner, erc4337provider, httpRpcClient, smartAccountAPI) {\n    super();\n    ethers__WEBPACK_IMPORTED_MODULE_9__.defineReadOnly(this, \"provider\", erc4337provider);\n    this.config = config;\n    this.originalSigner = originalSigner;\n    this.erc4337provider = erc4337provider;\n    this.httpRpcClient = httpRpcClient;\n    this.smartAccountAPI = smartAccountAPI;\n    this.approving = false;\n  }\n  // This one is called by Contract. It signs the request and passes in to Provider to be sent.\n  async sendTransaction(transaction, options) {\n    if (!this.approving) {\n      this.approving = true;\n      const tx = await this.smartAccountAPI.createApproveTx();\n      if (tx) {\n        await (await this.sendTransaction(tx)).wait();\n      }\n      this.approving = false;\n    }\n    const tx = await ethers__WEBPACK_IMPORTED_MODULE_9__.resolveProperties(transaction);\n    await this.verifyAllNecessaryFields(tx);\n    const multidimensionalNonce = (0,_dist_http_rpc_client_0a079e80_browser_esm_js__WEBPACK_IMPORTED_MODULE_5__.r)();\n    const unsigned = await this.smartAccountAPI.createUnsignedUserOp(this.httpRpcClient, {\n      target: tx.to || \"\",\n      data: tx.data?.toString() || \"0x\",\n      value: tx.value,\n      gasLimit: tx.gasLimit,\n      nonce: multidimensionalNonce,\n      maxFeePerGas: tx.maxFeePerGas,\n      maxPriorityFeePerGas: tx.maxPriorityFeePerGas\n    }, options);\n    const userOperation = await this.smartAccountAPI.signUserOp(unsigned);\n    const transactionResponse = await this.erc4337provider.constructUserOpTransactionResponse(userOperation);\n    try {\n      await this.httpRpcClient.sendUserOpToBundler(userOperation);\n    } catch (error) {\n      throw this.unwrapError(error);\n    }\n    // TODO: handle errors - transaction that is \"rejected\" by bundler is _not likely_ to ever resolve its \"wait()\"\n    return transactionResponse;\n  }\n  unwrapError(errorIn) {\n    try {\n      let errorMsg = \"Unknown Error\";\n      if (errorIn.error) {\n        errorMsg = `The bundler has failed to include UserOperation in a batch: ${errorIn.error}`;\n      } else if (errorIn.body && typeof errorIn.body === \"string\") {\n        const errorBody = JSON.parse(errorIn.body);\n        const errorStatus = errorIn.status || \"UNKNOWN\";\n        const errorCode = errorBody?.code || \"UNKNOWN\";\n        let failedOpMessage = errorBody?.error?.message || errorBody?.error?.data || errorBody?.error || errorIn.reason;\n        if (failedOpMessage?.includes(\"FailedOp\")) {\n          let paymasterInfo = \"\";\n          // TODO: better error extraction methods will be needed\n          const matched = failedOpMessage.match(/FailedOp\\((.*)\\)/);\n          if (matched) {\n            const split = matched[1].split(\",\");\n            paymasterInfo = `(paymaster address: ${split[1]})`;\n            failedOpMessage = split[2];\n          }\n          errorMsg = `The bundler has failed to include UserOperation in a batch: ${failedOpMessage} ${paymasterInfo}`;\n        } else {\n          errorMsg = `RPC error: ${failedOpMessage}\nStatus: ${errorStatus}\nCode: ${errorCode}`;\n        }\n      }\n      const error = new Error(errorMsg);\n      error.stack = errorIn.stack;\n      return error;\n    } catch (error) {}\n    return errorIn;\n  }\n  async verifyAllNecessaryFields(transactionRequest) {\n    if (!transactionRequest.to) {\n      throw new Error(\"Missing call target\");\n    }\n    if (!transactionRequest.data && !transactionRequest.value) {\n      // TBD: banning no-op UserOps seems to make sense on provider level\n      throw new Error(\"Missing call data or value\");\n    }\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  connect(provider) {\n    throw new Error(\"changing providers is not supported\");\n  }\n  async getAddress() {\n    if (!this.address) {\n      this.address = await this.erc4337provider.getSenderAccountAddress();\n    }\n    return this.address;\n  }\n\n  /**\n   * Sign a message and return the signature\n   */\n  async signMessage(message) {\n    // Deploy smart wallet if needed\n    const isNotDeployed = await this.smartAccountAPI.checkAccountPhantom();\n    if (isNotDeployed) {\n      console.log(\"Account contract not deployed yet. Deploying account before signing message\");\n      const tx = await this.sendTransaction({\n        to: await this.getAddress(),\n        data: \"0x\"\n      });\n      await tx.wait();\n    }\n    const [chainId, address] = await Promise.all([this.getChainId(), this.getAddress()]);\n    const originalMsgHash = ethers__WEBPACK_IMPORTED_MODULE_10__.hashMessage(message);\n    let factorySupports712;\n    let signature;\n    const rpcUrl = (0,_wallets_abstract_dist_thirdweb_dev_wallets_evm_wallets_abstract_browser_esm_js__WEBPACK_IMPORTED_MODULE_1__.chainIdToThirdwebRpc)(chainId, this.config.clientId);\n    const headers = {};\n    if ((0,_dist_url_a45219bd_browser_esm_js__WEBPACK_IMPORTED_MODULE_3__.i)(rpcUrl)) {\n      const bundleId = typeof globalThis !== \"undefined\" && \"APP_BUNDLE_ID\" in globalThis ? globalThis.APP_BUNDLE_ID : undefined;\n      if (this.config.secretKey) {\n        headers[\"x-secret-key\"] = this.config.secretKey;\n      } else if (this.config.clientId) {\n        headers[\"x-client-id\"] = this.config.clientId;\n        if (bundleId) {\n          headers[\"x-bundle-id\"] = bundleId;\n        }\n      }\n\n      // Dashboard token\n      if (typeof globalThis !== \"undefined\" && \"TW_AUTH_TOKEN\" in globalThis && typeof globalThis.TW_AUTH_TOKEN === \"string\") {\n        headers[\"authorization\"] = `Bearer ${globalThis.TW_AUTH_TOKEN}`;\n      }\n\n      // CLI token\n      if (typeof globalThis !== \"undefined\" && \"TW_CLI_AUTH_TOKEN\" in globalThis && typeof globalThis.TW_CLI_AUTH_TOKEN === \"string\") {\n        headers[\"authorization\"] = `Bearer ${globalThis.TW_CLI_AUTH_TOKEN}`;\n        headers[\"x-authorize-wallet\"] = \"true\";\n      }\n      (0,_dist_headers_733a8199_browser_esm_js__WEBPACK_IMPORTED_MODULE_4__.s)(headers);\n    }\n    try {\n      const provider = new ethers__WEBPACK_IMPORTED_MODULE_11__.StaticJsonRpcProvider({\n        url: rpcUrl,\n        headers\n      }, chainId);\n      const walletContract = new ethers__WEBPACK_IMPORTED_MODULE_12__.Contract(address, [\"function getMessageHash(bytes32 _hash) public view returns (bytes32)\"], provider);\n      // if this fails it's a pre 712 factory\n      await walletContract.getMessageHash(originalMsgHash);\n      factorySupports712 = true;\n    } catch {\n      factorySupports712 = false;\n    }\n    if (factorySupports712) {\n      const result = await (0,_thirdweb_dev_sdk__WEBPACK_IMPORTED_MODULE_13__.aM)(this, {\n        name: \"Account\",\n        version: \"1\",\n        chainId,\n        verifyingContract: address\n      }, {\n        AccountMessage: [{\n          name: \"message\",\n          type: \"bytes\"\n        }]\n      }, {\n        message: ethers__WEBPACK_IMPORTED_MODULE_7__.defaultAbiCoder.encode([\"bytes32\"], [originalMsgHash])\n      });\n      signature = result.signature;\n    } else {\n      signature = await this.originalSigner.signMessage(message);\n    }\n    const isValid = await (0,_dist_utils_f58e7acc_browser_esm_js__WEBPACK_IMPORTED_MODULE_14__.c)(message, signature, address, chainId, this.config.clientId, this.config.secretKey);\n    if (isValid) {\n      return signature;\n    } else {\n      throw new Error(\"Unable to verify signature on smart account, please make sure the smart account is deployed and the signature is valid.\");\n    }\n  }\n  async signTransaction(transaction, options) {\n    const tx = await ethers__WEBPACK_IMPORTED_MODULE_9__.resolveProperties(transaction);\n    await this.verifyAllNecessaryFields(tx);\n    const multidimensionalNonce = (0,_dist_http_rpc_client_0a079e80_browser_esm_js__WEBPACK_IMPORTED_MODULE_5__.r)();\n    const unsigned = await this.smartAccountAPI.createUnsignedUserOp(this.httpRpcClient, {\n      target: tx.to || \"\",\n      data: tx.data?.toString() || \"0x\",\n      value: tx.value,\n      gasLimit: tx.gasLimit,\n      nonce: multidimensionalNonce\n    }, options);\n    const userOperation = await this.smartAccountAPI.signUserOp(unsigned);\n    const userOpString = JSON.stringify(await (0,_dist_http_rpc_client_0a079e80_browser_esm_js__WEBPACK_IMPORTED_MODULE_5__.h)(userOperation));\n    return userOpString;\n  }\n}\n\nclass ERC4337EthersProvider extends ethers__WEBPACK_IMPORTED_MODULE_15__.BaseProvider {\n  constructor(chainId, config, originalSigner, originalProvider, httpRpcClient, entryPoint, smartAccountAPI) {\n    super({\n      name: \"ERC-4337 Custom Network\",\n      chainId\n    });\n    this.chainId = chainId;\n    this.config = config;\n    this.originalSigner = originalSigner;\n    this.originalProvider = originalProvider;\n    this.httpRpcClient = httpRpcClient;\n    this.entryPoint = entryPoint;\n    this.smartAccountAPI = smartAccountAPI;\n    this.signer = new ERC4337EthersSigner(config, originalSigner, this, httpRpcClient, smartAccountAPI);\n  }\n  getSigner() {\n    return this.signer;\n  }\n  async perform(method, params) {\n    if (method === \"sendTransaction\" || method === \"getTransactionReceipt\") {\n      // TODO: do we need 'perform' method to be available at all?\n      // there is nobody out there to use it for ERC-4337 methods yet, we have nothing to override in fact.\n      throw new Error(\"Should not get here. Investigate.\");\n    }\n    if (method === \"estimateGas\") {\n      // gas estimation does nothing at this layer, sendTransaction will do the gas estimation for the userOp\n      return ethers__WEBPACK_IMPORTED_MODULE_16__.BigNumber.from(500000);\n    }\n    return await this.originalProvider.perform(method, params);\n  }\n  async getTransaction(transactionHash) {\n    // TODO\n    return await super.getTransaction(transactionHash);\n  }\n  async getTransactionReceipt(transactionHash) {\n    const userOpHash = await transactionHash;\n    const sender = await this.getSenderAccountAddress();\n    return await new Promise((resolve, reject) => {\n      new UserOperationEventListener(resolve, reject, this.entryPoint, sender, userOpHash).start();\n    });\n  }\n  async getSenderAccountAddress() {\n    return await this.smartAccountAPI.getAccountAddress();\n  }\n  async waitForTransaction(transactionHash, confirmations, timeout) {\n    const sender = await this.getSenderAccountAddress();\n    return await new Promise((resolve, reject) => {\n      const listener = new UserOperationEventListener(resolve, reject, this.entryPoint, sender, transactionHash, undefined, timeout);\n      listener.start();\n    });\n  }\n\n  // fabricate a response in a format usable by ethers users...\n  async constructUserOpTransactionResponse(userOp1) {\n    const userOp = await ethers__WEBPACK_IMPORTED_MODULE_9__.resolveProperties(userOp1);\n    const userOpHash = await this.smartAccountAPI.getUserOpHash(userOp);\n    return {\n      hash: userOpHash,\n      confirmations: 0,\n      from: userOp.sender,\n      nonce: 0,\n      // not the real nonce, but good enough for this purpose\n      gasLimit: ethers__WEBPACK_IMPORTED_MODULE_16__.BigNumber.from(userOp.callGasLimit),\n      // ??\n      value: ethers__WEBPACK_IMPORTED_MODULE_16__.BigNumber.from(0),\n      data: ethers__WEBPACK_IMPORTED_MODULE_17__.hexValue(userOp.callData),\n      // should extract the actual called method from this \"execFromEntryPoint()\" call\n      chainId: this.chainId,\n      wait: async confirmations => {\n        const transactionReceipt = await this.smartAccountAPI.getUserOpReceipt(this.httpRpcClient, userOpHash);\n        if (userOp.initCode.length !== 0) {\n          // checking if the wallet has been deployed by the transaction; it must be if we are here\n          await this.smartAccountAPI.checkAccountPhantom();\n        }\n        return transactionReceipt;\n      }\n    };\n  }\n  async detectNetwork() {\n    return this.originalProvider.detectNetwork();\n  }\n}\n\n/**\n * wrap an existing provider to tunnel requests through Account Abstraction.\n * @param originalProvider - The normal provider\n * @param config - see {@link ClientConfig} for more info\n * @param originalSigner - use this signer as the owner. of this wallet. By default, use the provider's signer\n */\nfunction create4337Provider(config, accountApi, originalProvider, chainId) {\n  const entryPoint = _account_abstraction_contracts__WEBPACK_IMPORTED_MODULE_0__.EntryPoint__factory.connect(config.entryPointAddress, originalProvider);\n  const httpRpcClient = new _dist_http_rpc_client_0a079e80_browser_esm_js__WEBPACK_IMPORTED_MODULE_5__.H(config.bundlerUrl, config.entryPointAddress, chainId, config.clientId, config.secretKey);\n  return new ERC4337EthersProvider(chainId, config, config.localSigner, originalProvider, httpRpcClient, entryPoint, accountApi);\n}\n\nconst DUMMY_SIGNATURE = \"0xfffffffffffffffffffffffffffffff0000000000000000000000000000000007aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa1c\";\n\n/**\n * Base class for all Smart Wallet ERC-4337 Clients to implement.\n * Subclass should inherit 5 methods to support a specific wallet contract:\n *\n * - getAccountInitCode - return the value to put into the \"initCode\" field, if the account is not yet deployed. should create the account instance using a factory contract.\n * - getNonce - return current account's nonce value\n * - encodeExecute - encode the call from entryPoint through our account to the target contract.\n * - signUserOpHash - sign the hash of a UserOp.\n *\n * The user can use the following APIs:\n * - createUnsignedUserOp - given \"target\" and \"calldata\", fill userOp to perform that operation from the account.\n * - createSignedUserOp - helper to call the above createUnsignedUserOp, and then extract the userOpHash and sign it\n */\nclass BaseAccountAPI {\n  // entryPoint connected to \"zero\" address. allowed to make static calls (e.g. to getSenderAddress)\n\n  /**\n   * base constructor.\n   * subclass SHOULD add parameters that define the owner (signer) of this wallet\n   */\n  constructor(params) {\n    (0,_dist_defineProperty_350fc508_browser_esm_js__WEBPACK_IMPORTED_MODULE_6__._)(this, \"isPhantom\", true);\n    this.provider = params.provider;\n    this.entryPointAddress = params.entryPointAddress;\n    this.accountAddress = params.accountAddress;\n    this.paymasterAPI = params.paymasterAPI;\n    this.gasless = params.gasless;\n    this.erc20PaymasterAddress = params.erc20PaymasterAddress;\n    this.erc20TokenAddress = params.erc20TokenAddress;\n\n    // factory \"connect\" define the contract address. the contract \"connect\" defines the \"from\" address.\n    this.entryPointView = _account_abstraction_contracts__WEBPACK_IMPORTED_MODULE_0__.EntryPoint__factory.connect(params.entryPointAddress, params.provider).connect(ethers__WEBPACK_IMPORTED_MODULE_18__.AddressZero);\n  }\n\n  /**\n   * return the value to put into the \"initCode\" field, if the contract is not yet deployed.\n   * this value holds the \"factory\" address, followed by this account's information\n   */\n\n  /**\n   * return current account's nonce.\n   */\n\n  /**\n   * encode the call from entryPoint through our account to the target contract.\n   * @param target - The target contract address\n   * @param value - The value to send to the target contract\n   * @param data - The calldata to send to the target contract\n   */\n\n  /**\n   * sign a userOp's hash (userOpHash).\n   * @param userOpHash - The hash to sign\n   */\n\n  /**\n   * calculate the account address even before it is deployed\n   */\n\n  /**\n   * check if the contract is already deployed.\n   */\n  async checkAccountPhantom() {\n    if (!this.isPhantom) {\n      // already deployed. no need to check anymore.\n      return this.isPhantom;\n    }\n    const senderAddressCode = await this.provider.getCode(this.getAccountAddress());\n    if (senderAddressCode.length > 2) {\n      this.isPhantom = false;\n    }\n    return this.isPhantom;\n  }\n  /**\n   * return initCode value to into the UserOp.\n   * (either deployment code, or empty hex if contract already deployed)\n   */\n  async getInitCode() {\n    if (await this.checkAccountPhantom()) {\n      return await this.getAccountInitCode();\n    }\n    return \"0x\";\n  }\n\n  /**\n   * return maximum gas used for verification.\n   * NOTE: createUnsignedUserOp will add to this value the cost of creation, if the contract is not yet created.\n   */\n  async getVerificationGasLimit() {\n    return 100000;\n  }\n\n  /**\n   * return userOpHash for signing.\n   * This value matches entryPoint.getUserOpHash (calculated off-chain, to avoid a view call)\n   * @param userOp - userOperation, (signature field ignored)\n   */\n  async getUserOpHash(userOp) {\n    const chainId = await this.provider.getNetwork().then(net => net.chainId);\n    return (0,_dist_http_rpc_client_0a079e80_browser_esm_js__WEBPACK_IMPORTED_MODULE_5__.g)(userOp, this.entryPointAddress, chainId);\n  }\n\n  /**\n   * return the account's address.\n   * this value is valid even before deploying the contract.\n   */\n  async getAccountAddress() {\n    if (!this.senderAddress) {\n      if (this.accountAddress) {\n        this.senderAddress = this.accountAddress;\n      } else {\n        this.senderAddress = await this.getCounterFactualAddress();\n      }\n    }\n    return this.senderAddress;\n  }\n  async estimateCreationGas(initCode) {\n    if (!initCode || initCode === \"0x\") {\n      return 0;\n    }\n    const deployerAddress = initCode.substring(0, 42);\n    const deployerCallData = \"0x\" + initCode.substring(42);\n    return await this.provider.estimateGas({\n      to: deployerAddress,\n      data: deployerCallData\n    });\n  }\n  async createUnsignedUserOp(httpRpcClient, info, options) {\n    let {\n      maxFeePerGas,\n      maxPriorityFeePerGas\n    } = info;\n    // get fees from bundler if available\n    if ((0,_dist_url_a45219bd_browser_esm_js__WEBPACK_IMPORTED_MODULE_3__.i)(httpRpcClient.bundlerUrl)) {\n      const bundlerFeeData = await httpRpcClient.getUserOperationGasPrice();\n      maxFeePerGas = ethers__WEBPACK_IMPORTED_MODULE_16__.BigNumber.from(bundlerFeeData.maxFeePerGas);\n      maxPriorityFeePerGas = ethers__WEBPACK_IMPORTED_MODULE_16__.BigNumber.from(bundlerFeeData.maxPriorityFeePerGas);\n    } else {\n      // if bundler is not available, try to get fees from the network if not passed explicitly\n      if (!maxFeePerGas || !maxPriorityFeePerGas) {\n        const feeData = await (0,_thirdweb_dev_sdk__WEBPACK_IMPORTED_MODULE_19__.a)(this.provider);\n        if (!maxPriorityFeePerGas) {\n          maxPriorityFeePerGas = feeData.maxPriorityFeePerGas ?? undefined;\n        }\n        if (!maxFeePerGas) {\n          maxFeePerGas = feeData.maxFeePerGas ?? undefined;\n          const network = await this.provider.getNetwork();\n          const chainId = network.chainId;\n          if (chainId === _thirdweb_dev_chains__WEBPACK_IMPORTED_MODULE_20__.Celo.chainId || chainId === _thirdweb_dev_chains__WEBPACK_IMPORTED_MODULE_20__.CeloAlfajoresTestnet.chainId || chainId === _thirdweb_dev_chains__WEBPACK_IMPORTED_MODULE_20__.CeloBaklavaTestnet.chainId) {\n            maxPriorityFeePerGas = maxFeePerGas;\n          }\n        }\n      }\n    }\n    if (!maxFeePerGas || !maxPriorityFeePerGas) {\n      throw new Error(\"maxFeePerGas or maxPriorityFeePerGas could not be calculated, please pass them explicitely\");\n    }\n    const [sender, nonce] = await Promise.all([this.getAccountAddress(), info.nonce ? Promise.resolve(info.nonce) : this.getNonce()]);\n    const initCode = await this.getInitCode();\n    const value = parseNumber(info.value) ?? ethers__WEBPACK_IMPORTED_MODULE_16__.BigNumber.from(0);\n    const callData = options?.batchData ? info.data : await this.prepareExecute(info.target, value, info.data).then(async tx => {\n      if (!info.gasLimit) {\n        // estimate gas on the inner transactions to simulate\n        // bundler would not revert otherwise\n        await this.provider.estimateGas({\n          from: sender,\n          to: info.target,\n          data: info.data,\n          value: value\n        });\n      }\n      return tx.encode();\n    });\n    const partialOp = {\n      sender,\n      nonce,\n      initCode,\n      callData,\n      maxFeePerGas,\n      maxPriorityFeePerGas,\n      callGasLimit: ethers__WEBPACK_IMPORTED_MODULE_16__.BigNumber.from(1000000),\n      verificationGasLimit: ethers__WEBPACK_IMPORTED_MODULE_16__.BigNumber.from(1000000),\n      preVerificationGas: ethers__WEBPACK_IMPORTED_MODULE_16__.BigNumber.from(1000000),\n      paymasterAndData: \"0x\",\n      signature: DUMMY_SIGNATURE\n    };\n\n    // paymaster data + maybe used for estimation as well\n    const gasless = options?.gasless !== undefined ? options.gasless : this.gasless;\n    const useErc20Paymaster = this.erc20PaymasterAddress && this.erc20TokenAddress && (await this.isAccountApproved());\n    if (useErc20Paymaster) {\n      partialOp.paymasterAndData = this.erc20PaymasterAddress;\n      let estimates;\n      try {\n        estimates = await httpRpcClient.estimateUserOpGas(partialOp);\n      } catch (error) {\n        throw this.unwrapBundlerError(error);\n      }\n      partialOp.callGasLimit = estimates.callGasLimit;\n      partialOp.verificationGasLimit = estimates.verificationGasLimit;\n      partialOp.preVerificationGas = estimates.preVerificationGas;\n    } else if (gasless) {\n      const paymasterResult = await this.paymasterAPI.getPaymasterAndData(partialOp);\n      const paymasterAndData = paymasterResult.paymasterAndData;\n      if (paymasterAndData && paymasterAndData !== \"0x\") {\n        partialOp.paymasterAndData = paymasterAndData;\n      }\n      // paymaster can have the gas limits in the response\n      if (paymasterResult.callGasLimit && paymasterResult.verificationGasLimit && paymasterResult.preVerificationGas) {\n        partialOp.callGasLimit = ethers__WEBPACK_IMPORTED_MODULE_16__.BigNumber.from(paymasterResult.callGasLimit);\n        partialOp.verificationGasLimit = ethers__WEBPACK_IMPORTED_MODULE_16__.BigNumber.from(paymasterResult.verificationGasLimit);\n        partialOp.preVerificationGas = ethers__WEBPACK_IMPORTED_MODULE_16__.BigNumber.from(paymasterResult.preVerificationGas);\n      } else {\n        // otherwise fallback to bundler for gas limits\n        let estimates;\n        try {\n          estimates = await httpRpcClient.estimateUserOpGas(partialOp);\n        } catch (error) {\n          throw this.unwrapBundlerError(error);\n        }\n        partialOp.callGasLimit = estimates.callGasLimit;\n        partialOp.verificationGasLimit = estimates.verificationGasLimit;\n        partialOp.preVerificationGas = estimates.preVerificationGas;\n        // need paymaster to re-sign after estimates\n        if (paymasterAndData && paymasterAndData !== \"0x\") {\n          const paymasterResult2 = await this.paymasterAPI.getPaymasterAndData(partialOp);\n          if (paymasterResult2.paymasterAndData && paymasterResult2.paymasterAndData !== \"0x\") {\n            partialOp.paymasterAndData = paymasterResult2.paymasterAndData;\n          }\n        }\n      }\n    } else {\n      // query bundler for gas limits\n      let estimates;\n      try {\n        estimates = await httpRpcClient.estimateUserOpGas(partialOp);\n      } catch (error) {\n        throw this.unwrapBundlerError(error);\n      }\n      partialOp.callGasLimit = estimates.callGasLimit;\n      partialOp.verificationGasLimit = estimates.verificationGasLimit;\n      partialOp.preVerificationGas = estimates.preVerificationGas;\n    }\n    return {\n      ...partialOp,\n      signature: \"\"\n    };\n  }\n\n  /**\n   * Sign the filled userOp.\n   * @param userOp - The UserOperation to sign (with signature field ignored)\n   */\n  async signUserOp(userOp) {\n    const userOpHash = await this.getUserOpHash(userOp);\n    const signature = await this.signUserOpHash(userOpHash);\n    return {\n      ...userOp,\n      signature\n    };\n  }\n\n  /**\n   * get the transaction that has this userOpHash mined, or throws if not found\n   * @param userOpHash - returned by sendUserOpToBundler (or by getUserOpHash..)\n   * @param timeout - stop waiting after this timeout\n   * @param interval - time to wait between polls.\n   * @returns The transaction receipt, or an error if timed out.\n   */\n  async getUserOpReceipt(httpRpcClient, userOpHash) {\n    let timeout = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 120000;\n    let interval = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1000;\n    const endtime = Date.now() + timeout;\n    while (Date.now() < endtime) {\n      const userOpReceipt = await httpRpcClient.getUserOperationReceipt(userOpHash);\n      if (userOpReceipt) {\n        // avoid desync with current provider state\n        return await this.provider.waitForTransaction(userOpReceipt.receipt.transactionHash);\n      }\n      await new Promise(resolve => setTimeout(resolve, interval));\n    }\n    throw new Error(\"Timeout waiting for userOp to be mined\");\n  }\n  unwrapBundlerError(error) {\n    const message = error?.error?.message || error.error || error.message || error;\n    return new Error(message);\n  }\n}\nfunction parseNumber(a) {\n  if (!a || a === \"\") {\n    return null;\n  }\n  return ethers__WEBPACK_IMPORTED_MODULE_16__.BigNumber.from(a.toString());\n}\n\nclass AccountAPI extends BaseAccountAPI {\n  constructor(params, originalProvider) {\n    super({\n      ...params,\n      provider: originalProvider\n    });\n    this.params = params;\n    // Technically dont need the signer here, but we need to encode/estimate gas with it so a signer is required\n    // We don't want to use the localSigner directly since it might be connected to another chain\n    // so we just use the public hardhat pkey instead\n    this.sdk = _thirdweb_dev_sdk__WEBPACK_IMPORTED_MODULE_21__.T.fromPrivateKey(_thirdweb_dev_sdk__WEBPACK_IMPORTED_MODULE_21__.L, params.chain, {\n      clientId: params.clientId,\n      secretKey: params.secretKey,\n      // @ts-expect-error expected chain type error\n      supportedChains: typeof params.chain === \"object\" ? [params.chain] : undefined\n    });\n  }\n  async getChainId() {\n    return await this.provider.getNetwork().then(n => n.chainId);\n  }\n  async getAccountContract() {\n    if (!this.accountContract) {\n      if (this.params.accountInfo?.abi) {\n        this.accountContract = await this.sdk.getContract(await this.getAccountAddress(), this.params.accountInfo.abi);\n      } else {\n        this.accountContract = await this.sdk.getContract(await this.getAccountAddress(), _dist_utils_f58e7acc_browser_esm_js__WEBPACK_IMPORTED_MODULE_14__.A);\n      }\n    }\n    return this.accountContract;\n  }\n  async getAccountInitCode() {\n    const factory = await this.getFactoryContract();\n    const localSigner = await this.params.localSigner.getAddress();\n    const tx = await this.params.factoryInfo.createAccount(factory, localSigner);\n    return ethers__WEBPACK_IMPORTED_MODULE_17__.hexConcat([factory.getAddress(), tx.encode()]);\n  }\n  async getFactoryContract() {\n    if (this.factoryContract) {\n      return this.factoryContract;\n    }\n    if (this.params.factoryInfo?.abi) {\n      this.factoryContract = await this.sdk.getContract(this.params.factoryAddress, this.params.factoryInfo.abi);\n    } else {\n      this.factoryContract = await this.sdk.getContract(this.params.factoryAddress);\n    }\n    return this.factoryContract;\n  }\n  async getCounterFactualAddress() {\n    if (this.params.accountAddress) {\n      return this.params.accountAddress;\n    }\n    const factory = await this.getFactoryContract();\n    const localSigner = await this.params.localSigner.getAddress();\n    return this.params.factoryInfo.getAccountAddress(factory, localSigner);\n  }\n  async getNonce() {\n    if (await this.checkAccountPhantom()) {\n      return ethers__WEBPACK_IMPORTED_MODULE_16__.BigNumber.from(0);\n    }\n    const accountContract = await this.getAccountContract();\n    return this.params.accountInfo.getNonce(accountContract);\n  }\n  async prepareExecute(target, value, data) {\n    const accountContract = await this.getAccountContract();\n    return this.params.accountInfo.execute(accountContract, target, value, data);\n  }\n  async prepareExecuteBatch(targets, values, datas) {\n    const accountContract = await this.getAccountContract();\n    return accountContract.prepare(\"executeBatch\", [targets, values, datas]);\n  }\n  async signUserOpHash(userOpHash) {\n    return await this.params.localSigner.signMessage(ethers__WEBPACK_IMPORTED_MODULE_17__.arrayify(userOpHash));\n  }\n  async isAcountDeployed() {\n    return !(await this.checkAccountPhantom());\n  }\n  async isAccountApproved() {\n    if (!this.params.erc20PaymasterAddress || !this.params.erc20TokenAddress) {\n      return true;\n    }\n    const swAddress = await this.getCounterFactualAddress();\n    const ERC20Abi = (await Promise.resolve(/*! import() */).then(__webpack_require__.t.bind(__webpack_require__, /*! @thirdweb-dev/contracts-js/dist/abis/IERC20.json */ \"(app-pages-browser)/./node_modules/@thirdweb-dev/contracts-js/dist/abis/IERC20.json\", 19))).default;\n    const erc20Token = await this.sdk.getContract(this.params.erc20TokenAddress, ERC20Abi);\n    const allowance = await erc20Token.call(\"allowance\", [swAddress, this.params.erc20PaymasterAddress]);\n    return allowance.gte(ethers__WEBPACK_IMPORTED_MODULE_16__.BigNumber.from(2).pow(96).sub(1));\n  }\n  async createApproveTx() {\n    if (await this.isAccountApproved()) {\n      return undefined;\n    }\n    const amountToApprove = ethers__WEBPACK_IMPORTED_MODULE_16__.BigNumber.from(2).pow(96).sub(1);\n    const ethersSigner = new ethers__WEBPACK_IMPORTED_MODULE_22__.Wallet(_thirdweb_dev_sdk__WEBPACK_IMPORTED_MODULE_21__.L, this.provider);\n    const erc20Contract = new ethers__WEBPACK_IMPORTED_MODULE_12__.Contract(this.params.erc20TokenAddress, [\"function approve(address spender, uint256 amount) public returns (bool)\"], ethersSigner);\n    const tx = {\n      to: this.params.erc20TokenAddress,\n      from: await this.getAccountAddress(),\n      value: 0,\n      data: erc20Contract.interface.encodeFunctionData(\"approve\", [this.params.erc20PaymasterAddress, amountToApprove])\n    };\n    return tx;\n  }\n}\n\nclass SmartWalletConnector extends _dist_connector_05689d68_browser_esm_js__WEBPACK_IMPORTED_MODULE_23__.C {\n  constructor(config) {\n    super();\n    this.config = config;\n  }\n  async initialize(params) {\n    const config = this.config;\n    const originalProvider = (0,_thirdweb_dev_sdk__WEBPACK_IMPORTED_MODULE_13__.a_)(config.chain, {\n      clientId: config.clientId,\n      secretKey: config.secretKey\n    });\n    this.chainId = (await originalProvider.getNetwork()).chainId;\n    const bundlerUrl = this.config.bundlerUrl || `https://${this.chainId}.bundler.thirdweb.com`;\n    const paymasterUrl = this.config.paymasterUrl || `https://${this.chainId}.bundler.thirdweb.com`;\n    const entryPointAddress = config.entryPointAddress || _dist_utils_f58e7acc_browser_esm_js__WEBPACK_IMPORTED_MODULE_14__.f;\n    const localSigner = await params.personalWallet.getSigner();\n    const providerConfig = {\n      chain: config.chain,\n      localSigner,\n      entryPointAddress,\n      bundlerUrl,\n      paymasterAPI: this.config.paymasterAPI ? this.config.paymasterAPI : getVerifyingPaymaster(paymasterUrl, entryPointAddress, this.config.clientId, this.config.secretKey),\n      gasless: config.gasless,\n      factoryAddress: config.factoryAddress || _dist_utils_f58e7acc_browser_esm_js__WEBPACK_IMPORTED_MODULE_14__.D,\n      accountAddress: params.accountAddress,\n      factoryInfo: {\n        createAccount: config.factoryInfo?.createAccount || this.defaultFactoryInfo().createAccount,\n        getAccountAddress: config.factoryInfo?.getAccountAddress || this.defaultFactoryInfo().getAccountAddress,\n        abi: config.factoryInfo?.abi\n      },\n      accountInfo: {\n        execute: config.accountInfo?.execute || this.defaultAccountInfo().execute,\n        getNonce: config.accountInfo?.getNonce || this.defaultAccountInfo().getNonce,\n        abi: config.accountInfo?.abi\n      },\n      clientId: config.clientId,\n      secretKey: config.secretKey,\n      erc20PaymasterAddress: config.erc20PaymasterAddress,\n      erc20TokenAddress: config.erc20TokenAddress\n    };\n    this.personalWallet = params.personalWallet;\n    const accountApi = new AccountAPI(providerConfig, originalProvider);\n    this.aaProvider = create4337Provider(providerConfig, accountApi, originalProvider, this.chainId);\n    this.accountApi = accountApi;\n  }\n  async connect(connectionArgs) {\n    await this.initialize(connectionArgs);\n    return await this.getAddress();\n  }\n  getProvider() {\n    if (!this.aaProvider) {\n      throw new Error(\"Personal wallet not connected\");\n    }\n    return Promise.resolve(this.aaProvider);\n  }\n  async getSigner() {\n    if (!this.aaProvider) {\n      throw new Error(\"Personal wallet not connected\");\n    }\n    return Promise.resolve(this.aaProvider.getSigner());\n  }\n  async getAddress() {\n    const signer = await this.getSigner();\n    return signer.getAddress();\n  }\n  async isConnected() {\n    try {\n      const address = await this.getAddress();\n      return !!address;\n    } catch (e) {\n      return false;\n    }\n  }\n  async disconnect() {\n    this.personalWallet = undefined;\n    this.aaProvider = undefined;\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n  async switchChain(chainId) {\n    const provider = await this.getProvider();\n    const currentChainId = (await provider.getNetwork()).chainId;\n    if (currentChainId !== chainId) {\n      // only throw if actually trying to switch chains\n      throw new Error(\"Not supported.\");\n    }\n  }\n  setupListeners() {\n    return Promise.resolve();\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  updateChains(chains) {}\n\n  /**\n   * Check whether the connected signer can execute a given transaction using the smart wallet.\n   * @param transaction - The transaction to execute using the smart wallet.\n   * @returns whether the connected signer can execute the transaction using the smart wallet.\n   */\n  async hasPermissionToExecute(transaction) {\n    const accountContract = await this.getAccountContract();\n    const signer = await this.getSigner();\n    const signerAddress = await signer.getAddress();\n    const restrictions = (await accountContract.account.getAllSigners()).filter(item => ethers__WEBPACK_IMPORTED_MODULE_24__.getAddress(item.signer) === ethers__WEBPACK_IMPORTED_MODULE_24__.getAddress(signerAddress))[0]?.permissions;\n    if (!restrictions) {\n      return false;\n    }\n    return restrictions.approvedCallTargets.includes(transaction.getTarget());\n  }\n\n  /// PREPARED TRANSACTIONS\n\n  /**\n   * Send a single transaction without waiting for confirmations\n   * @param transaction - the transaction to send\n   * @param config - optional the transaction configuration\n   * @returns The awaitable transaction\n   */\n  async send(transaction, options) {\n    const signer = await this.getSigner();\n    return signer.sendTransaction({\n      to: transaction.getTarget(),\n      data: transaction.encode(),\n      value: await transaction.getValue()\n    }, options);\n  }\n\n  /**\n   * Execute a single transaction (waiting for confirmations)\n   * @param transaction - The transaction to execute\n   * @returns The transaction receipt\n   */\n  async execute(transaction, options) {\n    const tx = await this.send(transaction, options);\n    const receipt = await tx.wait();\n    return {\n      receipt\n    };\n  }\n  async sendBatch(transactions, options) {\n    if (!this.accountApi) {\n      throw new Error(\"Personal wallet not connected\");\n    }\n    const signer = await this.getSigner();\n    const {\n      tx,\n      batchData\n    } = await this.prepareBatchTx(transactions);\n    return await signer.sendTransaction({\n      to: await signer.getAddress(),\n      data: tx.encode(),\n      value: 0\n    }, {\n      ...options,\n      batchData\n    });\n  }\n\n  /**\n   * Execute multiple transactions in a single batch\n   * @param transactions - The transactions to execute\n   * @returns The transaction receipt\n   */\n  async executeBatch(transactions, options) {\n    const tx = await this.sendBatch(transactions, options);\n    const receipt = await tx.wait();\n    return {\n      receipt\n    };\n  }\n\n  /// RAW TRANSACTIONS\n\n  async sendRaw(transaction, options) {\n    if (!this.accountApi) {\n      throw new Error(\"Personal wallet not connected\");\n    }\n    const signer = await this.getSigner();\n    return signer.sendTransaction(transaction, options);\n  }\n  async executeRaw(transaction, options) {\n    const tx = await this.sendRaw(transaction, options);\n    const receipt = await tx.wait();\n    return {\n      receipt\n    };\n  }\n  async sendBatchRaw(transactions, options) {\n    if (!this.accountApi) {\n      throw new Error(\"Personal wallet not connected\");\n    }\n    const signer = await this.getSigner();\n    const batch = await this.prepareBatchRaw(transactions);\n    return signer.sendTransaction({\n      to: await signer.getAddress(),\n      data: batch.tx.encode(),\n      value: 0\n    }, {\n      ...options,\n      batchData: batch.batchData // batched tx flag\n    });\n  }\n  async executeBatchRaw(transactions, options) {\n    const tx = await this.sendBatchRaw(transactions, options);\n    const receipt = await tx.wait();\n    return {\n      receipt\n    };\n  }\n\n  /// ESTIMATION\n\n  async estimate(transaction, options) {\n    if (!this.accountApi) {\n      throw new Error(\"Personal wallet not connected\");\n    }\n    return this.estimateTx({\n      target: transaction.getTarget(),\n      data: transaction.encode(),\n      value: await transaction.getValue(),\n      gasLimit: await transaction.getOverrides().gasLimit,\n      maxFeePerGas: await transaction.getOverrides().maxFeePerGas,\n      maxPriorityFeePerGas: await transaction.getOverrides().maxPriorityFeePerGas,\n      nonce: await transaction.getOverrides().nonce\n    }, options);\n  }\n  async estimateRaw(transaction, options) {\n    if (!this.accountApi) {\n      throw new Error(\"Personal wallet not connected\");\n    }\n    const tx = await ethers__WEBPACK_IMPORTED_MODULE_9__.resolveProperties(transaction);\n    return this.estimateTx({\n      target: tx.to || ethers__WEBPACK_IMPORTED_MODULE_18__.AddressZero,\n      data: tx.data?.toString() || \"\",\n      value: tx.value || ethers__WEBPACK_IMPORTED_MODULE_16__.BigNumber.from(0),\n      gasLimit: tx.gasLimit,\n      maxFeePerGas: tx.maxFeePerGas,\n      maxPriorityFeePerGas: tx.maxPriorityFeePerGas,\n      nonce: tx.nonce\n    }, options);\n  }\n  async estimateBatch(transactions, options) {\n    if (!this.accountApi) {\n      throw new Error(\"Personal wallet not connected\");\n    }\n    const {\n      tx,\n      batchData\n    } = await this.prepareBatchTx(transactions);\n    return this.estimateTx({\n      target: tx.getTarget(),\n      data: tx.encode(),\n      value: await tx.getValue(),\n      gasLimit: await tx.getOverrides().gasLimit,\n      maxFeePerGas: await tx.getOverrides().maxFeePerGas,\n      maxPriorityFeePerGas: await tx.getOverrides().maxPriorityFeePerGas,\n      nonce: await tx.getOverrides().nonce\n    }, {\n      ...options,\n      batchData\n    });\n  }\n  async estimateBatchRaw(transactions, options) {\n    if (!this.accountApi) {\n      throw new Error(\"Personal wallet not connected\");\n    }\n    const {\n      tx,\n      batchData\n    } = await this.prepareBatchRaw(transactions);\n    return this.estimateTx({\n      target: tx.getTarget(),\n      data: tx.encode(),\n      value: await tx.getValue(),\n      gasLimit: await tx.getOverrides().gasLimit,\n      maxFeePerGas: await tx.getOverrides().maxFeePerGas,\n      maxPriorityFeePerGas: await tx.getOverrides().maxPriorityFeePerGas,\n      nonce: await tx.getOverrides().nonce\n    }, {\n      ...options,\n      batchData\n    });\n  }\n\n  //// DEPLOYMENT\n\n  /**\n   * Manually deploy the smart wallet contract. If already deployed this will throw an error.\n   * Note that this is not necessary as the smart wallet will be deployed automatically on the first transaction the user makes.\n   * @returns The transaction receipt\n   */\n  async deploy(options) {\n    if (!this.accountApi) {\n      throw new Error(\"Personal wallet not connected\");\n    }\n    const signer = await this.getSigner();\n    const tx = await signer.sendTransaction({\n      to: await signer.getAddress(),\n      data: \"0x\"\n    }, {\n      ...options,\n      batchData: {\n        targets: [],\n        data: [],\n        values: []\n      } // batched tx flag to avoid hitting the Router fallback method\n    });\n    const receipt = await tx.wait();\n    return {\n      receipt\n    };\n  }\n\n  /**\n   * Check if the smart wallet contract is deployed\n   * @returns true if the smart wallet contract is deployed\n   */\n  async isDeployed() {\n    if (!this.accountApi) {\n      throw new Error(\"Personal wallet not connected\");\n    }\n    return await this.accountApi.isAcountDeployed();\n  }\n  async deployIfNeeded(options) {\n    const isDeployed = await this.isDeployed();\n    if (!isDeployed) {\n      await this.deploy(options);\n    }\n  }\n\n  //// PERMISSIONS\n\n  async grantPermissions(target, permissions) {\n    const accountContract = await this.getAccountContract();\n    return accountContract.account.grantPermissions(target, permissions);\n  }\n  async revokePermissions(target) {\n    const accountContract = await this.getAccountContract();\n    return accountContract.account.revokeAccess(target);\n  }\n  async addAdmin(target) {\n    const accountContract = await this.getAccountContract();\n    return accountContract.account.grantAdminPermissions(target);\n  }\n  async removeAdmin(target) {\n    const accountContract = await this.getAccountContract();\n    return accountContract.account.revokeAdminPermissions(target);\n  }\n  async getAllActiveSigners() {\n    const isDeployed = await this.isDeployed();\n    if (isDeployed) {\n      const accountContract = await this.getAccountContract();\n      return accountContract.account.getAllAdminsAndSigners();\n    } else {\n      const personalWallet = await this.personalWallet?.getSigner();\n      if (!personalWallet) {\n        throw new Error(\"Personal wallet not connected\");\n      }\n      return [{\n        isAdmin: true,\n        signer: await personalWallet.getAddress(),\n        permissions: {\n          startDate: new Date(0),\n          expirationDate: new Date(0),\n          nativeTokenLimitPerTransaction: ethers__WEBPACK_IMPORTED_MODULE_16__.BigNumber.from(0),\n          approvedCallTargets: []\n        }\n      }];\n    }\n  }\n\n  /**\n   * Get the underlying account contract of the smart wallet.\n   * @returns The account contract of the smart wallet.\n   */\n  async getAccountContract() {\n    // getting a new instance everytime\n    // to avoid caching issues pre/post deployment\n    const sdk = _thirdweb_dev_sdk__WEBPACK_IMPORTED_MODULE_21__.T.fromSigner(await this.getSigner(), this.config.chain, {\n      clientId: this.config.clientId,\n      secretKey: this.config.secretKey\n    });\n    if (this.config.accountInfo?.abi) {\n      return sdk.getContract(await this.getAddress(), this.config.accountInfo.abi);\n    } else {\n      return sdk.getContract(await this.getAddress(), _dist_utils_f58e7acc_browser_esm_js__WEBPACK_IMPORTED_MODULE_14__.A);\n    }\n  }\n\n  /**\n   * Get the underlying account factory contract of the smart wallet.\n   * @returns The account factory contract.\n   */\n  async getFactoryContract() {\n    if (!this.config.factoryAddress) {\n      throw new Error(\"Factory address not set!\");\n    }\n    const sdk = _thirdweb_dev_sdk__WEBPACK_IMPORTED_MODULE_21__.T.fromSigner(await this.getSigner(), this.config.chain, {\n      clientId: this.config.clientId,\n      secretKey: this.config.secretKey\n    });\n    if (this.config.factoryInfo?.abi) {\n      return sdk.getContract(this.config.factoryAddress, this.config.factoryInfo.abi);\n    }\n    return sdk.getContract(this.config.factoryAddress);\n  }\n  defaultFactoryInfo() {\n    return {\n      createAccount: async (factory, owner) => {\n        return factory.prepare(\"createAccount\", [owner, ethers__WEBPACK_IMPORTED_MODULE_25__.toUtf8Bytes(\"\")]);\n      },\n      getAccountAddress: async (factory, owner) => {\n        return await factory.call(\"getAddress\", [owner, ethers__WEBPACK_IMPORTED_MODULE_25__.toUtf8Bytes(\"\")]);\n      }\n    };\n  }\n  defaultAccountInfo() {\n    return {\n      execute: async (account, target, value, data) => {\n        return account.prepare(\"execute\", [target, value, data]);\n      },\n      getNonce: async account => {\n        return account.call(\"getNonce\", []);\n      }\n    };\n  }\n\n  /// PRIVATE METHODS\n\n  async estimateTx(tx, options) {\n    if (!this.accountApi || !this.aaProvider) {\n      throw new Error(\"Personal wallet not connected\");\n    }\n    let deployGasLimit = ethers__WEBPACK_IMPORTED_MODULE_16__.BigNumber.from(0);\n    const [provider, isDeployed] = await Promise.all([this.getProvider(), this.isDeployed()]);\n    if (!isDeployed) {\n      deployGasLimit = await this.estimateDeploymentGasLimit();\n    }\n    const [userOp, gasPrice] = await Promise.all([this.accountApi.createUnsignedUserOp(this.aaProvider.httpRpcClient, tx, options), (0,_thirdweb_dev_sdk__WEBPACK_IMPORTED_MODULE_19__.b)(provider)]);\n    const resolved = await ethers__WEBPACK_IMPORTED_MODULE_9__.resolveProperties(userOp);\n    const transactionGasLimit = ethers__WEBPACK_IMPORTED_MODULE_16__.BigNumber.from(resolved.callGasLimit);\n    const transactionCost = transactionGasLimit.mul(gasPrice);\n    const deployCost = deployGasLimit.mul(gasPrice);\n    const totalCost = deployCost.add(transactionCost);\n    return {\n      ether: ethers__WEBPACK_IMPORTED_MODULE_26__.formatEther(totalCost),\n      wei: totalCost,\n      details: {\n        deployGasLimit,\n        transactionGasLimit,\n        gasPrice,\n        transactionCost,\n        deployCost,\n        totalCost\n      }\n    };\n  }\n  async estimateDeploymentGasLimit() {\n    if (!this.accountApi) {\n      throw new Error(\"Personal wallet not connected\");\n    }\n    const initCode = await this.accountApi.getInitCode();\n    const [initGas, verificationGasLimit] = await Promise.all([this.accountApi.estimateCreationGas(initCode), this.accountApi.getVerificationGasLimit()]);\n    return ethers__WEBPACK_IMPORTED_MODULE_16__.BigNumber.from(verificationGasLimit).add(initGas);\n  }\n  async prepareBatchRaw(transactions) {\n    if (!this.accountApi) {\n      throw new Error(\"Personal wallet not connected\");\n    }\n    const resolvedTxs = await Promise.all(transactions.map(transaction => ethers__WEBPACK_IMPORTED_MODULE_9__.resolveProperties(transaction)));\n    const targets = resolvedTxs.map(tx => tx.to || ethers__WEBPACK_IMPORTED_MODULE_18__.AddressZero);\n    const data = resolvedTxs.map(tx => tx.data || \"0x\");\n    const values = resolvedTxs.map(tx => tx.value || ethers__WEBPACK_IMPORTED_MODULE_16__.BigNumber.from(0));\n    return {\n      tx: await this.accountApi.prepareExecuteBatch(targets, values, data),\n      batchData: {\n        targets,\n        data,\n        values\n      }\n    };\n  }\n  async prepareBatchTx(transactions) {\n    if (!this.accountApi) {\n      throw new Error(\"Personal wallet not connected\");\n    }\n    const targets = transactions.map(tx => tx.getTarget());\n    const data = transactions.map(tx => tx.encode());\n    const values = await Promise.all(transactions.map(tx => tx.getValue()));\n    return {\n      tx: await this.accountApi.prepareExecuteBatch(targets, values, data),\n      batchData: {\n        targets,\n        data,\n        values\n      }\n    };\n  }\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AdGhpcmR3ZWItZGV2L3dhbGxldHMvZXZtL2Nvbm5lY3RvcnMvc21hcnQtd2FsbGV0L2Rpc3QvdGhpcmR3ZWItZGV2LXdhbGxldHMtZXZtLWNvbm5lY3RvcnMtc21hcnQtd2FsbGV0LmJyb3dzZXIuZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQW9GO0FBQ21GO0FBQzNGO0FBQ2dCO0FBQ3ZCO0FBQ3FCO0FBQ0s7QUFDMkM7QUFDWDtBQUNrRDtBQUMzRjtBQUMvRDs7QUFFdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLG9FQUFPO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDZDQUE2Qyx5QkFBeUI7QUFDdEU7O0FBRUE7QUFDQTtBQUNBLDZDQUE2Qyw2QkFBNkI7QUFDMUU7QUFDQTtBQUNBLE1BQU0sd0VBQW1CO0FBQ3pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsZ0ZBQWE7QUFDcEMsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQyxVQUFVO0FBQ1YsUUFBUSxLQUFLO0FBQ2I7QUFDQSxRQUFRLDRFQUFLO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsOENBQThDLGtCQUFrQixJQUFJLE1BQU07QUFDMUU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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O0FBQ0Esd0RBQXdELGdEQUF3QjtBQUNoRixPQUFPO0FBQ1A7QUFDQSx3REFBd0QsZ0RBQXdCO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsOENBQVM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvSUFBb0kscURBQVc7QUFDL0ksMkJBQTJCLHFEQUF1QjtBQUNsRCxnQ0FBZ0MsOENBQVM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGdEQUFpQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyw4Q0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEVBQTBFLHFEQUE4QjtBQUN4RyxtREFBbUQsZ0RBQXFCO0FBQ3hFO0FBQ0EscURBQXFELDhDQUFTO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWdDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AdGhpcmR3ZWItZGV2L3dhbGxldHMvZXZtL2Nvbm5lY3RvcnMvc21hcnQtd2FsbGV0L2Rpc3QvdGhpcmR3ZWItZGV2LXdhbGxldHMtZXZtLWNvbm5lY3RvcnMtc21hcnQtd2FsbGV0LmJyb3dzZXIuZXNtLmpzPzBjYzgiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQyBhcyBDb25uZWN0b3IgfSBmcm9tICcuLi8uLi8uLi8uLi9kaXN0L2Nvbm5lY3Rvci0wNTY4OWQ2OC5icm93c2VyLmVzbS5qcyc7XG5pbXBvcnQgeyBoIGFzIGhleGxpZnlVc2VyT3AsIEQgYXMgREVCVUcsIHIgYXMgcmFuZG9tTm9uY2UsIEggYXMgSHR0cFJwY0NsaWVudCwgZyBhcyBnZXRVc2VyT3BIYXNoVjA2IH0gZnJvbSAnLi4vLi4vLi4vLi4vZGlzdC9odHRwLXJwYy1jbGllbnQtMGEwNzllODAuYnJvd3Nlci5lc20uanMnO1xuaW1wb3J0IHsgaSBhcyBpc1R3VXJsIH0gZnJvbSAnLi4vLi4vLi4vLi4vZGlzdC91cmwtYTQ1MjE5YmQuYnJvd3Nlci5lc20uanMnO1xuaW1wb3J0IHsgcyBhcyBzZXRBbmFseXRpY3NIZWFkZXJzIH0gZnJvbSAnLi4vLi4vLi4vLi4vZGlzdC9oZWFkZXJzLTczM2E4MTk5LmJyb3dzZXIuZXNtLmpzJztcbmltcG9ydCB7IEVudHJ5UG9pbnRfX2ZhY3RvcnkgfSBmcm9tICdAYWNjb3VudC1hYnN0cmFjdGlvbi9jb250cmFjdHMnO1xuaW1wb3J0IHsgdXRpbHMsIFNpZ25lciwgZXRoZXJzLCBwcm92aWRlcnMsIENvbnRyYWN0LCBCaWdOdW1iZXIsIGNvbnN0YW50cyB9IGZyb20gJ2V0aGVycyc7XG5pbXBvcnQgeyBfIGFzIF9kZWZpbmVQcm9wZXJ0eSB9IGZyb20gJy4uLy4uLy4uLy4uL2Rpc3QvZGVmaW5lUHJvcGVydHktMzUwZmM1MDguYnJvd3Nlci5lc20uanMnO1xuaW1wb3J0IHsgc2lnblR5cGVkRGF0YUludGVybmFsLCBnZXREeW5hbWljRmVlRGF0YSwgVGhpcmR3ZWJTREssIExPQ0FMX05PREVfUEtFWSwgZ2V0Q2hhaW5Qcm92aWRlciwgZ2V0R2FzUHJpY2UgfSBmcm9tICdAdGhpcmR3ZWItZGV2L3Nkayc7XG5pbXBvcnQgeyBjaGFpbklkVG9UaGlyZHdlYlJwYyB9IGZyb20gJy4uLy4uLy4uL3dhbGxldHMvYWJzdHJhY3QvZGlzdC90aGlyZHdlYi1kZXYtd2FsbGV0cy1ldm0td2FsbGV0cy1hYnN0cmFjdC5icm93c2VyLmVzbS5qcyc7XG5pbXBvcnQgeyBjIGFzIGNoZWNrQ29udHJhY3RXYWxsZXRTaWduYXR1cmUsIEEgYXMgQUNDT1VOVF9DT1JFX0FCSSwgZiBhcyBFTlRSWVBPSU5UX0FERFJFU1MsIEQgYXMgREVGQVVMVF9GQUNUT1JZX0FERFJFU1MgfSBmcm9tICcuLi8uLi8uLi8uLi9kaXN0L3V0aWxzLWY1OGU3YWNjLmJyb3dzZXIuZXNtLmpzJztcbmltcG9ydCB7IENlbG8sIENlbG9BbGZham9yZXNUZXN0bmV0LCBDZWxvQmFrbGF2YVRlc3RuZXQgfSBmcm9tICdAdGhpcmR3ZWItZGV2L2NoYWlucyc7XG5pbXBvcnQgJ2V2ZW50ZW1pdHRlcjMnO1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cblxuLyoqXG4gKiBhbiBBUEkgdG8gZXh0ZXJuYWwgYSBVc2VyT3BlcmF0aW9uIHdpdGggcGF5bWFzdGVyIGluZm9cbiAqL1xuY2xhc3MgUGF5bWFzdGVyQVBJIHt9XG5cbmNsYXNzIFZlcmlmeWluZ1BheW1hc3RlckFQSSBleHRlbmRzIFBheW1hc3RlckFQSSB7XG4gIGNvbnN0cnVjdG9yKHBheW1hc3RlclVybCwgZW50cnlQb2ludCwgY2xpZW50SWQsIHNlY3JldEtleSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5wYXltYXN0ZXJVcmwgPSBwYXltYXN0ZXJVcmw7XG4gICAgdGhpcy5lbnRyeVBvaW50ID0gZW50cnlQb2ludDtcbiAgICB0aGlzLmNsaWVudElkID0gY2xpZW50SWQ7XG4gICAgdGhpcy5zZWNyZXRLZXkgPSBzZWNyZXRLZXk7XG4gIH1cbiAgYXN5bmMgZ2V0UGF5bWFzdGVyQW5kRGF0YSh1c2VyT3ApIHtcbiAgICBjb25zdCBoZWFkZXJzID0ge1xuICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCJcbiAgICB9O1xuICAgIGlmIChpc1R3VXJsKHRoaXMucGF5bWFzdGVyVXJsKSkge1xuICAgICAgaWYgKHRoaXMuc2VjcmV0S2V5ICYmIHRoaXMuY2xpZW50SWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHVzZSBib3RoIHNlY3JldCBrZXkgYW5kIGNsaWVudCBJRC4gUGxlYXNlIHVzZSBzZWNyZXRLZXkgZm9yIHNlcnZlci1zaWRlIGFwcGxpY2F0aW9ucyBhbmQgY2xpZW50SWQgZm9yIGNsaWVudC1zaWRlIGFwcGxpY2F0aW9ucy5cIik7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5zZWNyZXRLZXkpIHtcbiAgICAgICAgaGVhZGVyc1tcIngtc2VjcmV0LWtleVwiXSA9IHRoaXMuc2VjcmV0S2V5O1xuICAgICAgfSBlbHNlIGlmICh0aGlzLmNsaWVudElkKSB7XG4gICAgICAgIGhlYWRlcnNbXCJ4LWNsaWVudC1pZFwiXSA9IHRoaXMuY2xpZW50SWQ7XG4gICAgICAgIGNvbnN0IGJ1bmRsZUlkID0gdHlwZW9mIGdsb2JhbFRoaXMgIT09IFwidW5kZWZpbmVkXCIgJiYgXCJBUFBfQlVORExFX0lEXCIgaW4gZ2xvYmFsVGhpcyA/IGdsb2JhbFRoaXMuQVBQX0JVTkRMRV9JRCA6IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKGJ1bmRsZUlkKSB7XG4gICAgICAgICAgaGVhZGVyc1tcIngtYnVuZGxlLWlkXCJdID0gYnVuZGxlSWQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gRGFzaGJvYXJkIHRva2VuLlxuICAgICAgaWYgKHR5cGVvZiBnbG9iYWxUaGlzICE9PSBcInVuZGVmaW5lZFwiICYmIFwiVFdfQVVUSF9UT0tFTlwiIGluIGdsb2JhbFRoaXMgJiYgdHlwZW9mIGdsb2JhbFRoaXMuVFdfQVVUSF9UT0tFTiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBoZWFkZXJzW1wiYXV0aG9yaXphdGlvblwiXSA9IGBCZWFyZXIgJHtnbG9iYWxUaGlzLlRXX0FVVEhfVE9LRU59YDtcbiAgICAgIH1cblxuICAgICAgLy8gQ0xJIHRva2VuLlxuICAgICAgaWYgKHR5cGVvZiBnbG9iYWxUaGlzICE9PSBcInVuZGVmaW5lZFwiICYmIFwiVFdfQ0xJX0FVVEhfVE9LRU5cIiBpbiBnbG9iYWxUaGlzICYmIHR5cGVvZiBnbG9iYWxUaGlzLlRXX0NMSV9BVVRIX1RPS0VOID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGhlYWRlcnNbXCJhdXRob3JpemF0aW9uXCJdID0gYEJlYXJlciAke2dsb2JhbFRoaXMuVFdfQ0xJX0FVVEhfVE9LRU59YDtcbiAgICAgICAgaGVhZGVyc1tcIngtYXV0aG9yaXplLXdhbGxldFwiXSA9IFwidHJ1ZVwiO1xuICAgICAgfVxuICAgICAgc2V0QW5hbHl0aWNzSGVhZGVycyhoZWFkZXJzKTtcbiAgICB9XG5cbiAgICAvLyBBc2sgdGhlIHBheW1hc3RlciB0byBzaWduIHRoZSB0cmFuc2FjdGlvbiBhbmQgcmV0dXJuIGEgdmFsaWQgcGF5bWFzdGVyQW5kRGF0YSB2YWx1ZS5cbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHRoaXMucGF5bWFzdGVyVXJsLCB7XG4gICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgaGVhZGVycyxcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAganNvbnJwYzogXCIyLjBcIixcbiAgICAgICAgaWQ6IDEsXG4gICAgICAgIG1ldGhvZDogXCJwbV9zcG9uc29yVXNlck9wZXJhdGlvblwiLFxuICAgICAgICBwYXJhbXM6IFthd2FpdCBoZXhsaWZ5VXNlck9wKHVzZXJPcCksIHRoaXMuZW50cnlQb2ludF1cbiAgICAgIH0pXG4gICAgfSk7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgIGNvbnN0IGVycm9yID0gcmVzLmVycm9yIHx8IHJlc3BvbnNlLnN0YXR1c1RleHQ7XG4gICAgICBjb25zdCBjb2RlID0gcmVzLmNvZGUgfHwgXCJVTktOT1dOXCI7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFBheW1hc3RlciBlcnJvcjogJHtlcnJvcn1cblN0YXR1czogJHtyZXNwb25zZS5zdGF0dXN9XG5Db2RlOiAke2NvZGV9YCk7XG4gICAgfVxuICAgIGlmIChERUJVRykge1xuICAgICAgY29uc29sZS5kZWJ1ZyhcIlBheW1hc3RlciByZXN1bHQ6XCIsIHJlcyk7XG4gICAgfVxuICAgIGlmIChyZXMucmVzdWx0KSB7XG4gICAgICAvLyBzb21lIHBheW1hc3RlcnMgcmV0dXJuIGEgc3RyaW5nLCBzb21lIHJldHVybiBhbiBvYmplY3Qgd2l0aCBtb3JlIGRhdGFcbiAgICAgIGlmICh0eXBlb2YgcmVzLnJlc3VsdCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHBheW1hc3RlckFuZERhdGE6IHJlcy5yZXN1bHRcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiByZXMucmVzdWx0O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBlcnJvciA9IHJlcy5lcnJvcj8ubWVzc2FnZSB8fCByZXMuZXJyb3IgfHwgcmVzcG9uc2Uuc3RhdHVzVGV4dCB8fCBcInVua25vd24gZXJyb3JcIjtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgUGF5bWFzdGVyIGVycm9yIGZyb20gJHt0aGlzLnBheW1hc3RlclVybH06ICR7ZXJyb3J9YCk7XG4gICAgfVxuICB9XG59XG5jb25zdCBnZXRWZXJpZnlpbmdQYXltYXN0ZXIgPSAocGF5bWFzdGVyVXJsLCBlbnRyeVBvaW50LCBjbGllbnRJZCwgc2VjcmV0S2V5KSA9PiBuZXcgVmVyaWZ5aW5nUGF5bWFzdGVyQVBJKHBheW1hc3RlclVybCwgZW50cnlQb2ludCwgY2xpZW50SWQsIHNlY3JldEtleSk7XG5cbi8qKlxuICogVGhpcyBjbGFzcyBlbmNhcHN1bGF0ZXMgRXRoZXJzLmpzIGxpc3RlbmVyIGZ1bmN0aW9uIGFuZCBuZWNlc3NhcnkgVXNlck9wZXJhdGlvbiBkZXRhaWxzIHRvXG4gKiBkaXNjb3ZlciBhIFRyYW5zYWN0aW9uUmVjZWlwdCBmb3IgdGhlIG9wZXJhdGlvbi5cbiAqXG4gKiBUT0RPIHJlZmFjdG9yIHRoaXMgdG8gYSBzaW1wbGUgZXZlbnQgbGlzdGVuZXIgb24gdGhlIGVudHJ5IHBvaW50XG4gKi9cbmNsYXNzIFVzZXJPcGVyYXRpb25FdmVudExpc3RlbmVyIHtcbiAgY29uc3RydWN0b3IocmVzb2x2ZSwgcmVqZWN0LCBlbnRyeVBvaW50LCBzZW5kZXIsIHVzZXJPcEhhc2gsIG5vbmNlLCB0aW1lb3V0KSB7XG4gICAgdGhpcy5yZXNvbHZlID0gcmVzb2x2ZTtcbiAgICB0aGlzLnJlamVjdCA9IHJlamVjdDtcbiAgICB0aGlzLmVudHJ5UG9pbnQgPSBlbnRyeVBvaW50O1xuICAgIHRoaXMuc2VuZGVyID0gc2VuZGVyO1xuICAgIHRoaXMudXNlck9wSGFzaCA9IHVzZXJPcEhhc2g7XG4gICAgdGhpcy5ub25jZSA9IG5vbmNlO1xuICAgIHRoaXMudGltZW91dCA9IHRpbWVvdXQ7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwicmVzb2x2ZWRcIiwgZmFsc2UpO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbWlzdXNlZC1wcm9taXNlc1xuICAgIHRoaXMuYm91bmRMaXNlbmVyID0gdGhpcy5saXN0ZW5lckNhbGxiYWNrLmJpbmQodGhpcyk7XG4gIH1cbiAgc3RhcnQoKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1taXN1c2VkLXByb21pc2VzXG4gICAgY29uc3QgZmlsdGVyID0gdGhpcy5lbnRyeVBvaW50LmZpbHRlcnMuVXNlck9wZXJhdGlvbkV2ZW50KHRoaXMudXNlck9wSGFzaCk7XG4gICAgLy8gbGlzdGVuZXIgdGFrZXMgdGltZS4uLiBmaXJzdCBxdWVyeSBkaXJlY3RseTpcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW1pc3VzZWQtcHJvbWlzZXNcbiAgICBzZXRUaW1lb3V0KGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuZW50cnlQb2ludC5xdWVyeUZpbHRlcihmaWx0ZXIsIC0xMCk7IC8vIGxvb2sgYXQgbGFzdCAxMCBibG9ja3NcbiAgICAgIGlmIChyZXMubGVuZ3RoID4gMCkge1xuICAgICAgICB2b2lkIHRoaXMubGlzdGVuZXJDYWxsYmFjayhyZXNbMF0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5lbnRyeVBvaW50Lm9uY2UoZmlsdGVyLCB0aGlzLmJvdW5kTGlzZW5lcik7XG4gICAgICB9XG4gICAgfSwgMTAwKTtcbiAgfVxuICBzdG9wKCkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbWlzdXNlZC1wcm9taXNlc1xuICAgIHRoaXMuZW50cnlQb2ludC5vZmYoXCJVc2VyT3BlcmF0aW9uRXZlbnRcIiwgdGhpcy5ib3VuZExpc2VuZXIpO1xuICB9XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICBhc3luYyBsaXN0ZW5lckNhbGxiYWNrKCkge1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBwYXJhbSA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIHBhcmFtW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cbiAgICAvLyBUT0RPIGNsZWFuIHRoaXMgdXAuLlxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItcmVzdC1wYXJhbXNcbiAgICBjb25zdCBldmVudCA9IGFyZ3VtZW50c1thcmd1bWVudHMubGVuZ3RoIC0gMV07XG4gICAgaWYgKCFldmVudC5hcmdzKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiZ290IGV2ZW50IHdpdGhvdXQgYXJnc1wiLCBldmVudCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIFRPRE86IGNhbiB0aGlzIGhhcHBlbj8gd2UgcmVnaXN0ZXIgdG8gZXZlbnQgYnkgdXNlck9wSGFzaC4uXG4gICAgaWYgKGV2ZW50LmFyZ3MudXNlck9wSGFzaCAhPT0gdGhpcy51c2VyT3BIYXNoKSB7XG4gICAgICBjb25zb2xlLmxvZyhgPT0gZXZlbnQgd2l0aCB3cm9uZyB1c2VyT3BIYXNoOiBzZW5kZXIvbm9uY2U6IGV2ZW50LiR7ZXZlbnQuYXJncy5zZW5kZXJ9QCR7ZXZlbnQuYXJncy5ub25jZS50b1N0cmluZygpfSE9IHVzZXJPcC4ke3RoaXMuc2VuZGVyfUAke3BhcnNlSW50KHRoaXMubm9uY2U/LnRvU3RyaW5nKCkpfWApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB0cmFuc2FjdGlvblJlY2VpcHQgPSBhd2FpdCBldmVudC5nZXRUcmFuc2FjdGlvblJlY2VpcHQoKTtcblxuICAgIC8vIGJlZm9yZSByZXR1cm5pbmcgdGhlIHJlY2VpcHQsIHVwZGF0ZSB0aGUgc3RhdHVzIGZyb20gdGhlIGV2ZW50LlxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvc3RyaWN0LWJvb2xlYW4tZXhwcmVzc2lvbnNcbiAgICBpZiAoIWV2ZW50LmFyZ3Muc3VjY2Vzcykge1xuICAgICAgYXdhaXQgdGhpcy5leHRyYWN0RmFpbHVyZVJlYXNvbih0cmFuc2FjdGlvblJlY2VpcHQpO1xuICAgIH1cbiAgICB0aGlzLnN0b3AoKTtcbiAgICB0aGlzLnJlc29sdmUodHJhbnNhY3Rpb25SZWNlaXB0KTtcbiAgICB0aGlzLnJlc29sdmVkID0gdHJ1ZTtcbiAgfVxuICBhc3luYyBleHRyYWN0RmFpbHVyZVJlYXNvbihyZWNlaXB0KSB7XG4gICAgcmVjZWlwdC5zdGF0dXMgPSAwO1xuICAgIGNvbnN0IHJldmVydFJlYXNvbkV2ZW50cyA9IGF3YWl0IHRoaXMuZW50cnlQb2ludC5xdWVyeUZpbHRlcih0aGlzLmVudHJ5UG9pbnQuZmlsdGVycy5Vc2VyT3BlcmF0aW9uUmV2ZXJ0UmVhc29uKHRoaXMudXNlck9wSGFzaCwgdGhpcy5zZW5kZXIpLCByZWNlaXB0LmJsb2NrSGFzaCk7XG4gICAgaWYgKHJldmVydFJlYXNvbkV2ZW50c1swXSkge1xuICAgICAgbGV0IG1lc3NhZ2UgPSByZXZlcnRSZWFzb25FdmVudHNbMF0uYXJncy5yZXZlcnRSZWFzb247XG4gICAgICBpZiAobWVzc2FnZS5zdGFydHNXaXRoKFwiMHgwOGMzNzlhMFwiKSkge1xuICAgICAgICAvLyBFcnJvcihzdHJpbmcpXG4gICAgICAgIG1lc3NhZ2UgPSB1dGlscy5kZWZhdWx0QWJpQ29kZXIuZGVjb2RlKFtcInN0cmluZ1wiXSwgXCIweFwiICsgbWVzc2FnZS5zdWJzdHJpbmcoMTApKS50b1N0cmluZygpO1xuICAgICAgfVxuICAgICAgdGhpcy5yZWplY3QobmV3IEVycm9yKGBVc2VyT3AgZmFpbGVkIHdpdGggcmVhc29uOiAke21lc3NhZ2V9YCkpO1xuICAgIH1cbiAgfVxufVxuXG5jbGFzcyBFUkM0MzM3RXRoZXJzU2lnbmVyIGV4dGVuZHMgU2lnbmVyIHtcbiAgLy8gVE9ETzogd2UgaGF2ZSAnZXJjNDMzN3Byb3ZpZGVyJywgcmVtb3ZlIHNoYXJlZCBkZXBlbmRlbmNpZXMgb3IgYXZvaWQgdHdvLXdheSByZWZlcmVuY2VcbiAgY29uc3RydWN0b3IoY29uZmlnLCBvcmlnaW5hbFNpZ25lciwgZXJjNDMzN3Byb3ZpZGVyLCBodHRwUnBjQ2xpZW50LCBzbWFydEFjY291bnRBUEkpIHtcbiAgICBzdXBlcigpO1xuICAgIHV0aWxzLmRlZmluZVJlYWRPbmx5KHRoaXMsIFwicHJvdmlkZXJcIiwgZXJjNDMzN3Byb3ZpZGVyKTtcbiAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICB0aGlzLm9yaWdpbmFsU2lnbmVyID0gb3JpZ2luYWxTaWduZXI7XG4gICAgdGhpcy5lcmM0MzM3cHJvdmlkZXIgPSBlcmM0MzM3cHJvdmlkZXI7XG4gICAgdGhpcy5odHRwUnBjQ2xpZW50ID0gaHR0cFJwY0NsaWVudDtcbiAgICB0aGlzLnNtYXJ0QWNjb3VudEFQSSA9IHNtYXJ0QWNjb3VudEFQSTtcbiAgICB0aGlzLmFwcHJvdmluZyA9IGZhbHNlO1xuICB9XG4gIC8vIFRoaXMgb25lIGlzIGNhbGxlZCBieSBDb250cmFjdC4gSXQgc2lnbnMgdGhlIHJlcXVlc3QgYW5kIHBhc3NlcyBpbiB0byBQcm92aWRlciB0byBiZSBzZW50LlxuICBhc3luYyBzZW5kVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24sIG9wdGlvbnMpIHtcbiAgICBpZiAoIXRoaXMuYXBwcm92aW5nKSB7XG4gICAgICB0aGlzLmFwcHJvdmluZyA9IHRydWU7XG4gICAgICBjb25zdCB0eCA9IGF3YWl0IHRoaXMuc21hcnRBY2NvdW50QVBJLmNyZWF0ZUFwcHJvdmVUeCgpO1xuICAgICAgaWYgKHR4KSB7XG4gICAgICAgIGF3YWl0IChhd2FpdCB0aGlzLnNlbmRUcmFuc2FjdGlvbih0eCkpLndhaXQoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuYXBwcm92aW5nID0gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IHR4ID0gYXdhaXQgZXRoZXJzLnV0aWxzLnJlc29sdmVQcm9wZXJ0aWVzKHRyYW5zYWN0aW9uKTtcbiAgICBhd2FpdCB0aGlzLnZlcmlmeUFsbE5lY2Vzc2FyeUZpZWxkcyh0eCk7XG4gICAgY29uc3QgbXVsdGlkaW1lbnNpb25hbE5vbmNlID0gcmFuZG9tTm9uY2UoKTtcbiAgICBjb25zdCB1bnNpZ25lZCA9IGF3YWl0IHRoaXMuc21hcnRBY2NvdW50QVBJLmNyZWF0ZVVuc2lnbmVkVXNlck9wKHRoaXMuaHR0cFJwY0NsaWVudCwge1xuICAgICAgdGFyZ2V0OiB0eC50byB8fCBcIlwiLFxuICAgICAgZGF0YTogdHguZGF0YT8udG9TdHJpbmcoKSB8fCBcIjB4XCIsXG4gICAgICB2YWx1ZTogdHgudmFsdWUsXG4gICAgICBnYXNMaW1pdDogdHguZ2FzTGltaXQsXG4gICAgICBub25jZTogbXVsdGlkaW1lbnNpb25hbE5vbmNlLFxuICAgICAgbWF4RmVlUGVyR2FzOiB0eC5tYXhGZWVQZXJHYXMsXG4gICAgICBtYXhQcmlvcml0eUZlZVBlckdhczogdHgubWF4UHJpb3JpdHlGZWVQZXJHYXNcbiAgICB9LCBvcHRpb25zKTtcbiAgICBjb25zdCB1c2VyT3BlcmF0aW9uID0gYXdhaXQgdGhpcy5zbWFydEFjY291bnRBUEkuc2lnblVzZXJPcCh1bnNpZ25lZCk7XG4gICAgY29uc3QgdHJhbnNhY3Rpb25SZXNwb25zZSA9IGF3YWl0IHRoaXMuZXJjNDMzN3Byb3ZpZGVyLmNvbnN0cnVjdFVzZXJPcFRyYW5zYWN0aW9uUmVzcG9uc2UodXNlck9wZXJhdGlvbik7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHRoaXMuaHR0cFJwY0NsaWVudC5zZW5kVXNlck9wVG9CdW5kbGVyKHVzZXJPcGVyYXRpb24pO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aHJvdyB0aGlzLnVud3JhcEVycm9yKGVycm9yKTtcbiAgICB9XG4gICAgLy8gVE9ETzogaGFuZGxlIGVycm9ycyAtIHRyYW5zYWN0aW9uIHRoYXQgaXMgXCJyZWplY3RlZFwiIGJ5IGJ1bmRsZXIgaXMgX25vdCBsaWtlbHlfIHRvIGV2ZXIgcmVzb2x2ZSBpdHMgXCJ3YWl0KClcIlxuICAgIHJldHVybiB0cmFuc2FjdGlvblJlc3BvbnNlO1xuICB9XG4gIHVud3JhcEVycm9yKGVycm9ySW4pIHtcbiAgICB0cnkge1xuICAgICAgbGV0IGVycm9yTXNnID0gXCJVbmtub3duIEVycm9yXCI7XG4gICAgICBpZiAoZXJyb3JJbi5lcnJvcikge1xuICAgICAgICBlcnJvck1zZyA9IGBUaGUgYnVuZGxlciBoYXMgZmFpbGVkIHRvIGluY2x1ZGUgVXNlck9wZXJhdGlvbiBpbiBhIGJhdGNoOiAke2Vycm9ySW4uZXJyb3J9YDtcbiAgICAgIH0gZWxzZSBpZiAoZXJyb3JJbi5ib2R5ICYmIHR5cGVvZiBlcnJvckluLmJvZHkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgY29uc3QgZXJyb3JCb2R5ID0gSlNPTi5wYXJzZShlcnJvckluLmJvZHkpO1xuICAgICAgICBjb25zdCBlcnJvclN0YXR1cyA9IGVycm9ySW4uc3RhdHVzIHx8IFwiVU5LTk9XTlwiO1xuICAgICAgICBjb25zdCBlcnJvckNvZGUgPSBlcnJvckJvZHk/LmNvZGUgfHwgXCJVTktOT1dOXCI7XG4gICAgICAgIGxldCBmYWlsZWRPcE1lc3NhZ2UgPSBlcnJvckJvZHk/LmVycm9yPy5tZXNzYWdlIHx8IGVycm9yQm9keT8uZXJyb3I/LmRhdGEgfHwgZXJyb3JCb2R5Py5lcnJvciB8fCBlcnJvckluLnJlYXNvbjtcbiAgICAgICAgaWYgKGZhaWxlZE9wTWVzc2FnZT8uaW5jbHVkZXMoXCJGYWlsZWRPcFwiKSkge1xuICAgICAgICAgIGxldCBwYXltYXN0ZXJJbmZvID0gXCJcIjtcbiAgICAgICAgICAvLyBUT0RPOiBiZXR0ZXIgZXJyb3IgZXh0cmFjdGlvbiBtZXRob2RzIHdpbGwgYmUgbmVlZGVkXG4gICAgICAgICAgY29uc3QgbWF0Y2hlZCA9IGZhaWxlZE9wTWVzc2FnZS5tYXRjaCgvRmFpbGVkT3BcXCgoLiopXFwpLyk7XG4gICAgICAgICAgaWYgKG1hdGNoZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHNwbGl0ID0gbWF0Y2hlZFsxXS5zcGxpdChcIixcIik7XG4gICAgICAgICAgICBwYXltYXN0ZXJJbmZvID0gYChwYXltYXN0ZXIgYWRkcmVzczogJHtzcGxpdFsxXX0pYDtcbiAgICAgICAgICAgIGZhaWxlZE9wTWVzc2FnZSA9IHNwbGl0WzJdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlcnJvck1zZyA9IGBUaGUgYnVuZGxlciBoYXMgZmFpbGVkIHRvIGluY2x1ZGUgVXNlck9wZXJhdGlvbiBpbiBhIGJhdGNoOiAke2ZhaWxlZE9wTWVzc2FnZX0gJHtwYXltYXN0ZXJJbmZvfWA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZXJyb3JNc2cgPSBgUlBDIGVycm9yOiAke2ZhaWxlZE9wTWVzc2FnZX1cblN0YXR1czogJHtlcnJvclN0YXR1c31cbkNvZGU6ICR7ZXJyb3JDb2RlfWA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGVycm9yTXNnKTtcbiAgICAgIGVycm9yLnN0YWNrID0gZXJyb3JJbi5zdGFjaztcbiAgICAgIHJldHVybiBlcnJvcjtcbiAgICB9IGNhdGNoIChlcnJvcikge31cbiAgICByZXR1cm4gZXJyb3JJbjtcbiAgfVxuICBhc3luYyB2ZXJpZnlBbGxOZWNlc3NhcnlGaWVsZHModHJhbnNhY3Rpb25SZXF1ZXN0KSB7XG4gICAgaWYgKCF0cmFuc2FjdGlvblJlcXVlc3QudG8pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgY2FsbCB0YXJnZXRcIik7XG4gICAgfVxuICAgIGlmICghdHJhbnNhY3Rpb25SZXF1ZXN0LmRhdGEgJiYgIXRyYW5zYWN0aW9uUmVxdWVzdC52YWx1ZSkge1xuICAgICAgLy8gVEJEOiBiYW5uaW5nIG5vLW9wIFVzZXJPcHMgc2VlbXMgdG8gbWFrZSBzZW5zZSBvbiBwcm92aWRlciBsZXZlbFxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyBjYWxsIGRhdGEgb3IgdmFsdWVcIik7XG4gICAgfVxuICB9XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICBjb25uZWN0KHByb3ZpZGVyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiY2hhbmdpbmcgcHJvdmlkZXJzIGlzIG5vdCBzdXBwb3J0ZWRcIik7XG4gIH1cbiAgYXN5bmMgZ2V0QWRkcmVzcygpIHtcbiAgICBpZiAoIXRoaXMuYWRkcmVzcykge1xuICAgICAgdGhpcy5hZGRyZXNzID0gYXdhaXQgdGhpcy5lcmM0MzM3cHJvdmlkZXIuZ2V0U2VuZGVyQWNjb3VudEFkZHJlc3MoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuYWRkcmVzcztcbiAgfVxuXG4gIC8qKlxuICAgKiBTaWduIGEgbWVzc2FnZSBhbmQgcmV0dXJuIHRoZSBzaWduYXR1cmVcbiAgICovXG4gIGFzeW5jIHNpZ25NZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICAvLyBEZXBsb3kgc21hcnQgd2FsbGV0IGlmIG5lZWRlZFxuICAgIGNvbnN0IGlzTm90RGVwbG95ZWQgPSBhd2FpdCB0aGlzLnNtYXJ0QWNjb3VudEFQSS5jaGVja0FjY291bnRQaGFudG9tKCk7XG4gICAgaWYgKGlzTm90RGVwbG95ZWQpIHtcbiAgICAgIGNvbnNvbGUubG9nKFwiQWNjb3VudCBjb250cmFjdCBub3QgZGVwbG95ZWQgeWV0LiBEZXBsb3lpbmcgYWNjb3VudCBiZWZvcmUgc2lnbmluZyBtZXNzYWdlXCIpO1xuICAgICAgY29uc3QgdHggPSBhd2FpdCB0aGlzLnNlbmRUcmFuc2FjdGlvbih7XG4gICAgICAgIHRvOiBhd2FpdCB0aGlzLmdldEFkZHJlc3MoKSxcbiAgICAgICAgZGF0YTogXCIweFwiXG4gICAgICB9KTtcbiAgICAgIGF3YWl0IHR4LndhaXQoKTtcbiAgICB9XG4gICAgY29uc3QgW2NoYWluSWQsIGFkZHJlc3NdID0gYXdhaXQgUHJvbWlzZS5hbGwoW3RoaXMuZ2V0Q2hhaW5JZCgpLCB0aGlzLmdldEFkZHJlc3MoKV0pO1xuICAgIGNvbnN0IG9yaWdpbmFsTXNnSGFzaCA9IHV0aWxzLmhhc2hNZXNzYWdlKG1lc3NhZ2UpO1xuICAgIGxldCBmYWN0b3J5U3VwcG9ydHM3MTI7XG4gICAgbGV0IHNpZ25hdHVyZTtcbiAgICBjb25zdCBycGNVcmwgPSBjaGFpbklkVG9UaGlyZHdlYlJwYyhjaGFpbklkLCB0aGlzLmNvbmZpZy5jbGllbnRJZCk7XG4gICAgY29uc3QgaGVhZGVycyA9IHt9O1xuICAgIGlmIChpc1R3VXJsKHJwY1VybCkpIHtcbiAgICAgIGNvbnN0IGJ1bmRsZUlkID0gdHlwZW9mIGdsb2JhbFRoaXMgIT09IFwidW5kZWZpbmVkXCIgJiYgXCJBUFBfQlVORExFX0lEXCIgaW4gZ2xvYmFsVGhpcyA/IGdsb2JhbFRoaXMuQVBQX0JVTkRMRV9JRCA6IHVuZGVmaW5lZDtcbiAgICAgIGlmICh0aGlzLmNvbmZpZy5zZWNyZXRLZXkpIHtcbiAgICAgICAgaGVhZGVyc1tcIngtc2VjcmV0LWtleVwiXSA9IHRoaXMuY29uZmlnLnNlY3JldEtleTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5jb25maWcuY2xpZW50SWQpIHtcbiAgICAgICAgaGVhZGVyc1tcIngtY2xpZW50LWlkXCJdID0gdGhpcy5jb25maWcuY2xpZW50SWQ7XG4gICAgICAgIGlmIChidW5kbGVJZCkge1xuICAgICAgICAgIGhlYWRlcnNbXCJ4LWJ1bmRsZS1pZFwiXSA9IGJ1bmRsZUlkO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIERhc2hib2FyZCB0b2tlblxuICAgICAgaWYgKHR5cGVvZiBnbG9iYWxUaGlzICE9PSBcInVuZGVmaW5lZFwiICYmIFwiVFdfQVVUSF9UT0tFTlwiIGluIGdsb2JhbFRoaXMgJiYgdHlwZW9mIGdsb2JhbFRoaXMuVFdfQVVUSF9UT0tFTiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBoZWFkZXJzW1wiYXV0aG9yaXphdGlvblwiXSA9IGBCZWFyZXIgJHtnbG9iYWxUaGlzLlRXX0FVVEhfVE9LRU59YDtcbiAgICAgIH1cblxuICAgICAgLy8gQ0xJIHRva2VuXG4gICAgICBpZiAodHlwZW9mIGdsb2JhbFRoaXMgIT09IFwidW5kZWZpbmVkXCIgJiYgXCJUV19DTElfQVVUSF9UT0tFTlwiIGluIGdsb2JhbFRoaXMgJiYgdHlwZW9mIGdsb2JhbFRoaXMuVFdfQ0xJX0FVVEhfVE9LRU4gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgaGVhZGVyc1tcImF1dGhvcml6YXRpb25cIl0gPSBgQmVhcmVyICR7Z2xvYmFsVGhpcy5UV19DTElfQVVUSF9UT0tFTn1gO1xuICAgICAgICBoZWFkZXJzW1wieC1hdXRob3JpemUtd2FsbGV0XCJdID0gXCJ0cnVlXCI7XG4gICAgICB9XG4gICAgICBzZXRBbmFseXRpY3NIZWFkZXJzKGhlYWRlcnMpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgY29uc3QgcHJvdmlkZXIgPSBuZXcgcHJvdmlkZXJzLlN0YXRpY0pzb25ScGNQcm92aWRlcih7XG4gICAgICAgIHVybDogcnBjVXJsLFxuICAgICAgICBoZWFkZXJzXG4gICAgICB9LCBjaGFpbklkKTtcbiAgICAgIGNvbnN0IHdhbGxldENvbnRyYWN0ID0gbmV3IENvbnRyYWN0KGFkZHJlc3MsIFtcImZ1bmN0aW9uIGdldE1lc3NhZ2VIYXNoKGJ5dGVzMzIgX2hhc2gpIHB1YmxpYyB2aWV3IHJldHVybnMgKGJ5dGVzMzIpXCJdLCBwcm92aWRlcik7XG4gICAgICAvLyBpZiB0aGlzIGZhaWxzIGl0J3MgYSBwcmUgNzEyIGZhY3RvcnlcbiAgICAgIGF3YWl0IHdhbGxldENvbnRyYWN0LmdldE1lc3NhZ2VIYXNoKG9yaWdpbmFsTXNnSGFzaCk7XG4gICAgICBmYWN0b3J5U3VwcG9ydHM3MTIgPSB0cnVlO1xuICAgIH0gY2F0Y2gge1xuICAgICAgZmFjdG9yeVN1cHBvcnRzNzEyID0gZmFsc2U7XG4gICAgfVxuICAgIGlmIChmYWN0b3J5U3VwcG9ydHM3MTIpIHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHNpZ25UeXBlZERhdGFJbnRlcm5hbCh0aGlzLCB7XG4gICAgICAgIG5hbWU6IFwiQWNjb3VudFwiLFxuICAgICAgICB2ZXJzaW9uOiBcIjFcIixcbiAgICAgICAgY2hhaW5JZCxcbiAgICAgICAgdmVyaWZ5aW5nQ29udHJhY3Q6IGFkZHJlc3NcbiAgICAgIH0sIHtcbiAgICAgICAgQWNjb3VudE1lc3NhZ2U6IFt7XG4gICAgICAgICAgbmFtZTogXCJtZXNzYWdlXCIsXG4gICAgICAgICAgdHlwZTogXCJieXRlc1wiXG4gICAgICAgIH1dXG4gICAgICB9LCB7XG4gICAgICAgIG1lc3NhZ2U6IHV0aWxzLmRlZmF1bHRBYmlDb2Rlci5lbmNvZGUoW1wiYnl0ZXMzMlwiXSwgW29yaWdpbmFsTXNnSGFzaF0pXG4gICAgICB9KTtcbiAgICAgIHNpZ25hdHVyZSA9IHJlc3VsdC5zaWduYXR1cmU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNpZ25hdHVyZSA9IGF3YWl0IHRoaXMub3JpZ2luYWxTaWduZXIuc2lnbk1lc3NhZ2UobWVzc2FnZSk7XG4gICAgfVxuICAgIGNvbnN0IGlzVmFsaWQgPSBhd2FpdCBjaGVja0NvbnRyYWN0V2FsbGV0U2lnbmF0dXJlKG1lc3NhZ2UsIHNpZ25hdHVyZSwgYWRkcmVzcywgY2hhaW5JZCwgdGhpcy5jb25maWcuY2xpZW50SWQsIHRoaXMuY29uZmlnLnNlY3JldEtleSk7XG4gICAgaWYgKGlzVmFsaWQpIHtcbiAgICAgIHJldHVybiBzaWduYXR1cmU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuYWJsZSB0byB2ZXJpZnkgc2lnbmF0dXJlIG9uIHNtYXJ0IGFjY291bnQsIHBsZWFzZSBtYWtlIHN1cmUgdGhlIHNtYXJ0IGFjY291bnQgaXMgZGVwbG95ZWQgYW5kIHRoZSBzaWduYXR1cmUgaXMgdmFsaWQuXCIpO1xuICAgIH1cbiAgfVxuICBhc3luYyBzaWduVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24sIG9wdGlvbnMpIHtcbiAgICBjb25zdCB0eCA9IGF3YWl0IGV0aGVycy51dGlscy5yZXNvbHZlUHJvcGVydGllcyh0cmFuc2FjdGlvbik7XG4gICAgYXdhaXQgdGhpcy52ZXJpZnlBbGxOZWNlc3NhcnlGaWVsZHModHgpO1xuICAgIGNvbnN0IG11bHRpZGltZW5zaW9uYWxOb25jZSA9IHJhbmRvbU5vbmNlKCk7XG4gICAgY29uc3QgdW5zaWduZWQgPSBhd2FpdCB0aGlzLnNtYXJ0QWNjb3VudEFQSS5jcmVhdGVVbnNpZ25lZFVzZXJPcCh0aGlzLmh0dHBScGNDbGllbnQsIHtcbiAgICAgIHRhcmdldDogdHgudG8gfHwgXCJcIixcbiAgICAgIGRhdGE6IHR4LmRhdGE/LnRvU3RyaW5nKCkgfHwgXCIweFwiLFxuICAgICAgdmFsdWU6IHR4LnZhbHVlLFxuICAgICAgZ2FzTGltaXQ6IHR4Lmdhc0xpbWl0LFxuICAgICAgbm9uY2U6IG11bHRpZGltZW5zaW9uYWxOb25jZVxuICAgIH0sIG9wdGlvbnMpO1xuICAgIGNvbnN0IHVzZXJPcGVyYXRpb24gPSBhd2FpdCB0aGlzLnNtYXJ0QWNjb3VudEFQSS5zaWduVXNlck9wKHVuc2lnbmVkKTtcbiAgICBjb25zdCB1c2VyT3BTdHJpbmcgPSBKU09OLnN0cmluZ2lmeShhd2FpdCBoZXhsaWZ5VXNlck9wKHVzZXJPcGVyYXRpb24pKTtcbiAgICByZXR1cm4gdXNlck9wU3RyaW5nO1xuICB9XG59XG5cbmNsYXNzIEVSQzQzMzdFdGhlcnNQcm92aWRlciBleHRlbmRzIHByb3ZpZGVycy5CYXNlUHJvdmlkZXIge1xuICBjb25zdHJ1Y3RvcihjaGFpbklkLCBjb25maWcsIG9yaWdpbmFsU2lnbmVyLCBvcmlnaW5hbFByb3ZpZGVyLCBodHRwUnBjQ2xpZW50LCBlbnRyeVBvaW50LCBzbWFydEFjY291bnRBUEkpIHtcbiAgICBzdXBlcih7XG4gICAgICBuYW1lOiBcIkVSQy00MzM3IEN1c3RvbSBOZXR3b3JrXCIsXG4gICAgICBjaGFpbklkXG4gICAgfSk7XG4gICAgdGhpcy5jaGFpbklkID0gY2hhaW5JZDtcbiAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICB0aGlzLm9yaWdpbmFsU2lnbmVyID0gb3JpZ2luYWxTaWduZXI7XG4gICAgdGhpcy5vcmlnaW5hbFByb3ZpZGVyID0gb3JpZ2luYWxQcm92aWRlcjtcbiAgICB0aGlzLmh0dHBScGNDbGllbnQgPSBodHRwUnBjQ2xpZW50O1xuICAgIHRoaXMuZW50cnlQb2ludCA9IGVudHJ5UG9pbnQ7XG4gICAgdGhpcy5zbWFydEFjY291bnRBUEkgPSBzbWFydEFjY291bnRBUEk7XG4gICAgdGhpcy5zaWduZXIgPSBuZXcgRVJDNDMzN0V0aGVyc1NpZ25lcihjb25maWcsIG9yaWdpbmFsU2lnbmVyLCB0aGlzLCBodHRwUnBjQ2xpZW50LCBzbWFydEFjY291bnRBUEkpO1xuICB9XG4gIGdldFNpZ25lcigpIHtcbiAgICByZXR1cm4gdGhpcy5zaWduZXI7XG4gIH1cbiAgYXN5bmMgcGVyZm9ybShtZXRob2QsIHBhcmFtcykge1xuICAgIGlmIChtZXRob2QgPT09IFwic2VuZFRyYW5zYWN0aW9uXCIgfHwgbWV0aG9kID09PSBcImdldFRyYW5zYWN0aW9uUmVjZWlwdFwiKSB7XG4gICAgICAvLyBUT0RPOiBkbyB3ZSBuZWVkICdwZXJmb3JtJyBtZXRob2QgdG8gYmUgYXZhaWxhYmxlIGF0IGFsbD9cbiAgICAgIC8vIHRoZXJlIGlzIG5vYm9keSBvdXQgdGhlcmUgdG8gdXNlIGl0IGZvciBFUkMtNDMzNyBtZXRob2RzIHlldCwgd2UgaGF2ZSBub3RoaW5nIHRvIG92ZXJyaWRlIGluIGZhY3QuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTaG91bGQgbm90IGdldCBoZXJlLiBJbnZlc3RpZ2F0ZS5cIik7XG4gICAgfVxuICAgIGlmIChtZXRob2QgPT09IFwiZXN0aW1hdGVHYXNcIikge1xuICAgICAgLy8gZ2FzIGVzdGltYXRpb24gZG9lcyBub3RoaW5nIGF0IHRoaXMgbGF5ZXIsIHNlbmRUcmFuc2FjdGlvbiB3aWxsIGRvIHRoZSBnYXMgZXN0aW1hdGlvbiBmb3IgdGhlIHVzZXJPcFxuICAgICAgcmV0dXJuIEJpZ051bWJlci5mcm9tKDUwMDAwMCk7XG4gICAgfVxuICAgIHJldHVybiBhd2FpdCB0aGlzLm9yaWdpbmFsUHJvdmlkZXIucGVyZm9ybShtZXRob2QsIHBhcmFtcyk7XG4gIH1cbiAgYXN5bmMgZ2V0VHJhbnNhY3Rpb24odHJhbnNhY3Rpb25IYXNoKSB7XG4gICAgLy8gVE9ET1xuICAgIHJldHVybiBhd2FpdCBzdXBlci5nZXRUcmFuc2FjdGlvbih0cmFuc2FjdGlvbkhhc2gpO1xuICB9XG4gIGFzeW5jIGdldFRyYW5zYWN0aW9uUmVjZWlwdCh0cmFuc2FjdGlvbkhhc2gpIHtcbiAgICBjb25zdCB1c2VyT3BIYXNoID0gYXdhaXQgdHJhbnNhY3Rpb25IYXNoO1xuICAgIGNvbnN0IHNlbmRlciA9IGF3YWl0IHRoaXMuZ2V0U2VuZGVyQWNjb3VudEFkZHJlc3MoKTtcbiAgICByZXR1cm4gYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgbmV3IFVzZXJPcGVyYXRpb25FdmVudExpc3RlbmVyKHJlc29sdmUsIHJlamVjdCwgdGhpcy5lbnRyeVBvaW50LCBzZW5kZXIsIHVzZXJPcEhhc2gpLnN0YXJ0KCk7XG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgZ2V0U2VuZGVyQWNjb3VudEFkZHJlc3MoKSB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuc21hcnRBY2NvdW50QVBJLmdldEFjY291bnRBZGRyZXNzKCk7XG4gIH1cbiAgYXN5bmMgd2FpdEZvclRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uSGFzaCwgY29uZmlybWF0aW9ucywgdGltZW91dCkge1xuICAgIGNvbnN0IHNlbmRlciA9IGF3YWl0IHRoaXMuZ2V0U2VuZGVyQWNjb3VudEFkZHJlc3MoKTtcbiAgICByZXR1cm4gYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgY29uc3QgbGlzdGVuZXIgPSBuZXcgVXNlck9wZXJhdGlvbkV2ZW50TGlzdGVuZXIocmVzb2x2ZSwgcmVqZWN0LCB0aGlzLmVudHJ5UG9pbnQsIHNlbmRlciwgdHJhbnNhY3Rpb25IYXNoLCB1bmRlZmluZWQsIHRpbWVvdXQpO1xuICAgICAgbGlzdGVuZXIuc3RhcnQoKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8vIGZhYnJpY2F0ZSBhIHJlc3BvbnNlIGluIGEgZm9ybWF0IHVzYWJsZSBieSBldGhlcnMgdXNlcnMuLi5cbiAgYXN5bmMgY29uc3RydWN0VXNlck9wVHJhbnNhY3Rpb25SZXNwb25zZSh1c2VyT3AxKSB7XG4gICAgY29uc3QgdXNlck9wID0gYXdhaXQgdXRpbHMucmVzb2x2ZVByb3BlcnRpZXModXNlck9wMSk7XG4gICAgY29uc3QgdXNlck9wSGFzaCA9IGF3YWl0IHRoaXMuc21hcnRBY2NvdW50QVBJLmdldFVzZXJPcEhhc2godXNlck9wKTtcbiAgICByZXR1cm4ge1xuICAgICAgaGFzaDogdXNlck9wSGFzaCxcbiAgICAgIGNvbmZpcm1hdGlvbnM6IDAsXG4gICAgICBmcm9tOiB1c2VyT3Auc2VuZGVyLFxuICAgICAgbm9uY2U6IDAsXG4gICAgICAvLyBub3QgdGhlIHJlYWwgbm9uY2UsIGJ1dCBnb29kIGVub3VnaCBmb3IgdGhpcyBwdXJwb3NlXG4gICAgICBnYXNMaW1pdDogQmlnTnVtYmVyLmZyb20odXNlck9wLmNhbGxHYXNMaW1pdCksXG4gICAgICAvLyA/P1xuICAgICAgdmFsdWU6IEJpZ051bWJlci5mcm9tKDApLFxuICAgICAgZGF0YTogdXRpbHMuaGV4VmFsdWUodXNlck9wLmNhbGxEYXRhKSxcbiAgICAgIC8vIHNob3VsZCBleHRyYWN0IHRoZSBhY3R1YWwgY2FsbGVkIG1ldGhvZCBmcm9tIHRoaXMgXCJleGVjRnJvbUVudHJ5UG9pbnQoKVwiIGNhbGxcbiAgICAgIGNoYWluSWQ6IHRoaXMuY2hhaW5JZCxcbiAgICAgIHdhaXQ6IGFzeW5jIGNvbmZpcm1hdGlvbnMgPT4ge1xuICAgICAgICBjb25zdCB0cmFuc2FjdGlvblJlY2VpcHQgPSBhd2FpdCB0aGlzLnNtYXJ0QWNjb3VudEFQSS5nZXRVc2VyT3BSZWNlaXB0KHRoaXMuaHR0cFJwY0NsaWVudCwgdXNlck9wSGFzaCk7XG4gICAgICAgIGlmICh1c2VyT3AuaW5pdENvZGUubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgLy8gY2hlY2tpbmcgaWYgdGhlIHdhbGxldCBoYXMgYmVlbiBkZXBsb3llZCBieSB0aGUgdHJhbnNhY3Rpb247IGl0IG11c3QgYmUgaWYgd2UgYXJlIGhlcmVcbiAgICAgICAgICBhd2FpdCB0aGlzLnNtYXJ0QWNjb3VudEFQSS5jaGVja0FjY291bnRQaGFudG9tKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRyYW5zYWN0aW9uUmVjZWlwdDtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIGFzeW5jIGRldGVjdE5ldHdvcmsoKSB7XG4gICAgcmV0dXJuIHRoaXMub3JpZ2luYWxQcm92aWRlci5kZXRlY3ROZXR3b3JrKCk7XG4gIH1cbn1cblxuLyoqXG4gKiB3cmFwIGFuIGV4aXN0aW5nIHByb3ZpZGVyIHRvIHR1bm5lbCByZXF1ZXN0cyB0aHJvdWdoIEFjY291bnQgQWJzdHJhY3Rpb24uXG4gKiBAcGFyYW0gb3JpZ2luYWxQcm92aWRlciAtIFRoZSBub3JtYWwgcHJvdmlkZXJcbiAqIEBwYXJhbSBjb25maWcgLSBzZWUge0BsaW5rIENsaWVudENvbmZpZ30gZm9yIG1vcmUgaW5mb1xuICogQHBhcmFtIG9yaWdpbmFsU2lnbmVyIC0gdXNlIHRoaXMgc2lnbmVyIGFzIHRoZSBvd25lci4gb2YgdGhpcyB3YWxsZXQuIEJ5IGRlZmF1bHQsIHVzZSB0aGUgcHJvdmlkZXIncyBzaWduZXJcbiAqL1xuZnVuY3Rpb24gY3JlYXRlNDMzN1Byb3ZpZGVyKGNvbmZpZywgYWNjb3VudEFwaSwgb3JpZ2luYWxQcm92aWRlciwgY2hhaW5JZCkge1xuICBjb25zdCBlbnRyeVBvaW50ID0gRW50cnlQb2ludF9fZmFjdG9yeS5jb25uZWN0KGNvbmZpZy5lbnRyeVBvaW50QWRkcmVzcywgb3JpZ2luYWxQcm92aWRlcik7XG4gIGNvbnN0IGh0dHBScGNDbGllbnQgPSBuZXcgSHR0cFJwY0NsaWVudChjb25maWcuYnVuZGxlclVybCwgY29uZmlnLmVudHJ5UG9pbnRBZGRyZXNzLCBjaGFpbklkLCBjb25maWcuY2xpZW50SWQsIGNvbmZpZy5zZWNyZXRLZXkpO1xuICByZXR1cm4gbmV3IEVSQzQzMzdFdGhlcnNQcm92aWRlcihjaGFpbklkLCBjb25maWcsIGNvbmZpZy5sb2NhbFNpZ25lciwgb3JpZ2luYWxQcm92aWRlciwgaHR0cFJwY0NsaWVudCwgZW50cnlQb2ludCwgYWNjb3VudEFwaSk7XG59XG5cbmNvbnN0IERVTU1ZX1NJR05BVFVSRSA9IFwiMHhmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwN2FhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYTFjXCI7XG5cbi8qKlxuICogQmFzZSBjbGFzcyBmb3IgYWxsIFNtYXJ0IFdhbGxldCBFUkMtNDMzNyBDbGllbnRzIHRvIGltcGxlbWVudC5cbiAqIFN1YmNsYXNzIHNob3VsZCBpbmhlcml0IDUgbWV0aG9kcyB0byBzdXBwb3J0IGEgc3BlY2lmaWMgd2FsbGV0IGNvbnRyYWN0OlxuICpcbiAqIC0gZ2V0QWNjb3VudEluaXRDb2RlIC0gcmV0dXJuIHRoZSB2YWx1ZSB0byBwdXQgaW50byB0aGUgXCJpbml0Q29kZVwiIGZpZWxkLCBpZiB0aGUgYWNjb3VudCBpcyBub3QgeWV0IGRlcGxveWVkLiBzaG91bGQgY3JlYXRlIHRoZSBhY2NvdW50IGluc3RhbmNlIHVzaW5nIGEgZmFjdG9yeSBjb250cmFjdC5cbiAqIC0gZ2V0Tm9uY2UgLSByZXR1cm4gY3VycmVudCBhY2NvdW50J3Mgbm9uY2UgdmFsdWVcbiAqIC0gZW5jb2RlRXhlY3V0ZSAtIGVuY29kZSB0aGUgY2FsbCBmcm9tIGVudHJ5UG9pbnQgdGhyb3VnaCBvdXIgYWNjb3VudCB0byB0aGUgdGFyZ2V0IGNvbnRyYWN0LlxuICogLSBzaWduVXNlck9wSGFzaCAtIHNpZ24gdGhlIGhhc2ggb2YgYSBVc2VyT3AuXG4gKlxuICogVGhlIHVzZXIgY2FuIHVzZSB0aGUgZm9sbG93aW5nIEFQSXM6XG4gKiAtIGNyZWF0ZVVuc2lnbmVkVXNlck9wIC0gZ2l2ZW4gXCJ0YXJnZXRcIiBhbmQgXCJjYWxsZGF0YVwiLCBmaWxsIHVzZXJPcCB0byBwZXJmb3JtIHRoYXQgb3BlcmF0aW9uIGZyb20gdGhlIGFjY291bnQuXG4gKiAtIGNyZWF0ZVNpZ25lZFVzZXJPcCAtIGhlbHBlciB0byBjYWxsIHRoZSBhYm92ZSBjcmVhdGVVbnNpZ25lZFVzZXJPcCwgYW5kIHRoZW4gZXh0cmFjdCB0aGUgdXNlck9wSGFzaCBhbmQgc2lnbiBpdFxuICovXG5jbGFzcyBCYXNlQWNjb3VudEFQSSB7XG4gIC8vIGVudHJ5UG9pbnQgY29ubmVjdGVkIHRvIFwiemVyb1wiIGFkZHJlc3MuIGFsbG93ZWQgdG8gbWFrZSBzdGF0aWMgY2FsbHMgKGUuZy4gdG8gZ2V0U2VuZGVyQWRkcmVzcylcblxuICAvKipcbiAgICogYmFzZSBjb25zdHJ1Y3Rvci5cbiAgICogc3ViY2xhc3MgU0hPVUxEIGFkZCBwYXJhbWV0ZXJzIHRoYXQgZGVmaW5lIHRoZSBvd25lciAoc2lnbmVyKSBvZiB0aGlzIHdhbGxldFxuICAgKi9cbiAgY29uc3RydWN0b3IocGFyYW1zKSB7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiaXNQaGFudG9tXCIsIHRydWUpO1xuICAgIHRoaXMucHJvdmlkZXIgPSBwYXJhbXMucHJvdmlkZXI7XG4gICAgdGhpcy5lbnRyeVBvaW50QWRkcmVzcyA9IHBhcmFtcy5lbnRyeVBvaW50QWRkcmVzcztcbiAgICB0aGlzLmFjY291bnRBZGRyZXNzID0gcGFyYW1zLmFjY291bnRBZGRyZXNzO1xuICAgIHRoaXMucGF5bWFzdGVyQVBJID0gcGFyYW1zLnBheW1hc3RlckFQSTtcbiAgICB0aGlzLmdhc2xlc3MgPSBwYXJhbXMuZ2FzbGVzcztcbiAgICB0aGlzLmVyYzIwUGF5bWFzdGVyQWRkcmVzcyA9IHBhcmFtcy5lcmMyMFBheW1hc3RlckFkZHJlc3M7XG4gICAgdGhpcy5lcmMyMFRva2VuQWRkcmVzcyA9IHBhcmFtcy5lcmMyMFRva2VuQWRkcmVzcztcblxuICAgIC8vIGZhY3RvcnkgXCJjb25uZWN0XCIgZGVmaW5lIHRoZSBjb250cmFjdCBhZGRyZXNzLiB0aGUgY29udHJhY3QgXCJjb25uZWN0XCIgZGVmaW5lcyB0aGUgXCJmcm9tXCIgYWRkcmVzcy5cbiAgICB0aGlzLmVudHJ5UG9pbnRWaWV3ID0gRW50cnlQb2ludF9fZmFjdG9yeS5jb25uZWN0KHBhcmFtcy5lbnRyeVBvaW50QWRkcmVzcywgcGFyYW1zLnByb3ZpZGVyKS5jb25uZWN0KGV0aGVycy5jb25zdGFudHMuQWRkcmVzc1plcm8pO1xuICB9XG5cbiAgLyoqXG4gICAqIHJldHVybiB0aGUgdmFsdWUgdG8gcHV0IGludG8gdGhlIFwiaW5pdENvZGVcIiBmaWVsZCwgaWYgdGhlIGNvbnRyYWN0IGlzIG5vdCB5ZXQgZGVwbG95ZWQuXG4gICAqIHRoaXMgdmFsdWUgaG9sZHMgdGhlIFwiZmFjdG9yeVwiIGFkZHJlc3MsIGZvbGxvd2VkIGJ5IHRoaXMgYWNjb3VudCdzIGluZm9ybWF0aW9uXG4gICAqL1xuXG4gIC8qKlxuICAgKiByZXR1cm4gY3VycmVudCBhY2NvdW50J3Mgbm9uY2UuXG4gICAqL1xuXG4gIC8qKlxuICAgKiBlbmNvZGUgdGhlIGNhbGwgZnJvbSBlbnRyeVBvaW50IHRocm91Z2ggb3VyIGFjY291bnQgdG8gdGhlIHRhcmdldCBjb250cmFjdC5cbiAgICogQHBhcmFtIHRhcmdldCAtIFRoZSB0YXJnZXQgY29udHJhY3QgYWRkcmVzc1xuICAgKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gc2VuZCB0byB0aGUgdGFyZ2V0IGNvbnRyYWN0XG4gICAqIEBwYXJhbSBkYXRhIC0gVGhlIGNhbGxkYXRhIHRvIHNlbmQgdG8gdGhlIHRhcmdldCBjb250cmFjdFxuICAgKi9cblxuICAvKipcbiAgICogc2lnbiBhIHVzZXJPcCdzIGhhc2ggKHVzZXJPcEhhc2gpLlxuICAgKiBAcGFyYW0gdXNlck9wSGFzaCAtIFRoZSBoYXNoIHRvIHNpZ25cbiAgICovXG5cbiAgLyoqXG4gICAqIGNhbGN1bGF0ZSB0aGUgYWNjb3VudCBhZGRyZXNzIGV2ZW4gYmVmb3JlIGl0IGlzIGRlcGxveWVkXG4gICAqL1xuXG4gIC8qKlxuICAgKiBjaGVjayBpZiB0aGUgY29udHJhY3QgaXMgYWxyZWFkeSBkZXBsb3llZC5cbiAgICovXG4gIGFzeW5jIGNoZWNrQWNjb3VudFBoYW50b20oKSB7XG4gICAgaWYgKCF0aGlzLmlzUGhhbnRvbSkge1xuICAgICAgLy8gYWxyZWFkeSBkZXBsb3llZC4gbm8gbmVlZCB0byBjaGVjayBhbnltb3JlLlxuICAgICAgcmV0dXJuIHRoaXMuaXNQaGFudG9tO1xuICAgIH1cbiAgICBjb25zdCBzZW5kZXJBZGRyZXNzQ29kZSA9IGF3YWl0IHRoaXMucHJvdmlkZXIuZ2V0Q29kZSh0aGlzLmdldEFjY291bnRBZGRyZXNzKCkpO1xuICAgIGlmIChzZW5kZXJBZGRyZXNzQ29kZS5sZW5ndGggPiAyKSB7XG4gICAgICB0aGlzLmlzUGhhbnRvbSA9IGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5pc1BoYW50b207XG4gIH1cbiAgLyoqXG4gICAqIHJldHVybiBpbml0Q29kZSB2YWx1ZSB0byBpbnRvIHRoZSBVc2VyT3AuXG4gICAqIChlaXRoZXIgZGVwbG95bWVudCBjb2RlLCBvciBlbXB0eSBoZXggaWYgY29udHJhY3QgYWxyZWFkeSBkZXBsb3llZClcbiAgICovXG4gIGFzeW5jIGdldEluaXRDb2RlKCkge1xuICAgIGlmIChhd2FpdCB0aGlzLmNoZWNrQWNjb3VudFBoYW50b20oKSkge1xuICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuZ2V0QWNjb3VudEluaXRDb2RlKCk7XG4gICAgfVxuICAgIHJldHVybiBcIjB4XCI7XG4gIH1cblxuICAvKipcbiAgICogcmV0dXJuIG1heGltdW0gZ2FzIHVzZWQgZm9yIHZlcmlmaWNhdGlvbi5cbiAgICogTk9URTogY3JlYXRlVW5zaWduZWRVc2VyT3Agd2lsbCBhZGQgdG8gdGhpcyB2YWx1ZSB0aGUgY29zdCBvZiBjcmVhdGlvbiwgaWYgdGhlIGNvbnRyYWN0IGlzIG5vdCB5ZXQgY3JlYXRlZC5cbiAgICovXG4gIGFzeW5jIGdldFZlcmlmaWNhdGlvbkdhc0xpbWl0KCkge1xuICAgIHJldHVybiAxMDAwMDA7XG4gIH1cblxuICAvKipcbiAgICogcmV0dXJuIHVzZXJPcEhhc2ggZm9yIHNpZ25pbmcuXG4gICAqIFRoaXMgdmFsdWUgbWF0Y2hlcyBlbnRyeVBvaW50LmdldFVzZXJPcEhhc2ggKGNhbGN1bGF0ZWQgb2ZmLWNoYWluLCB0byBhdm9pZCBhIHZpZXcgY2FsbClcbiAgICogQHBhcmFtIHVzZXJPcCAtIHVzZXJPcGVyYXRpb24sIChzaWduYXR1cmUgZmllbGQgaWdub3JlZClcbiAgICovXG4gIGFzeW5jIGdldFVzZXJPcEhhc2godXNlck9wKSB7XG4gICAgY29uc3QgY2hhaW5JZCA9IGF3YWl0IHRoaXMucHJvdmlkZXIuZ2V0TmV0d29yaygpLnRoZW4obmV0ID0+IG5ldC5jaGFpbklkKTtcbiAgICByZXR1cm4gZ2V0VXNlck9wSGFzaFYwNih1c2VyT3AsIHRoaXMuZW50cnlQb2ludEFkZHJlc3MsIGNoYWluSWQpO1xuICB9XG5cbiAgLyoqXG4gICAqIHJldHVybiB0aGUgYWNjb3VudCdzIGFkZHJlc3MuXG4gICAqIHRoaXMgdmFsdWUgaXMgdmFsaWQgZXZlbiBiZWZvcmUgZGVwbG95aW5nIHRoZSBjb250cmFjdC5cbiAgICovXG4gIGFzeW5jIGdldEFjY291bnRBZGRyZXNzKCkge1xuICAgIGlmICghdGhpcy5zZW5kZXJBZGRyZXNzKSB7XG4gICAgICBpZiAodGhpcy5hY2NvdW50QWRkcmVzcykge1xuICAgICAgICB0aGlzLnNlbmRlckFkZHJlc3MgPSB0aGlzLmFjY291bnRBZGRyZXNzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zZW5kZXJBZGRyZXNzID0gYXdhaXQgdGhpcy5nZXRDb3VudGVyRmFjdHVhbEFkZHJlc3MoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuc2VuZGVyQWRkcmVzcztcbiAgfVxuICBhc3luYyBlc3RpbWF0ZUNyZWF0aW9uR2FzKGluaXRDb2RlKSB7XG4gICAgaWYgKCFpbml0Q29kZSB8fCBpbml0Q29kZSA9PT0gXCIweFwiKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgY29uc3QgZGVwbG95ZXJBZGRyZXNzID0gaW5pdENvZGUuc3Vic3RyaW5nKDAsIDQyKTtcbiAgICBjb25zdCBkZXBsb3llckNhbGxEYXRhID0gXCIweFwiICsgaW5pdENvZGUuc3Vic3RyaW5nKDQyKTtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5wcm92aWRlci5lc3RpbWF0ZUdhcyh7XG4gICAgICB0bzogZGVwbG95ZXJBZGRyZXNzLFxuICAgICAgZGF0YTogZGVwbG95ZXJDYWxsRGF0YVxuICAgIH0pO1xuICB9XG4gIGFzeW5jIGNyZWF0ZVVuc2lnbmVkVXNlck9wKGh0dHBScGNDbGllbnQsIGluZm8sIG9wdGlvbnMpIHtcbiAgICBsZXQge1xuICAgICAgbWF4RmVlUGVyR2FzLFxuICAgICAgbWF4UHJpb3JpdHlGZWVQZXJHYXNcbiAgICB9ID0gaW5mbztcbiAgICAvLyBnZXQgZmVlcyBmcm9tIGJ1bmRsZXIgaWYgYXZhaWxhYmxlXG4gICAgaWYgKGlzVHdVcmwoaHR0cFJwY0NsaWVudC5idW5kbGVyVXJsKSkge1xuICAgICAgY29uc3QgYnVuZGxlckZlZURhdGEgPSBhd2FpdCBodHRwUnBjQ2xpZW50LmdldFVzZXJPcGVyYXRpb25HYXNQcmljZSgpO1xuICAgICAgbWF4RmVlUGVyR2FzID0gQmlnTnVtYmVyLmZyb20oYnVuZGxlckZlZURhdGEubWF4RmVlUGVyR2FzKTtcbiAgICAgIG1heFByaW9yaXR5RmVlUGVyR2FzID0gQmlnTnVtYmVyLmZyb20oYnVuZGxlckZlZURhdGEubWF4UHJpb3JpdHlGZWVQZXJHYXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBpZiBidW5kbGVyIGlzIG5vdCBhdmFpbGFibGUsIHRyeSB0byBnZXQgZmVlcyBmcm9tIHRoZSBuZXR3b3JrIGlmIG5vdCBwYXNzZWQgZXhwbGljaXRseVxuICAgICAgaWYgKCFtYXhGZWVQZXJHYXMgfHwgIW1heFByaW9yaXR5RmVlUGVyR2FzKSB7XG4gICAgICAgIGNvbnN0IGZlZURhdGEgPSBhd2FpdCBnZXREeW5hbWljRmVlRGF0YSh0aGlzLnByb3ZpZGVyKTtcbiAgICAgICAgaWYgKCFtYXhQcmlvcml0eUZlZVBlckdhcykge1xuICAgICAgICAgIG1heFByaW9yaXR5RmVlUGVyR2FzID0gZmVlRGF0YS5tYXhQcmlvcml0eUZlZVBlckdhcyA/PyB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFtYXhGZWVQZXJHYXMpIHtcbiAgICAgICAgICBtYXhGZWVQZXJHYXMgPSBmZWVEYXRhLm1heEZlZVBlckdhcyA/PyB1bmRlZmluZWQ7XG4gICAgICAgICAgY29uc3QgbmV0d29yayA9IGF3YWl0IHRoaXMucHJvdmlkZXIuZ2V0TmV0d29yaygpO1xuICAgICAgICAgIGNvbnN0IGNoYWluSWQgPSBuZXR3b3JrLmNoYWluSWQ7XG4gICAgICAgICAgaWYgKGNoYWluSWQgPT09IENlbG8uY2hhaW5JZCB8fCBjaGFpbklkID09PSBDZWxvQWxmYWpvcmVzVGVzdG5ldC5jaGFpbklkIHx8IGNoYWluSWQgPT09IENlbG9CYWtsYXZhVGVzdG5ldC5jaGFpbklkKSB7XG4gICAgICAgICAgICBtYXhQcmlvcml0eUZlZVBlckdhcyA9IG1heEZlZVBlckdhcztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFtYXhGZWVQZXJHYXMgfHwgIW1heFByaW9yaXR5RmVlUGVyR2FzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJtYXhGZWVQZXJHYXMgb3IgbWF4UHJpb3JpdHlGZWVQZXJHYXMgY291bGQgbm90IGJlIGNhbGN1bGF0ZWQsIHBsZWFzZSBwYXNzIHRoZW0gZXhwbGljaXRlbHlcIik7XG4gICAgfVxuICAgIGNvbnN0IFtzZW5kZXIsIG5vbmNlXSA9IGF3YWl0IFByb21pc2UuYWxsKFt0aGlzLmdldEFjY291bnRBZGRyZXNzKCksIGluZm8ubm9uY2UgPyBQcm9taXNlLnJlc29sdmUoaW5mby5ub25jZSkgOiB0aGlzLmdldE5vbmNlKCldKTtcbiAgICBjb25zdCBpbml0Q29kZSA9IGF3YWl0IHRoaXMuZ2V0SW5pdENvZGUoKTtcbiAgICBjb25zdCB2YWx1ZSA9IHBhcnNlTnVtYmVyKGluZm8udmFsdWUpID8/IEJpZ051bWJlci5mcm9tKDApO1xuICAgIGNvbnN0IGNhbGxEYXRhID0gb3B0aW9ucz8uYmF0Y2hEYXRhID8gaW5mby5kYXRhIDogYXdhaXQgdGhpcy5wcmVwYXJlRXhlY3V0ZShpbmZvLnRhcmdldCwgdmFsdWUsIGluZm8uZGF0YSkudGhlbihhc3luYyB0eCA9PiB7XG4gICAgICBpZiAoIWluZm8uZ2FzTGltaXQpIHtcbiAgICAgICAgLy8gZXN0aW1hdGUgZ2FzIG9uIHRoZSBpbm5lciB0cmFuc2FjdGlvbnMgdG8gc2ltdWxhdGVcbiAgICAgICAgLy8gYnVuZGxlciB3b3VsZCBub3QgcmV2ZXJ0IG90aGVyd2lzZVxuICAgICAgICBhd2FpdCB0aGlzLnByb3ZpZGVyLmVzdGltYXRlR2FzKHtcbiAgICAgICAgICBmcm9tOiBzZW5kZXIsXG4gICAgICAgICAgdG86IGluZm8udGFyZ2V0LFxuICAgICAgICAgIGRhdGE6IGluZm8uZGF0YSxcbiAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHguZW5jb2RlKCk7XG4gICAgfSk7XG4gICAgY29uc3QgcGFydGlhbE9wID0ge1xuICAgICAgc2VuZGVyLFxuICAgICAgbm9uY2UsXG4gICAgICBpbml0Q29kZSxcbiAgICAgIGNhbGxEYXRhLFxuICAgICAgbWF4RmVlUGVyR2FzLFxuICAgICAgbWF4UHJpb3JpdHlGZWVQZXJHYXMsXG4gICAgICBjYWxsR2FzTGltaXQ6IEJpZ051bWJlci5mcm9tKDEwMDAwMDApLFxuICAgICAgdmVyaWZpY2F0aW9uR2FzTGltaXQ6IEJpZ051bWJlci5mcm9tKDEwMDAwMDApLFxuICAgICAgcHJlVmVyaWZpY2F0aW9uR2FzOiBCaWdOdW1iZXIuZnJvbSgxMDAwMDAwKSxcbiAgICAgIHBheW1hc3RlckFuZERhdGE6IFwiMHhcIixcbiAgICAgIHNpZ25hdHVyZTogRFVNTVlfU0lHTkFUVVJFXG4gICAgfTtcblxuICAgIC8vIHBheW1hc3RlciBkYXRhICsgbWF5YmUgdXNlZCBmb3IgZXN0aW1hdGlvbiBhcyB3ZWxsXG4gICAgY29uc3QgZ2FzbGVzcyA9IG9wdGlvbnM/Lmdhc2xlc3MgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuZ2FzbGVzcyA6IHRoaXMuZ2FzbGVzcztcbiAgICBjb25zdCB1c2VFcmMyMFBheW1hc3RlciA9IHRoaXMuZXJjMjBQYXltYXN0ZXJBZGRyZXNzICYmIHRoaXMuZXJjMjBUb2tlbkFkZHJlc3MgJiYgKGF3YWl0IHRoaXMuaXNBY2NvdW50QXBwcm92ZWQoKSk7XG4gICAgaWYgKHVzZUVyYzIwUGF5bWFzdGVyKSB7XG4gICAgICBwYXJ0aWFsT3AucGF5bWFzdGVyQW5kRGF0YSA9IHRoaXMuZXJjMjBQYXltYXN0ZXJBZGRyZXNzO1xuICAgICAgbGV0IGVzdGltYXRlcztcbiAgICAgIHRyeSB7XG4gICAgICAgIGVzdGltYXRlcyA9IGF3YWl0IGh0dHBScGNDbGllbnQuZXN0aW1hdGVVc2VyT3BHYXMocGFydGlhbE9wKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHRocm93IHRoaXMudW53cmFwQnVuZGxlckVycm9yKGVycm9yKTtcbiAgICAgIH1cbiAgICAgIHBhcnRpYWxPcC5jYWxsR2FzTGltaXQgPSBlc3RpbWF0ZXMuY2FsbEdhc0xpbWl0O1xuICAgICAgcGFydGlhbE9wLnZlcmlmaWNhdGlvbkdhc0xpbWl0ID0gZXN0aW1hdGVzLnZlcmlmaWNhdGlvbkdhc0xpbWl0O1xuICAgICAgcGFydGlhbE9wLnByZVZlcmlmaWNhdGlvbkdhcyA9IGVzdGltYXRlcy5wcmVWZXJpZmljYXRpb25HYXM7XG4gICAgfSBlbHNlIGlmIChnYXNsZXNzKSB7XG4gICAgICBjb25zdCBwYXltYXN0ZXJSZXN1bHQgPSBhd2FpdCB0aGlzLnBheW1hc3RlckFQSS5nZXRQYXltYXN0ZXJBbmREYXRhKHBhcnRpYWxPcCk7XG4gICAgICBjb25zdCBwYXltYXN0ZXJBbmREYXRhID0gcGF5bWFzdGVyUmVzdWx0LnBheW1hc3RlckFuZERhdGE7XG4gICAgICBpZiAocGF5bWFzdGVyQW5kRGF0YSAmJiBwYXltYXN0ZXJBbmREYXRhICE9PSBcIjB4XCIpIHtcbiAgICAgICAgcGFydGlhbE9wLnBheW1hc3RlckFuZERhdGEgPSBwYXltYXN0ZXJBbmREYXRhO1xuICAgICAgfVxuICAgICAgLy8gcGF5bWFzdGVyIGNhbiBoYXZlIHRoZSBnYXMgbGltaXRzIGluIHRoZSByZXNwb25zZVxuICAgICAgaWYgKHBheW1hc3RlclJlc3VsdC5jYWxsR2FzTGltaXQgJiYgcGF5bWFzdGVyUmVzdWx0LnZlcmlmaWNhdGlvbkdhc0xpbWl0ICYmIHBheW1hc3RlclJlc3VsdC5wcmVWZXJpZmljYXRpb25HYXMpIHtcbiAgICAgICAgcGFydGlhbE9wLmNhbGxHYXNMaW1pdCA9IEJpZ051bWJlci5mcm9tKHBheW1hc3RlclJlc3VsdC5jYWxsR2FzTGltaXQpO1xuICAgICAgICBwYXJ0aWFsT3AudmVyaWZpY2F0aW9uR2FzTGltaXQgPSBCaWdOdW1iZXIuZnJvbShwYXltYXN0ZXJSZXN1bHQudmVyaWZpY2F0aW9uR2FzTGltaXQpO1xuICAgICAgICBwYXJ0aWFsT3AucHJlVmVyaWZpY2F0aW9uR2FzID0gQmlnTnVtYmVyLmZyb20ocGF5bWFzdGVyUmVzdWx0LnByZVZlcmlmaWNhdGlvbkdhcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBvdGhlcndpc2UgZmFsbGJhY2sgdG8gYnVuZGxlciBmb3IgZ2FzIGxpbWl0c1xuICAgICAgICBsZXQgZXN0aW1hdGVzO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGVzdGltYXRlcyA9IGF3YWl0IGh0dHBScGNDbGllbnQuZXN0aW1hdGVVc2VyT3BHYXMocGFydGlhbE9wKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICB0aHJvdyB0aGlzLnVud3JhcEJ1bmRsZXJFcnJvcihlcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgcGFydGlhbE9wLmNhbGxHYXNMaW1pdCA9IGVzdGltYXRlcy5jYWxsR2FzTGltaXQ7XG4gICAgICAgIHBhcnRpYWxPcC52ZXJpZmljYXRpb25HYXNMaW1pdCA9IGVzdGltYXRlcy52ZXJpZmljYXRpb25HYXNMaW1pdDtcbiAgICAgICAgcGFydGlhbE9wLnByZVZlcmlmaWNhdGlvbkdhcyA9IGVzdGltYXRlcy5wcmVWZXJpZmljYXRpb25HYXM7XG4gICAgICAgIC8vIG5lZWQgcGF5bWFzdGVyIHRvIHJlLXNpZ24gYWZ0ZXIgZXN0aW1hdGVzXG4gICAgICAgIGlmIChwYXltYXN0ZXJBbmREYXRhICYmIHBheW1hc3RlckFuZERhdGEgIT09IFwiMHhcIikge1xuICAgICAgICAgIGNvbnN0IHBheW1hc3RlclJlc3VsdDIgPSBhd2FpdCB0aGlzLnBheW1hc3RlckFQSS5nZXRQYXltYXN0ZXJBbmREYXRhKHBhcnRpYWxPcCk7XG4gICAgICAgICAgaWYgKHBheW1hc3RlclJlc3VsdDIucGF5bWFzdGVyQW5kRGF0YSAmJiBwYXltYXN0ZXJSZXN1bHQyLnBheW1hc3RlckFuZERhdGEgIT09IFwiMHhcIikge1xuICAgICAgICAgICAgcGFydGlhbE9wLnBheW1hc3RlckFuZERhdGEgPSBwYXltYXN0ZXJSZXN1bHQyLnBheW1hc3RlckFuZERhdGE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHF1ZXJ5IGJ1bmRsZXIgZm9yIGdhcyBsaW1pdHNcbiAgICAgIGxldCBlc3RpbWF0ZXM7XG4gICAgICB0cnkge1xuICAgICAgICBlc3RpbWF0ZXMgPSBhd2FpdCBodHRwUnBjQ2xpZW50LmVzdGltYXRlVXNlck9wR2FzKHBhcnRpYWxPcCk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICB0aHJvdyB0aGlzLnVud3JhcEJ1bmRsZXJFcnJvcihlcnJvcik7XG4gICAgICB9XG4gICAgICBwYXJ0aWFsT3AuY2FsbEdhc0xpbWl0ID0gZXN0aW1hdGVzLmNhbGxHYXNMaW1pdDtcbiAgICAgIHBhcnRpYWxPcC52ZXJpZmljYXRpb25HYXNMaW1pdCA9IGVzdGltYXRlcy52ZXJpZmljYXRpb25HYXNMaW1pdDtcbiAgICAgIHBhcnRpYWxPcC5wcmVWZXJpZmljYXRpb25HYXMgPSBlc3RpbWF0ZXMucHJlVmVyaWZpY2F0aW9uR2FzO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgLi4ucGFydGlhbE9wLFxuICAgICAgc2lnbmF0dXJlOiBcIlwiXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTaWduIHRoZSBmaWxsZWQgdXNlck9wLlxuICAgKiBAcGFyYW0gdXNlck9wIC0gVGhlIFVzZXJPcGVyYXRpb24gdG8gc2lnbiAod2l0aCBzaWduYXR1cmUgZmllbGQgaWdub3JlZClcbiAgICovXG4gIGFzeW5jIHNpZ25Vc2VyT3AodXNlck9wKSB7XG4gICAgY29uc3QgdXNlck9wSGFzaCA9IGF3YWl0IHRoaXMuZ2V0VXNlck9wSGFzaCh1c2VyT3ApO1xuICAgIGNvbnN0IHNpZ25hdHVyZSA9IGF3YWl0IHRoaXMuc2lnblVzZXJPcEhhc2godXNlck9wSGFzaCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnVzZXJPcCxcbiAgICAgIHNpZ25hdHVyZVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogZ2V0IHRoZSB0cmFuc2FjdGlvbiB0aGF0IGhhcyB0aGlzIHVzZXJPcEhhc2ggbWluZWQsIG9yIHRocm93cyBpZiBub3QgZm91bmRcbiAgICogQHBhcmFtIHVzZXJPcEhhc2ggLSByZXR1cm5lZCBieSBzZW5kVXNlck9wVG9CdW5kbGVyIChvciBieSBnZXRVc2VyT3BIYXNoLi4pXG4gICAqIEBwYXJhbSB0aW1lb3V0IC0gc3RvcCB3YWl0aW5nIGFmdGVyIHRoaXMgdGltZW91dFxuICAgKiBAcGFyYW0gaW50ZXJ2YWwgLSB0aW1lIHRvIHdhaXQgYmV0d2VlbiBwb2xscy5cbiAgICogQHJldHVybnMgVGhlIHRyYW5zYWN0aW9uIHJlY2VpcHQsIG9yIGFuIGVycm9yIGlmIHRpbWVkIG91dC5cbiAgICovXG4gIGFzeW5jIGdldFVzZXJPcFJlY2VpcHQoaHR0cFJwY0NsaWVudCwgdXNlck9wSGFzaCkge1xuICAgIGxldCB0aW1lb3V0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAxMjAwMDA7XG4gICAgbGV0IGludGVydmFsID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiAxMDAwO1xuICAgIGNvbnN0IGVuZHRpbWUgPSBEYXRlLm5vdygpICsgdGltZW91dDtcbiAgICB3aGlsZSAoRGF0ZS5ub3coKSA8IGVuZHRpbWUpIHtcbiAgICAgIGNvbnN0IHVzZXJPcFJlY2VpcHQgPSBhd2FpdCBodHRwUnBjQ2xpZW50LmdldFVzZXJPcGVyYXRpb25SZWNlaXB0KHVzZXJPcEhhc2gpO1xuICAgICAgaWYgKHVzZXJPcFJlY2VpcHQpIHtcbiAgICAgICAgLy8gYXZvaWQgZGVzeW5jIHdpdGggY3VycmVudCBwcm92aWRlciBzdGF0ZVxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5wcm92aWRlci53YWl0Rm9yVHJhbnNhY3Rpb24odXNlck9wUmVjZWlwdC5yZWNlaXB0LnRyYW5zYWN0aW9uSGFzaCk7XG4gICAgICB9XG4gICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgaW50ZXJ2YWwpKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVGltZW91dCB3YWl0aW5nIGZvciB1c2VyT3AgdG8gYmUgbWluZWRcIik7XG4gIH1cbiAgdW53cmFwQnVuZGxlckVycm9yKGVycm9yKSB7XG4gICAgY29uc3QgbWVzc2FnZSA9IGVycm9yPy5lcnJvcj8ubWVzc2FnZSB8fCBlcnJvci5lcnJvciB8fCBlcnJvci5tZXNzYWdlIHx8IGVycm9yO1xuICAgIHJldHVybiBuZXcgRXJyb3IobWVzc2FnZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHBhcnNlTnVtYmVyKGEpIHtcbiAgaWYgKCFhIHx8IGEgPT09IFwiXCIpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gQmlnTnVtYmVyLmZyb20oYS50b1N0cmluZygpKTtcbn1cblxuY2xhc3MgQWNjb3VudEFQSSBleHRlbmRzIEJhc2VBY2NvdW50QVBJIHtcbiAgY29uc3RydWN0b3IocGFyYW1zLCBvcmlnaW5hbFByb3ZpZGVyKSB7XG4gICAgc3VwZXIoe1xuICAgICAgLi4ucGFyYW1zLFxuICAgICAgcHJvdmlkZXI6IG9yaWdpbmFsUHJvdmlkZXJcbiAgICB9KTtcbiAgICB0aGlzLnBhcmFtcyA9IHBhcmFtcztcbiAgICAvLyBUZWNobmljYWxseSBkb250IG5lZWQgdGhlIHNpZ25lciBoZXJlLCBidXQgd2UgbmVlZCB0byBlbmNvZGUvZXN0aW1hdGUgZ2FzIHdpdGggaXQgc28gYSBzaWduZXIgaXMgcmVxdWlyZWRcbiAgICAvLyBXZSBkb24ndCB3YW50IHRvIHVzZSB0aGUgbG9jYWxTaWduZXIgZGlyZWN0bHkgc2luY2UgaXQgbWlnaHQgYmUgY29ubmVjdGVkIHRvIGFub3RoZXIgY2hhaW5cbiAgICAvLyBzbyB3ZSBqdXN0IHVzZSB0aGUgcHVibGljIGhhcmRoYXQgcGtleSBpbnN0ZWFkXG4gICAgdGhpcy5zZGsgPSBUaGlyZHdlYlNESy5mcm9tUHJpdmF0ZUtleShMT0NBTF9OT0RFX1BLRVksIHBhcmFtcy5jaGFpbiwge1xuICAgICAgY2xpZW50SWQ6IHBhcmFtcy5jbGllbnRJZCxcbiAgICAgIHNlY3JldEtleTogcGFyYW1zLnNlY3JldEtleSxcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgZXhwZWN0ZWQgY2hhaW4gdHlwZSBlcnJvclxuICAgICAgc3VwcG9ydGVkQ2hhaW5zOiB0eXBlb2YgcGFyYW1zLmNoYWluID09PSBcIm9iamVjdFwiID8gW3BhcmFtcy5jaGFpbl0gOiB1bmRlZmluZWRcbiAgICB9KTtcbiAgfVxuICBhc3luYyBnZXRDaGFpbklkKCkge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLnByb3ZpZGVyLmdldE5ldHdvcmsoKS50aGVuKG4gPT4gbi5jaGFpbklkKTtcbiAgfVxuICBhc3luYyBnZXRBY2NvdW50Q29udHJhY3QoKSB7XG4gICAgaWYgKCF0aGlzLmFjY291bnRDb250cmFjdCkge1xuICAgICAgaWYgKHRoaXMucGFyYW1zLmFjY291bnRJbmZvPy5hYmkpIHtcbiAgICAgICAgdGhpcy5hY2NvdW50Q29udHJhY3QgPSBhd2FpdCB0aGlzLnNkay5nZXRDb250cmFjdChhd2FpdCB0aGlzLmdldEFjY291bnRBZGRyZXNzKCksIHRoaXMucGFyYW1zLmFjY291bnRJbmZvLmFiaSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmFjY291bnRDb250cmFjdCA9IGF3YWl0IHRoaXMuc2RrLmdldENvbnRyYWN0KGF3YWl0IHRoaXMuZ2V0QWNjb3VudEFkZHJlc3MoKSwgQUNDT1VOVF9DT1JFX0FCSSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmFjY291bnRDb250cmFjdDtcbiAgfVxuICBhc3luYyBnZXRBY2NvdW50SW5pdENvZGUoKSB7XG4gICAgY29uc3QgZmFjdG9yeSA9IGF3YWl0IHRoaXMuZ2V0RmFjdG9yeUNvbnRyYWN0KCk7XG4gICAgY29uc3QgbG9jYWxTaWduZXIgPSBhd2FpdCB0aGlzLnBhcmFtcy5sb2NhbFNpZ25lci5nZXRBZGRyZXNzKCk7XG4gICAgY29uc3QgdHggPSBhd2FpdCB0aGlzLnBhcmFtcy5mYWN0b3J5SW5mby5jcmVhdGVBY2NvdW50KGZhY3RvcnksIGxvY2FsU2lnbmVyKTtcbiAgICByZXR1cm4gdXRpbHMuaGV4Q29uY2F0KFtmYWN0b3J5LmdldEFkZHJlc3MoKSwgdHguZW5jb2RlKCldKTtcbiAgfVxuICBhc3luYyBnZXRGYWN0b3J5Q29udHJhY3QoKSB7XG4gICAgaWYgKHRoaXMuZmFjdG9yeUNvbnRyYWN0KSB7XG4gICAgICByZXR1cm4gdGhpcy5mYWN0b3J5Q29udHJhY3Q7XG4gICAgfVxuICAgIGlmICh0aGlzLnBhcmFtcy5mYWN0b3J5SW5mbz8uYWJpKSB7XG4gICAgICB0aGlzLmZhY3RvcnlDb250cmFjdCA9IGF3YWl0IHRoaXMuc2RrLmdldENvbnRyYWN0KHRoaXMucGFyYW1zLmZhY3RvcnlBZGRyZXNzLCB0aGlzLnBhcmFtcy5mYWN0b3J5SW5mby5hYmkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmZhY3RvcnlDb250cmFjdCA9IGF3YWl0IHRoaXMuc2RrLmdldENvbnRyYWN0KHRoaXMucGFyYW1zLmZhY3RvcnlBZGRyZXNzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZmFjdG9yeUNvbnRyYWN0O1xuICB9XG4gIGFzeW5jIGdldENvdW50ZXJGYWN0dWFsQWRkcmVzcygpIHtcbiAgICBpZiAodGhpcy5wYXJhbXMuYWNjb3VudEFkZHJlc3MpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcmFtcy5hY2NvdW50QWRkcmVzcztcbiAgICB9XG4gICAgY29uc3QgZmFjdG9yeSA9IGF3YWl0IHRoaXMuZ2V0RmFjdG9yeUNvbnRyYWN0KCk7XG4gICAgY29uc3QgbG9jYWxTaWduZXIgPSBhd2FpdCB0aGlzLnBhcmFtcy5sb2NhbFNpZ25lci5nZXRBZGRyZXNzKCk7XG4gICAgcmV0dXJuIHRoaXMucGFyYW1zLmZhY3RvcnlJbmZvLmdldEFjY291bnRBZGRyZXNzKGZhY3RvcnksIGxvY2FsU2lnbmVyKTtcbiAgfVxuICBhc3luYyBnZXROb25jZSgpIHtcbiAgICBpZiAoYXdhaXQgdGhpcy5jaGVja0FjY291bnRQaGFudG9tKCkpIHtcbiAgICAgIHJldHVybiBCaWdOdW1iZXIuZnJvbSgwKTtcbiAgICB9XG4gICAgY29uc3QgYWNjb3VudENvbnRyYWN0ID0gYXdhaXQgdGhpcy5nZXRBY2NvdW50Q29udHJhY3QoKTtcbiAgICByZXR1cm4gdGhpcy5wYXJhbXMuYWNjb3VudEluZm8uZ2V0Tm9uY2UoYWNjb3VudENvbnRyYWN0KTtcbiAgfVxuICBhc3luYyBwcmVwYXJlRXhlY3V0ZSh0YXJnZXQsIHZhbHVlLCBkYXRhKSB7XG4gICAgY29uc3QgYWNjb3VudENvbnRyYWN0ID0gYXdhaXQgdGhpcy5nZXRBY2NvdW50Q29udHJhY3QoKTtcbiAgICByZXR1cm4gdGhpcy5wYXJhbXMuYWNjb3VudEluZm8uZXhlY3V0ZShhY2NvdW50Q29udHJhY3QsIHRhcmdldCwgdmFsdWUsIGRhdGEpO1xuICB9XG4gIGFzeW5jIHByZXBhcmVFeGVjdXRlQmF0Y2godGFyZ2V0cywgdmFsdWVzLCBkYXRhcykge1xuICAgIGNvbnN0IGFjY291bnRDb250cmFjdCA9IGF3YWl0IHRoaXMuZ2V0QWNjb3VudENvbnRyYWN0KCk7XG4gICAgcmV0dXJuIGFjY291bnRDb250cmFjdC5wcmVwYXJlKFwiZXhlY3V0ZUJhdGNoXCIsIFt0YXJnZXRzLCB2YWx1ZXMsIGRhdGFzXSk7XG4gIH1cbiAgYXN5bmMgc2lnblVzZXJPcEhhc2godXNlck9wSGFzaCkge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLnBhcmFtcy5sb2NhbFNpZ25lci5zaWduTWVzc2FnZSh1dGlscy5hcnJheWlmeSh1c2VyT3BIYXNoKSk7XG4gIH1cbiAgYXN5bmMgaXNBY291bnREZXBsb3llZCgpIHtcbiAgICByZXR1cm4gIShhd2FpdCB0aGlzLmNoZWNrQWNjb3VudFBoYW50b20oKSk7XG4gIH1cbiAgYXN5bmMgaXNBY2NvdW50QXBwcm92ZWQoKSB7XG4gICAgaWYgKCF0aGlzLnBhcmFtcy5lcmMyMFBheW1hc3RlckFkZHJlc3MgfHwgIXRoaXMucGFyYW1zLmVyYzIwVG9rZW5BZGRyZXNzKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY29uc3Qgc3dBZGRyZXNzID0gYXdhaXQgdGhpcy5nZXRDb3VudGVyRmFjdHVhbEFkZHJlc3MoKTtcbiAgICBjb25zdCBFUkMyMEFiaSA9IChhd2FpdCBpbXBvcnQoJ0B0aGlyZHdlYi1kZXYvY29udHJhY3RzLWpzL2Rpc3QvYWJpcy9JRVJDMjAuanNvbicpKS5kZWZhdWx0O1xuICAgIGNvbnN0IGVyYzIwVG9rZW4gPSBhd2FpdCB0aGlzLnNkay5nZXRDb250cmFjdCh0aGlzLnBhcmFtcy5lcmMyMFRva2VuQWRkcmVzcywgRVJDMjBBYmkpO1xuICAgIGNvbnN0IGFsbG93YW5jZSA9IGF3YWl0IGVyYzIwVG9rZW4uY2FsbChcImFsbG93YW5jZVwiLCBbc3dBZGRyZXNzLCB0aGlzLnBhcmFtcy5lcmMyMFBheW1hc3RlckFkZHJlc3NdKTtcbiAgICByZXR1cm4gYWxsb3dhbmNlLmd0ZShCaWdOdW1iZXIuZnJvbSgyKS5wb3coOTYpLnN1YigxKSk7XG4gIH1cbiAgYXN5bmMgY3JlYXRlQXBwcm92ZVR4KCkge1xuICAgIGlmIChhd2FpdCB0aGlzLmlzQWNjb3VudEFwcHJvdmVkKCkpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGNvbnN0IGFtb3VudFRvQXBwcm92ZSA9IEJpZ051bWJlci5mcm9tKDIpLnBvdyg5Nikuc3ViKDEpO1xuICAgIGNvbnN0IGV0aGVyc1NpZ25lciA9IG5ldyBldGhlcnMuV2FsbGV0KExPQ0FMX05PREVfUEtFWSwgdGhpcy5wcm92aWRlcik7XG4gICAgY29uc3QgZXJjMjBDb250cmFjdCA9IG5ldyBDb250cmFjdCh0aGlzLnBhcmFtcy5lcmMyMFRva2VuQWRkcmVzcywgW1wiZnVuY3Rpb24gYXBwcm92ZShhZGRyZXNzIHNwZW5kZXIsIHVpbnQyNTYgYW1vdW50KSBwdWJsaWMgcmV0dXJucyAoYm9vbClcIl0sIGV0aGVyc1NpZ25lcik7XG4gICAgY29uc3QgdHggPSB7XG4gICAgICB0bzogdGhpcy5wYXJhbXMuZXJjMjBUb2tlbkFkZHJlc3MsXG4gICAgICBmcm9tOiBhd2FpdCB0aGlzLmdldEFjY291bnRBZGRyZXNzKCksXG4gICAgICB2YWx1ZTogMCxcbiAgICAgIGRhdGE6IGVyYzIwQ29udHJhY3QuaW50ZXJmYWNlLmVuY29kZUZ1bmN0aW9uRGF0YShcImFwcHJvdmVcIiwgW3RoaXMucGFyYW1zLmVyYzIwUGF5bWFzdGVyQWRkcmVzcywgYW1vdW50VG9BcHByb3ZlXSlcbiAgICB9O1xuICAgIHJldHVybiB0eDtcbiAgfVxufVxuXG5jbGFzcyBTbWFydFdhbGxldENvbm5lY3RvciBleHRlbmRzIENvbm5lY3RvciB7XG4gIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gIH1cbiAgYXN5bmMgaW5pdGlhbGl6ZShwYXJhbXMpIHtcbiAgICBjb25zdCBjb25maWcgPSB0aGlzLmNvbmZpZztcbiAgICBjb25zdCBvcmlnaW5hbFByb3ZpZGVyID0gZ2V0Q2hhaW5Qcm92aWRlcihjb25maWcuY2hhaW4sIHtcbiAgICAgIGNsaWVudElkOiBjb25maWcuY2xpZW50SWQsXG4gICAgICBzZWNyZXRLZXk6IGNvbmZpZy5zZWNyZXRLZXlcbiAgICB9KTtcbiAgICB0aGlzLmNoYWluSWQgPSAoYXdhaXQgb3JpZ2luYWxQcm92aWRlci5nZXROZXR3b3JrKCkpLmNoYWluSWQ7XG4gICAgY29uc3QgYnVuZGxlclVybCA9IHRoaXMuY29uZmlnLmJ1bmRsZXJVcmwgfHwgYGh0dHBzOi8vJHt0aGlzLmNoYWluSWR9LmJ1bmRsZXIudGhpcmR3ZWIuY29tYDtcbiAgICBjb25zdCBwYXltYXN0ZXJVcmwgPSB0aGlzLmNvbmZpZy5wYXltYXN0ZXJVcmwgfHwgYGh0dHBzOi8vJHt0aGlzLmNoYWluSWR9LmJ1bmRsZXIudGhpcmR3ZWIuY29tYDtcbiAgICBjb25zdCBlbnRyeVBvaW50QWRkcmVzcyA9IGNvbmZpZy5lbnRyeVBvaW50QWRkcmVzcyB8fCBFTlRSWVBPSU5UX0FERFJFU1M7XG4gICAgY29uc3QgbG9jYWxTaWduZXIgPSBhd2FpdCBwYXJhbXMucGVyc29uYWxXYWxsZXQuZ2V0U2lnbmVyKCk7XG4gICAgY29uc3QgcHJvdmlkZXJDb25maWcgPSB7XG4gICAgICBjaGFpbjogY29uZmlnLmNoYWluLFxuICAgICAgbG9jYWxTaWduZXIsXG4gICAgICBlbnRyeVBvaW50QWRkcmVzcyxcbiAgICAgIGJ1bmRsZXJVcmwsXG4gICAgICBwYXltYXN0ZXJBUEk6IHRoaXMuY29uZmlnLnBheW1hc3RlckFQSSA/IHRoaXMuY29uZmlnLnBheW1hc3RlckFQSSA6IGdldFZlcmlmeWluZ1BheW1hc3RlcihwYXltYXN0ZXJVcmwsIGVudHJ5UG9pbnRBZGRyZXNzLCB0aGlzLmNvbmZpZy5jbGllbnRJZCwgdGhpcy5jb25maWcuc2VjcmV0S2V5KSxcbiAgICAgIGdhc2xlc3M6IGNvbmZpZy5nYXNsZXNzLFxuICAgICAgZmFjdG9yeUFkZHJlc3M6IGNvbmZpZy5mYWN0b3J5QWRkcmVzcyB8fCBERUZBVUxUX0ZBQ1RPUllfQUREUkVTUyxcbiAgICAgIGFjY291bnRBZGRyZXNzOiBwYXJhbXMuYWNjb3VudEFkZHJlc3MsXG4gICAgICBmYWN0b3J5SW5mbzoge1xuICAgICAgICBjcmVhdGVBY2NvdW50OiBjb25maWcuZmFjdG9yeUluZm8/LmNyZWF0ZUFjY291bnQgfHwgdGhpcy5kZWZhdWx0RmFjdG9yeUluZm8oKS5jcmVhdGVBY2NvdW50LFxuICAgICAgICBnZXRBY2NvdW50QWRkcmVzczogY29uZmlnLmZhY3RvcnlJbmZvPy5nZXRBY2NvdW50QWRkcmVzcyB8fCB0aGlzLmRlZmF1bHRGYWN0b3J5SW5mbygpLmdldEFjY291bnRBZGRyZXNzLFxuICAgICAgICBhYmk6IGNvbmZpZy5mYWN0b3J5SW5mbz8uYWJpXG4gICAgICB9LFxuICAgICAgYWNjb3VudEluZm86IHtcbiAgICAgICAgZXhlY3V0ZTogY29uZmlnLmFjY291bnRJbmZvPy5leGVjdXRlIHx8IHRoaXMuZGVmYXVsdEFjY291bnRJbmZvKCkuZXhlY3V0ZSxcbiAgICAgICAgZ2V0Tm9uY2U6IGNvbmZpZy5hY2NvdW50SW5mbz8uZ2V0Tm9uY2UgfHwgdGhpcy5kZWZhdWx0QWNjb3VudEluZm8oKS5nZXROb25jZSxcbiAgICAgICAgYWJpOiBjb25maWcuYWNjb3VudEluZm8/LmFiaVxuICAgICAgfSxcbiAgICAgIGNsaWVudElkOiBjb25maWcuY2xpZW50SWQsXG4gICAgICBzZWNyZXRLZXk6IGNvbmZpZy5zZWNyZXRLZXksXG4gICAgICBlcmMyMFBheW1hc3RlckFkZHJlc3M6IGNvbmZpZy5lcmMyMFBheW1hc3RlckFkZHJlc3MsXG4gICAgICBlcmMyMFRva2VuQWRkcmVzczogY29uZmlnLmVyYzIwVG9rZW5BZGRyZXNzXG4gICAgfTtcbiAgICB0aGlzLnBlcnNvbmFsV2FsbGV0ID0gcGFyYW1zLnBlcnNvbmFsV2FsbGV0O1xuICAgIGNvbnN0IGFjY291bnRBcGkgPSBuZXcgQWNjb3VudEFQSShwcm92aWRlckNvbmZpZywgb3JpZ2luYWxQcm92aWRlcik7XG4gICAgdGhpcy5hYVByb3ZpZGVyID0gY3JlYXRlNDMzN1Byb3ZpZGVyKHByb3ZpZGVyQ29uZmlnLCBhY2NvdW50QXBpLCBvcmlnaW5hbFByb3ZpZGVyLCB0aGlzLmNoYWluSWQpO1xuICAgIHRoaXMuYWNjb3VudEFwaSA9IGFjY291bnRBcGk7XG4gIH1cbiAgYXN5bmMgY29ubmVjdChjb25uZWN0aW9uQXJncykge1xuICAgIGF3YWl0IHRoaXMuaW5pdGlhbGl6ZShjb25uZWN0aW9uQXJncyk7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuZ2V0QWRkcmVzcygpO1xuICB9XG4gIGdldFByb3ZpZGVyKCkge1xuICAgIGlmICghdGhpcy5hYVByb3ZpZGVyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQZXJzb25hbCB3YWxsZXQgbm90IGNvbm5lY3RlZFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLmFhUHJvdmlkZXIpO1xuICB9XG4gIGFzeW5jIGdldFNpZ25lcigpIHtcbiAgICBpZiAoIXRoaXMuYWFQcm92aWRlcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUGVyc29uYWwgd2FsbGV0IG5vdCBjb25uZWN0ZWRcIik7XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5hYVByb3ZpZGVyLmdldFNpZ25lcigpKTtcbiAgfVxuICBhc3luYyBnZXRBZGRyZXNzKCkge1xuICAgIGNvbnN0IHNpZ25lciA9IGF3YWl0IHRoaXMuZ2V0U2lnbmVyKCk7XG4gICAgcmV0dXJuIHNpZ25lci5nZXRBZGRyZXNzKCk7XG4gIH1cbiAgYXN5bmMgaXNDb25uZWN0ZWQoKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGFkZHJlc3MgPSBhd2FpdCB0aGlzLmdldEFkZHJlc3MoKTtcbiAgICAgIHJldHVybiAhIWFkZHJlc3M7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICBhc3luYyBkaXNjb25uZWN0KCkge1xuICAgIHRoaXMucGVyc29uYWxXYWxsZXQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5hYVByb3ZpZGVyID0gdW5kZWZpbmVkO1xuICB9XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcblxuICBhc3luYyBzd2l0Y2hDaGFpbihjaGFpbklkKSB7XG4gICAgY29uc3QgcHJvdmlkZXIgPSBhd2FpdCB0aGlzLmdldFByb3ZpZGVyKCk7XG4gICAgY29uc3QgY3VycmVudENoYWluSWQgPSAoYXdhaXQgcHJvdmlkZXIuZ2V0TmV0d29yaygpKS5jaGFpbklkO1xuICAgIGlmIChjdXJyZW50Q2hhaW5JZCAhPT0gY2hhaW5JZCkge1xuICAgICAgLy8gb25seSB0aHJvdyBpZiBhY3R1YWxseSB0cnlpbmcgdG8gc3dpdGNoIGNoYWluc1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm90IHN1cHBvcnRlZC5cIik7XG4gICAgfVxuICB9XG4gIHNldHVwTGlzdGVuZXJzKCkge1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgfVxuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgdXBkYXRlQ2hhaW5zKGNoYWlucykge31cblxuICAvKipcbiAgICogQ2hlY2sgd2hldGhlciB0aGUgY29ubmVjdGVkIHNpZ25lciBjYW4gZXhlY3V0ZSBhIGdpdmVuIHRyYW5zYWN0aW9uIHVzaW5nIHRoZSBzbWFydCB3YWxsZXQuXG4gICAqIEBwYXJhbSB0cmFuc2FjdGlvbiAtIFRoZSB0cmFuc2FjdGlvbiB0byBleGVjdXRlIHVzaW5nIHRoZSBzbWFydCB3YWxsZXQuXG4gICAqIEByZXR1cm5zIHdoZXRoZXIgdGhlIGNvbm5lY3RlZCBzaWduZXIgY2FuIGV4ZWN1dGUgdGhlIHRyYW5zYWN0aW9uIHVzaW5nIHRoZSBzbWFydCB3YWxsZXQuXG4gICAqL1xuICBhc3luYyBoYXNQZXJtaXNzaW9uVG9FeGVjdXRlKHRyYW5zYWN0aW9uKSB7XG4gICAgY29uc3QgYWNjb3VudENvbnRyYWN0ID0gYXdhaXQgdGhpcy5nZXRBY2NvdW50Q29udHJhY3QoKTtcbiAgICBjb25zdCBzaWduZXIgPSBhd2FpdCB0aGlzLmdldFNpZ25lcigpO1xuICAgIGNvbnN0IHNpZ25lckFkZHJlc3MgPSBhd2FpdCBzaWduZXIuZ2V0QWRkcmVzcygpO1xuICAgIGNvbnN0IHJlc3RyaWN0aW9ucyA9IChhd2FpdCBhY2NvdW50Q29udHJhY3QuYWNjb3VudC5nZXRBbGxTaWduZXJzKCkpLmZpbHRlcihpdGVtID0+IGV0aGVycy51dGlscy5nZXRBZGRyZXNzKGl0ZW0uc2lnbmVyKSA9PT0gZXRoZXJzLnV0aWxzLmdldEFkZHJlc3Moc2lnbmVyQWRkcmVzcykpWzBdPy5wZXJtaXNzaW9ucztcbiAgICBpZiAoIXJlc3RyaWN0aW9ucykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdHJpY3Rpb25zLmFwcHJvdmVkQ2FsbFRhcmdldHMuaW5jbHVkZXModHJhbnNhY3Rpb24uZ2V0VGFyZ2V0KCkpO1xuICB9XG5cbiAgLy8vIFBSRVBBUkVEIFRSQU5TQUNUSU9OU1xuXG4gIC8qKlxuICAgKiBTZW5kIGEgc2luZ2xlIHRyYW5zYWN0aW9uIHdpdGhvdXQgd2FpdGluZyBmb3IgY29uZmlybWF0aW9uc1xuICAgKiBAcGFyYW0gdHJhbnNhY3Rpb24gLSB0aGUgdHJhbnNhY3Rpb24gdG8gc2VuZFxuICAgKiBAcGFyYW0gY29uZmlnIC0gb3B0aW9uYWwgdGhlIHRyYW5zYWN0aW9uIGNvbmZpZ3VyYXRpb25cbiAgICogQHJldHVybnMgVGhlIGF3YWl0YWJsZSB0cmFuc2FjdGlvblxuICAgKi9cbiAgYXN5bmMgc2VuZCh0cmFuc2FjdGlvbiwgb3B0aW9ucykge1xuICAgIGNvbnN0IHNpZ25lciA9IGF3YWl0IHRoaXMuZ2V0U2lnbmVyKCk7XG4gICAgcmV0dXJuIHNpZ25lci5zZW5kVHJhbnNhY3Rpb24oe1xuICAgICAgdG86IHRyYW5zYWN0aW9uLmdldFRhcmdldCgpLFxuICAgICAgZGF0YTogdHJhbnNhY3Rpb24uZW5jb2RlKCksXG4gICAgICB2YWx1ZTogYXdhaXQgdHJhbnNhY3Rpb24uZ2V0VmFsdWUoKVxuICAgIH0sIG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEV4ZWN1dGUgYSBzaW5nbGUgdHJhbnNhY3Rpb24gKHdhaXRpbmcgZm9yIGNvbmZpcm1hdGlvbnMpXG4gICAqIEBwYXJhbSB0cmFuc2FjdGlvbiAtIFRoZSB0cmFuc2FjdGlvbiB0byBleGVjdXRlXG4gICAqIEByZXR1cm5zIFRoZSB0cmFuc2FjdGlvbiByZWNlaXB0XG4gICAqL1xuICBhc3luYyBleGVjdXRlKHRyYW5zYWN0aW9uLCBvcHRpb25zKSB7XG4gICAgY29uc3QgdHggPSBhd2FpdCB0aGlzLnNlbmQodHJhbnNhY3Rpb24sIG9wdGlvbnMpO1xuICAgIGNvbnN0IHJlY2VpcHQgPSBhd2FpdCB0eC53YWl0KCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlY2VpcHRcbiAgICB9O1xuICB9XG4gIGFzeW5jIHNlbmRCYXRjaCh0cmFuc2FjdGlvbnMsIG9wdGlvbnMpIHtcbiAgICBpZiAoIXRoaXMuYWNjb3VudEFwaSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUGVyc29uYWwgd2FsbGV0IG5vdCBjb25uZWN0ZWRcIik7XG4gICAgfVxuICAgIGNvbnN0IHNpZ25lciA9IGF3YWl0IHRoaXMuZ2V0U2lnbmVyKCk7XG4gICAgY29uc3Qge1xuICAgICAgdHgsXG4gICAgICBiYXRjaERhdGFcbiAgICB9ID0gYXdhaXQgdGhpcy5wcmVwYXJlQmF0Y2hUeCh0cmFuc2FjdGlvbnMpO1xuICAgIHJldHVybiBhd2FpdCBzaWduZXIuc2VuZFRyYW5zYWN0aW9uKHtcbiAgICAgIHRvOiBhd2FpdCBzaWduZXIuZ2V0QWRkcmVzcygpLFxuICAgICAgZGF0YTogdHguZW5jb2RlKCksXG4gICAgICB2YWx1ZTogMFxuICAgIH0sIHtcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICBiYXRjaERhdGFcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFeGVjdXRlIG11bHRpcGxlIHRyYW5zYWN0aW9ucyBpbiBhIHNpbmdsZSBiYXRjaFxuICAgKiBAcGFyYW0gdHJhbnNhY3Rpb25zIC0gVGhlIHRyYW5zYWN0aW9ucyB0byBleGVjdXRlXG4gICAqIEByZXR1cm5zIFRoZSB0cmFuc2FjdGlvbiByZWNlaXB0XG4gICAqL1xuICBhc3luYyBleGVjdXRlQmF0Y2godHJhbnNhY3Rpb25zLCBvcHRpb25zKSB7XG4gICAgY29uc3QgdHggPSBhd2FpdCB0aGlzLnNlbmRCYXRjaCh0cmFuc2FjdGlvbnMsIG9wdGlvbnMpO1xuICAgIGNvbnN0IHJlY2VpcHQgPSBhd2FpdCB0eC53YWl0KCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlY2VpcHRcbiAgICB9O1xuICB9XG5cbiAgLy8vIFJBVyBUUkFOU0FDVElPTlNcblxuICBhc3luYyBzZW5kUmF3KHRyYW5zYWN0aW9uLCBvcHRpb25zKSB7XG4gICAgaWYgKCF0aGlzLmFjY291bnRBcGkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlBlcnNvbmFsIHdhbGxldCBub3QgY29ubmVjdGVkXCIpO1xuICAgIH1cbiAgICBjb25zdCBzaWduZXIgPSBhd2FpdCB0aGlzLmdldFNpZ25lcigpO1xuICAgIHJldHVybiBzaWduZXIuc2VuZFRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uLCBvcHRpb25zKTtcbiAgfVxuICBhc3luYyBleGVjdXRlUmF3KHRyYW5zYWN0aW9uLCBvcHRpb25zKSB7XG4gICAgY29uc3QgdHggPSBhd2FpdCB0aGlzLnNlbmRSYXcodHJhbnNhY3Rpb24sIG9wdGlvbnMpO1xuICAgIGNvbnN0IHJlY2VpcHQgPSBhd2FpdCB0eC53YWl0KCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlY2VpcHRcbiAgICB9O1xuICB9XG4gIGFzeW5jIHNlbmRCYXRjaFJhdyh0cmFuc2FjdGlvbnMsIG9wdGlvbnMpIHtcbiAgICBpZiAoIXRoaXMuYWNjb3VudEFwaSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUGVyc29uYWwgd2FsbGV0IG5vdCBjb25uZWN0ZWRcIik7XG4gICAgfVxuICAgIGNvbnN0IHNpZ25lciA9IGF3YWl0IHRoaXMuZ2V0U2lnbmVyKCk7XG4gICAgY29uc3QgYmF0Y2ggPSBhd2FpdCB0aGlzLnByZXBhcmVCYXRjaFJhdyh0cmFuc2FjdGlvbnMpO1xuICAgIHJldHVybiBzaWduZXIuc2VuZFRyYW5zYWN0aW9uKHtcbiAgICAgIHRvOiBhd2FpdCBzaWduZXIuZ2V0QWRkcmVzcygpLFxuICAgICAgZGF0YTogYmF0Y2gudHguZW5jb2RlKCksXG4gICAgICB2YWx1ZTogMFxuICAgIH0sIHtcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICBiYXRjaERhdGE6IGJhdGNoLmJhdGNoRGF0YSAvLyBiYXRjaGVkIHR4IGZsYWdcbiAgICB9KTtcbiAgfVxuICBhc3luYyBleGVjdXRlQmF0Y2hSYXcodHJhbnNhY3Rpb25zLCBvcHRpb25zKSB7XG4gICAgY29uc3QgdHggPSBhd2FpdCB0aGlzLnNlbmRCYXRjaFJhdyh0cmFuc2FjdGlvbnMsIG9wdGlvbnMpO1xuICAgIGNvbnN0IHJlY2VpcHQgPSBhd2FpdCB0eC53YWl0KCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlY2VpcHRcbiAgICB9O1xuICB9XG5cbiAgLy8vIEVTVElNQVRJT05cblxuICBhc3luYyBlc3RpbWF0ZSh0cmFuc2FjdGlvbiwgb3B0aW9ucykge1xuICAgIGlmICghdGhpcy5hY2NvdW50QXBpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQZXJzb25hbCB3YWxsZXQgbm90IGNvbm5lY3RlZFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZXN0aW1hdGVUeCh7XG4gICAgICB0YXJnZXQ6IHRyYW5zYWN0aW9uLmdldFRhcmdldCgpLFxuICAgICAgZGF0YTogdHJhbnNhY3Rpb24uZW5jb2RlKCksXG4gICAgICB2YWx1ZTogYXdhaXQgdHJhbnNhY3Rpb24uZ2V0VmFsdWUoKSxcbiAgICAgIGdhc0xpbWl0OiBhd2FpdCB0cmFuc2FjdGlvbi5nZXRPdmVycmlkZXMoKS5nYXNMaW1pdCxcbiAgICAgIG1heEZlZVBlckdhczogYXdhaXQgdHJhbnNhY3Rpb24uZ2V0T3ZlcnJpZGVzKCkubWF4RmVlUGVyR2FzLFxuICAgICAgbWF4UHJpb3JpdHlGZWVQZXJHYXM6IGF3YWl0IHRyYW5zYWN0aW9uLmdldE92ZXJyaWRlcygpLm1heFByaW9yaXR5RmVlUGVyR2FzLFxuICAgICAgbm9uY2U6IGF3YWl0IHRyYW5zYWN0aW9uLmdldE92ZXJyaWRlcygpLm5vbmNlXG4gICAgfSwgb3B0aW9ucyk7XG4gIH1cbiAgYXN5bmMgZXN0aW1hdGVSYXcodHJhbnNhY3Rpb24sIG9wdGlvbnMpIHtcbiAgICBpZiAoIXRoaXMuYWNjb3VudEFwaSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUGVyc29uYWwgd2FsbGV0IG5vdCBjb25uZWN0ZWRcIik7XG4gICAgfVxuICAgIGNvbnN0IHR4ID0gYXdhaXQgZXRoZXJzLnV0aWxzLnJlc29sdmVQcm9wZXJ0aWVzKHRyYW5zYWN0aW9uKTtcbiAgICByZXR1cm4gdGhpcy5lc3RpbWF0ZVR4KHtcbiAgICAgIHRhcmdldDogdHgudG8gfHwgY29uc3RhbnRzLkFkZHJlc3NaZXJvLFxuICAgICAgZGF0YTogdHguZGF0YT8udG9TdHJpbmcoKSB8fCBcIlwiLFxuICAgICAgdmFsdWU6IHR4LnZhbHVlIHx8IEJpZ051bWJlci5mcm9tKDApLFxuICAgICAgZ2FzTGltaXQ6IHR4Lmdhc0xpbWl0LFxuICAgICAgbWF4RmVlUGVyR2FzOiB0eC5tYXhGZWVQZXJHYXMsXG4gICAgICBtYXhQcmlvcml0eUZlZVBlckdhczogdHgubWF4UHJpb3JpdHlGZWVQZXJHYXMsXG4gICAgICBub25jZTogdHgubm9uY2VcbiAgICB9LCBvcHRpb25zKTtcbiAgfVxuICBhc3luYyBlc3RpbWF0ZUJhdGNoKHRyYW5zYWN0aW9ucywgb3B0aW9ucykge1xuICAgIGlmICghdGhpcy5hY2NvdW50QXBpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQZXJzb25hbCB3YWxsZXQgbm90IGNvbm5lY3RlZFwiKTtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgdHgsXG4gICAgICBiYXRjaERhdGFcbiAgICB9ID0gYXdhaXQgdGhpcy5wcmVwYXJlQmF0Y2hUeCh0cmFuc2FjdGlvbnMpO1xuICAgIHJldHVybiB0aGlzLmVzdGltYXRlVHgoe1xuICAgICAgdGFyZ2V0OiB0eC5nZXRUYXJnZXQoKSxcbiAgICAgIGRhdGE6IHR4LmVuY29kZSgpLFxuICAgICAgdmFsdWU6IGF3YWl0IHR4LmdldFZhbHVlKCksXG4gICAgICBnYXNMaW1pdDogYXdhaXQgdHguZ2V0T3ZlcnJpZGVzKCkuZ2FzTGltaXQsXG4gICAgICBtYXhGZWVQZXJHYXM6IGF3YWl0IHR4LmdldE92ZXJyaWRlcygpLm1heEZlZVBlckdhcyxcbiAgICAgIG1heFByaW9yaXR5RmVlUGVyR2FzOiBhd2FpdCB0eC5nZXRPdmVycmlkZXMoKS5tYXhQcmlvcml0eUZlZVBlckdhcyxcbiAgICAgIG5vbmNlOiBhd2FpdCB0eC5nZXRPdmVycmlkZXMoKS5ub25jZVxuICAgIH0sIHtcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICBiYXRjaERhdGFcbiAgICB9KTtcbiAgfVxuICBhc3luYyBlc3RpbWF0ZUJhdGNoUmF3KHRyYW5zYWN0aW9ucywgb3B0aW9ucykge1xuICAgIGlmICghdGhpcy5hY2NvdW50QXBpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQZXJzb25hbCB3YWxsZXQgbm90IGNvbm5lY3RlZFwiKTtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgdHgsXG4gICAgICBiYXRjaERhdGFcbiAgICB9ID0gYXdhaXQgdGhpcy5wcmVwYXJlQmF0Y2hSYXcodHJhbnNhY3Rpb25zKTtcbiAgICByZXR1cm4gdGhpcy5lc3RpbWF0ZVR4KHtcbiAgICAgIHRhcmdldDogdHguZ2V0VGFyZ2V0KCksXG4gICAgICBkYXRhOiB0eC5lbmNvZGUoKSxcbiAgICAgIHZhbHVlOiBhd2FpdCB0eC5nZXRWYWx1ZSgpLFxuICAgICAgZ2FzTGltaXQ6IGF3YWl0IHR4LmdldE92ZXJyaWRlcygpLmdhc0xpbWl0LFxuICAgICAgbWF4RmVlUGVyR2FzOiBhd2FpdCB0eC5nZXRPdmVycmlkZXMoKS5tYXhGZWVQZXJHYXMsXG4gICAgICBtYXhQcmlvcml0eUZlZVBlckdhczogYXdhaXQgdHguZ2V0T3ZlcnJpZGVzKCkubWF4UHJpb3JpdHlGZWVQZXJHYXMsXG4gICAgICBub25jZTogYXdhaXQgdHguZ2V0T3ZlcnJpZGVzKCkubm9uY2VcbiAgICB9LCB7XG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgYmF0Y2hEYXRhXG4gICAgfSk7XG4gIH1cblxuICAvLy8vIERFUExPWU1FTlRcblxuICAvKipcbiAgICogTWFudWFsbHkgZGVwbG95IHRoZSBzbWFydCB3YWxsZXQgY29udHJhY3QuIElmIGFscmVhZHkgZGVwbG95ZWQgdGhpcyB3aWxsIHRocm93IGFuIGVycm9yLlxuICAgKiBOb3RlIHRoYXQgdGhpcyBpcyBub3QgbmVjZXNzYXJ5IGFzIHRoZSBzbWFydCB3YWxsZXQgd2lsbCBiZSBkZXBsb3llZCBhdXRvbWF0aWNhbGx5IG9uIHRoZSBmaXJzdCB0cmFuc2FjdGlvbiB0aGUgdXNlciBtYWtlcy5cbiAgICogQHJldHVybnMgVGhlIHRyYW5zYWN0aW9uIHJlY2VpcHRcbiAgICovXG4gIGFzeW5jIGRlcGxveShvcHRpb25zKSB7XG4gICAgaWYgKCF0aGlzLmFjY291bnRBcGkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlBlcnNvbmFsIHdhbGxldCBub3QgY29ubmVjdGVkXCIpO1xuICAgIH1cbiAgICBjb25zdCBzaWduZXIgPSBhd2FpdCB0aGlzLmdldFNpZ25lcigpO1xuICAgIGNvbnN0IHR4ID0gYXdhaXQgc2lnbmVyLnNlbmRUcmFuc2FjdGlvbih7XG4gICAgICB0bzogYXdhaXQgc2lnbmVyLmdldEFkZHJlc3MoKSxcbiAgICAgIGRhdGE6IFwiMHhcIlxuICAgIH0sIHtcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICBiYXRjaERhdGE6IHtcbiAgICAgICAgdGFyZ2V0czogW10sXG4gICAgICAgIGRhdGE6IFtdLFxuICAgICAgICB2YWx1ZXM6IFtdXG4gICAgICB9IC8vIGJhdGNoZWQgdHggZmxhZyB0byBhdm9pZCBoaXR0aW5nIHRoZSBSb3V0ZXIgZmFsbGJhY2sgbWV0aG9kXG4gICAgfSk7XG4gICAgY29uc3QgcmVjZWlwdCA9IGF3YWl0IHR4LndhaXQoKTtcbiAgICByZXR1cm4ge1xuICAgICAgcmVjZWlwdFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgdGhlIHNtYXJ0IHdhbGxldCBjb250cmFjdCBpcyBkZXBsb3llZFxuICAgKiBAcmV0dXJucyB0cnVlIGlmIHRoZSBzbWFydCB3YWxsZXQgY29udHJhY3QgaXMgZGVwbG95ZWRcbiAgICovXG4gIGFzeW5jIGlzRGVwbG95ZWQoKSB7XG4gICAgaWYgKCF0aGlzLmFjY291bnRBcGkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlBlcnNvbmFsIHdhbGxldCBub3QgY29ubmVjdGVkXCIpO1xuICAgIH1cbiAgICByZXR1cm4gYXdhaXQgdGhpcy5hY2NvdW50QXBpLmlzQWNvdW50RGVwbG95ZWQoKTtcbiAgfVxuICBhc3luYyBkZXBsb3lJZk5lZWRlZChvcHRpb25zKSB7XG4gICAgY29uc3QgaXNEZXBsb3llZCA9IGF3YWl0IHRoaXMuaXNEZXBsb3llZCgpO1xuICAgIGlmICghaXNEZXBsb3llZCkge1xuICAgICAgYXdhaXQgdGhpcy5kZXBsb3kob3B0aW9ucyk7XG4gICAgfVxuICB9XG5cbiAgLy8vLyBQRVJNSVNTSU9OU1xuXG4gIGFzeW5jIGdyYW50UGVybWlzc2lvbnModGFyZ2V0LCBwZXJtaXNzaW9ucykge1xuICAgIGNvbnN0IGFjY291bnRDb250cmFjdCA9IGF3YWl0IHRoaXMuZ2V0QWNjb3VudENvbnRyYWN0KCk7XG4gICAgcmV0dXJuIGFjY291bnRDb250cmFjdC5hY2NvdW50LmdyYW50UGVybWlzc2lvbnModGFyZ2V0LCBwZXJtaXNzaW9ucyk7XG4gIH1cbiAgYXN5bmMgcmV2b2tlUGVybWlzc2lvbnModGFyZ2V0KSB7XG4gICAgY29uc3QgYWNjb3VudENvbnRyYWN0ID0gYXdhaXQgdGhpcy5nZXRBY2NvdW50Q29udHJhY3QoKTtcbiAgICByZXR1cm4gYWNjb3VudENvbnRyYWN0LmFjY291bnQucmV2b2tlQWNjZXNzKHRhcmdldCk7XG4gIH1cbiAgYXN5bmMgYWRkQWRtaW4odGFyZ2V0KSB7XG4gICAgY29uc3QgYWNjb3VudENvbnRyYWN0ID0gYXdhaXQgdGhpcy5nZXRBY2NvdW50Q29udHJhY3QoKTtcbiAgICByZXR1cm4gYWNjb3VudENvbnRyYWN0LmFjY291bnQuZ3JhbnRBZG1pblBlcm1pc3Npb25zKHRhcmdldCk7XG4gIH1cbiAgYXN5bmMgcmVtb3ZlQWRtaW4odGFyZ2V0KSB7XG4gICAgY29uc3QgYWNjb3VudENvbnRyYWN0ID0gYXdhaXQgdGhpcy5nZXRBY2NvdW50Q29udHJhY3QoKTtcbiAgICByZXR1cm4gYWNjb3VudENvbnRyYWN0LmFjY291bnQucmV2b2tlQWRtaW5QZXJtaXNzaW9ucyh0YXJnZXQpO1xuICB9XG4gIGFzeW5jIGdldEFsbEFjdGl2ZVNpZ25lcnMoKSB7XG4gICAgY29uc3QgaXNEZXBsb3llZCA9IGF3YWl0IHRoaXMuaXNEZXBsb3llZCgpO1xuICAgIGlmIChpc0RlcGxveWVkKSB7XG4gICAgICBjb25zdCBhY2NvdW50Q29udHJhY3QgPSBhd2FpdCB0aGlzLmdldEFjY291bnRDb250cmFjdCgpO1xuICAgICAgcmV0dXJuIGFjY291bnRDb250cmFjdC5hY2NvdW50LmdldEFsbEFkbWluc0FuZFNpZ25lcnMoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgcGVyc29uYWxXYWxsZXQgPSBhd2FpdCB0aGlzLnBlcnNvbmFsV2FsbGV0Py5nZXRTaWduZXIoKTtcbiAgICAgIGlmICghcGVyc29uYWxXYWxsZXQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUGVyc29uYWwgd2FsbGV0IG5vdCBjb25uZWN0ZWRcIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gW3tcbiAgICAgICAgaXNBZG1pbjogdHJ1ZSxcbiAgICAgICAgc2lnbmVyOiBhd2FpdCBwZXJzb25hbFdhbGxldC5nZXRBZGRyZXNzKCksXG4gICAgICAgIHBlcm1pc3Npb25zOiB7XG4gICAgICAgICAgc3RhcnREYXRlOiBuZXcgRGF0ZSgwKSxcbiAgICAgICAgICBleHBpcmF0aW9uRGF0ZTogbmV3IERhdGUoMCksXG4gICAgICAgICAgbmF0aXZlVG9rZW5MaW1pdFBlclRyYW5zYWN0aW9uOiBCaWdOdW1iZXIuZnJvbSgwKSxcbiAgICAgICAgICBhcHByb3ZlZENhbGxUYXJnZXRzOiBbXVxuICAgICAgICB9XG4gICAgICB9XTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSB1bmRlcmx5aW5nIGFjY291bnQgY29udHJhY3Qgb2YgdGhlIHNtYXJ0IHdhbGxldC5cbiAgICogQHJldHVybnMgVGhlIGFjY291bnQgY29udHJhY3Qgb2YgdGhlIHNtYXJ0IHdhbGxldC5cbiAgICovXG4gIGFzeW5jIGdldEFjY291bnRDb250cmFjdCgpIHtcbiAgICAvLyBnZXR0aW5nIGEgbmV3IGluc3RhbmNlIGV2ZXJ5dGltZVxuICAgIC8vIHRvIGF2b2lkIGNhY2hpbmcgaXNzdWVzIHByZS9wb3N0IGRlcGxveW1lbnRcbiAgICBjb25zdCBzZGsgPSBUaGlyZHdlYlNESy5mcm9tU2lnbmVyKGF3YWl0IHRoaXMuZ2V0U2lnbmVyKCksIHRoaXMuY29uZmlnLmNoYWluLCB7XG4gICAgICBjbGllbnRJZDogdGhpcy5jb25maWcuY2xpZW50SWQsXG4gICAgICBzZWNyZXRLZXk6IHRoaXMuY29uZmlnLnNlY3JldEtleVxuICAgIH0pO1xuICAgIGlmICh0aGlzLmNvbmZpZy5hY2NvdW50SW5mbz8uYWJpKSB7XG4gICAgICByZXR1cm4gc2RrLmdldENvbnRyYWN0KGF3YWl0IHRoaXMuZ2V0QWRkcmVzcygpLCB0aGlzLmNvbmZpZy5hY2NvdW50SW5mby5hYmkpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gc2RrLmdldENvbnRyYWN0KGF3YWl0IHRoaXMuZ2V0QWRkcmVzcygpLCBBQ0NPVU5UX0NPUkVfQUJJKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSB1bmRlcmx5aW5nIGFjY291bnQgZmFjdG9yeSBjb250cmFjdCBvZiB0aGUgc21hcnQgd2FsbGV0LlxuICAgKiBAcmV0dXJucyBUaGUgYWNjb3VudCBmYWN0b3J5IGNvbnRyYWN0LlxuICAgKi9cbiAgYXN5bmMgZ2V0RmFjdG9yeUNvbnRyYWN0KCkge1xuICAgIGlmICghdGhpcy5jb25maWcuZmFjdG9yeUFkZHJlc3MpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkZhY3RvcnkgYWRkcmVzcyBub3Qgc2V0IVwiKTtcbiAgICB9XG4gICAgY29uc3Qgc2RrID0gVGhpcmR3ZWJTREsuZnJvbVNpZ25lcihhd2FpdCB0aGlzLmdldFNpZ25lcigpLCB0aGlzLmNvbmZpZy5jaGFpbiwge1xuICAgICAgY2xpZW50SWQ6IHRoaXMuY29uZmlnLmNsaWVudElkLFxuICAgICAgc2VjcmV0S2V5OiB0aGlzLmNvbmZpZy5zZWNyZXRLZXlcbiAgICB9KTtcbiAgICBpZiAodGhpcy5jb25maWcuZmFjdG9yeUluZm8/LmFiaSkge1xuICAgICAgcmV0dXJuIHNkay5nZXRDb250cmFjdCh0aGlzLmNvbmZpZy5mYWN0b3J5QWRkcmVzcywgdGhpcy5jb25maWcuZmFjdG9yeUluZm8uYWJpKTtcbiAgICB9XG4gICAgcmV0dXJuIHNkay5nZXRDb250cmFjdCh0aGlzLmNvbmZpZy5mYWN0b3J5QWRkcmVzcyk7XG4gIH1cbiAgZGVmYXVsdEZhY3RvcnlJbmZvKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjcmVhdGVBY2NvdW50OiBhc3luYyAoZmFjdG9yeSwgb3duZXIpID0+IHtcbiAgICAgICAgcmV0dXJuIGZhY3RvcnkucHJlcGFyZShcImNyZWF0ZUFjY291bnRcIiwgW293bmVyLCBldGhlcnMudXRpbHMudG9VdGY4Qnl0ZXMoXCJcIildKTtcbiAgICAgIH0sXG4gICAgICBnZXRBY2NvdW50QWRkcmVzczogYXN5bmMgKGZhY3RvcnksIG93bmVyKSA9PiB7XG4gICAgICAgIHJldHVybiBhd2FpdCBmYWN0b3J5LmNhbGwoXCJnZXRBZGRyZXNzXCIsIFtvd25lciwgZXRoZXJzLnV0aWxzLnRvVXRmOEJ5dGVzKFwiXCIpXSk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBkZWZhdWx0QWNjb3VudEluZm8oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGV4ZWN1dGU6IGFzeW5jIChhY2NvdW50LCB0YXJnZXQsIHZhbHVlLCBkYXRhKSA9PiB7XG4gICAgICAgIHJldHVybiBhY2NvdW50LnByZXBhcmUoXCJleGVjdXRlXCIsIFt0YXJnZXQsIHZhbHVlLCBkYXRhXSk7XG4gICAgICB9LFxuICAgICAgZ2V0Tm9uY2U6IGFzeW5jIGFjY291bnQgPT4ge1xuICAgICAgICByZXR1cm4gYWNjb3VudC5jYWxsKFwiZ2V0Tm9uY2VcIiwgW10pO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICAvLy8gUFJJVkFURSBNRVRIT0RTXG5cbiAgYXN5bmMgZXN0aW1hdGVUeCh0eCwgb3B0aW9ucykge1xuICAgIGlmICghdGhpcy5hY2NvdW50QXBpIHx8ICF0aGlzLmFhUHJvdmlkZXIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlBlcnNvbmFsIHdhbGxldCBub3QgY29ubmVjdGVkXCIpO1xuICAgIH1cbiAgICBsZXQgZGVwbG95R2FzTGltaXQgPSBCaWdOdW1iZXIuZnJvbSgwKTtcbiAgICBjb25zdCBbcHJvdmlkZXIsIGlzRGVwbG95ZWRdID0gYXdhaXQgUHJvbWlzZS5hbGwoW3RoaXMuZ2V0UHJvdmlkZXIoKSwgdGhpcy5pc0RlcGxveWVkKCldKTtcbiAgICBpZiAoIWlzRGVwbG95ZWQpIHtcbiAgICAgIGRlcGxveUdhc0xpbWl0ID0gYXdhaXQgdGhpcy5lc3RpbWF0ZURlcGxveW1lbnRHYXNMaW1pdCgpO1xuICAgIH1cbiAgICBjb25zdCBbdXNlck9wLCBnYXNQcmljZV0gPSBhd2FpdCBQcm9taXNlLmFsbChbdGhpcy5hY2NvdW50QXBpLmNyZWF0ZVVuc2lnbmVkVXNlck9wKHRoaXMuYWFQcm92aWRlci5odHRwUnBjQ2xpZW50LCB0eCwgb3B0aW9ucyksIGdldEdhc1ByaWNlKHByb3ZpZGVyKV0pO1xuICAgIGNvbnN0IHJlc29sdmVkID0gYXdhaXQgdXRpbHMucmVzb2x2ZVByb3BlcnRpZXModXNlck9wKTtcbiAgICBjb25zdCB0cmFuc2FjdGlvbkdhc0xpbWl0ID0gQmlnTnVtYmVyLmZyb20ocmVzb2x2ZWQuY2FsbEdhc0xpbWl0KTtcbiAgICBjb25zdCB0cmFuc2FjdGlvbkNvc3QgPSB0cmFuc2FjdGlvbkdhc0xpbWl0Lm11bChnYXNQcmljZSk7XG4gICAgY29uc3QgZGVwbG95Q29zdCA9IGRlcGxveUdhc0xpbWl0Lm11bChnYXNQcmljZSk7XG4gICAgY29uc3QgdG90YWxDb3N0ID0gZGVwbG95Q29zdC5hZGQodHJhbnNhY3Rpb25Db3N0KTtcbiAgICByZXR1cm4ge1xuICAgICAgZXRoZXI6IHV0aWxzLmZvcm1hdEV0aGVyKHRvdGFsQ29zdCksXG4gICAgICB3ZWk6IHRvdGFsQ29zdCxcbiAgICAgIGRldGFpbHM6IHtcbiAgICAgICAgZGVwbG95R2FzTGltaXQsXG4gICAgICAgIHRyYW5zYWN0aW9uR2FzTGltaXQsXG4gICAgICAgIGdhc1ByaWNlLFxuICAgICAgICB0cmFuc2FjdGlvbkNvc3QsXG4gICAgICAgIGRlcGxveUNvc3QsXG4gICAgICAgIHRvdGFsQ29zdFxuICAgICAgfVxuICAgIH07XG4gIH1cbiAgYXN5bmMgZXN0aW1hdGVEZXBsb3ltZW50R2FzTGltaXQoKSB7XG4gICAgaWYgKCF0aGlzLmFjY291bnRBcGkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlBlcnNvbmFsIHdhbGxldCBub3QgY29ubmVjdGVkXCIpO1xuICAgIH1cbiAgICBjb25zdCBpbml0Q29kZSA9IGF3YWl0IHRoaXMuYWNjb3VudEFwaS5nZXRJbml0Q29kZSgpO1xuICAgIGNvbnN0IFtpbml0R2FzLCB2ZXJpZmljYXRpb25HYXNMaW1pdF0gPSBhd2FpdCBQcm9taXNlLmFsbChbdGhpcy5hY2NvdW50QXBpLmVzdGltYXRlQ3JlYXRpb25HYXMoaW5pdENvZGUpLCB0aGlzLmFjY291bnRBcGkuZ2V0VmVyaWZpY2F0aW9uR2FzTGltaXQoKV0pO1xuICAgIHJldHVybiBCaWdOdW1iZXIuZnJvbSh2ZXJpZmljYXRpb25HYXNMaW1pdCkuYWRkKGluaXRHYXMpO1xuICB9XG4gIGFzeW5jIHByZXBhcmVCYXRjaFJhdyh0cmFuc2FjdGlvbnMpIHtcbiAgICBpZiAoIXRoaXMuYWNjb3VudEFwaSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUGVyc29uYWwgd2FsbGV0IG5vdCBjb25uZWN0ZWRcIik7XG4gICAgfVxuICAgIGNvbnN0IHJlc29sdmVkVHhzID0gYXdhaXQgUHJvbWlzZS5hbGwodHJhbnNhY3Rpb25zLm1hcCh0cmFuc2FjdGlvbiA9PiBldGhlcnMudXRpbHMucmVzb2x2ZVByb3BlcnRpZXModHJhbnNhY3Rpb24pKSk7XG4gICAgY29uc3QgdGFyZ2V0cyA9IHJlc29sdmVkVHhzLm1hcCh0eCA9PiB0eC50byB8fCBjb25zdGFudHMuQWRkcmVzc1plcm8pO1xuICAgIGNvbnN0IGRhdGEgPSByZXNvbHZlZFR4cy5tYXAodHggPT4gdHguZGF0YSB8fCBcIjB4XCIpO1xuICAgIGNvbnN0IHZhbHVlcyA9IHJlc29sdmVkVHhzLm1hcCh0eCA9PiB0eC52YWx1ZSB8fCBCaWdOdW1iZXIuZnJvbSgwKSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR4OiBhd2FpdCB0aGlzLmFjY291bnRBcGkucHJlcGFyZUV4ZWN1dGVCYXRjaCh0YXJnZXRzLCB2YWx1ZXMsIGRhdGEpLFxuICAgICAgYmF0Y2hEYXRhOiB7XG4gICAgICAgIHRhcmdldHMsXG4gICAgICAgIGRhdGEsXG4gICAgICAgIHZhbHVlc1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgYXN5bmMgcHJlcGFyZUJhdGNoVHgodHJhbnNhY3Rpb25zKSB7XG4gICAgaWYgKCF0aGlzLmFjY291bnRBcGkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlBlcnNvbmFsIHdhbGxldCBub3QgY29ubmVjdGVkXCIpO1xuICAgIH1cbiAgICBjb25zdCB0YXJnZXRzID0gdHJhbnNhY3Rpb25zLm1hcCh0eCA9PiB0eC5nZXRUYXJnZXQoKSk7XG4gICAgY29uc3QgZGF0YSA9IHRyYW5zYWN0aW9ucy5tYXAodHggPT4gdHguZW5jb2RlKCkpO1xuICAgIGNvbnN0IHZhbHVlcyA9IGF3YWl0IFByb21pc2UuYWxsKHRyYW5zYWN0aW9ucy5tYXAodHggPT4gdHguZ2V0VmFsdWUoKSkpO1xuICAgIHJldHVybiB7XG4gICAgICB0eDogYXdhaXQgdGhpcy5hY2NvdW50QXBpLnByZXBhcmVFeGVjdXRlQmF0Y2godGFyZ2V0cywgdmFsdWVzLCBkYXRhKSxcbiAgICAgIGJhdGNoRGF0YToge1xuICAgICAgICB0YXJnZXRzLFxuICAgICAgICBkYXRhLFxuICAgICAgICB2YWx1ZXNcbiAgICAgIH1cbiAgICB9O1xuICB9XG59XG5cbmV4cG9ydCB7IFNtYXJ0V2FsbGV0Q29ubmVjdG9yIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@thirdweb-dev/wallets/evm/connectors/smart-wallet/dist/thirdweb-dev-wallets-evm-connectors-smart-wallet.browser.esm.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@thirdweb-dev/wallets/evm/connectors/token-bound-smart-wallet/dist/thirdweb-dev-wallets-evm-connectors-token-bound-smart-wallet.browser.esm.js":
/*!*********************************************************************************************************************************************************************!*\
  !*** ./node_modules/@thirdweb-dev/wallets/evm/connectors/token-bound-smart-wallet/dist/thirdweb-dev-wallets-evm-connectors-token-bound-smart-wallet.browser.esm.js ***!
  \*********************************************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TokenBoundSmartWalletConnector: function() { return /* binding */ TokenBoundSmartWalletConnector; }\n/* harmony export */ });\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/./node_modules/@ethersproject/strings/lib.esm/utf8.js\");\n/* harmony import */ var _smart_wallet_dist_thirdweb_dev_wallets_evm_connectors_smart_wallet_browser_esm_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../smart-wallet/dist/thirdweb-dev-wallets-evm-connectors-smart-wallet.browser.esm.js */ \"(app-pages-browser)/./node_modules/@thirdweb-dev/wallets/evm/connectors/smart-wallet/dist/thirdweb-dev-wallets-evm-connectors-smart-wallet.browser.esm.js\");\n/* harmony import */ var _dist_utils_f58e7acc_browser_esm_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../../dist/utils-f58e7acc.browser.esm.js */ \"(app-pages-browser)/./node_modules/@thirdweb-dev/wallets/dist/utils-f58e7acc.browser.esm.js\");\n/* harmony import */ var eventemitter3__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! eventemitter3 */ \"(app-pages-browser)/./node_modules/eventemitter3/index.mjs\");\n/* harmony import */ var _account_abstraction_contracts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @account-abstraction/contracts */ \"(app-pages-browser)/./node_modules/@account-abstraction/contracts/dist/index.js\");\n/* harmony import */ var _account_abstraction_contracts__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_account_abstraction_contracts__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _wallets_abstract_dist_thirdweb_dev_wallets_evm_wallets_abstract_browser_esm_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../wallets/abstract/dist/thirdweb-dev-wallets-evm-wallets-abstract.browser.esm.js */ \"(app-pages-browser)/./node_modules/@thirdweb-dev/wallets/evm/wallets/abstract/dist/thirdweb-dev-wallets-evm-wallets-abstract.browser.esm.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nclass TokenBoundSmartWalletConnector extends _smart_wallet_dist_thirdweb_dev_wallets_evm_connectors_smart_wallet_browser_esm_js__WEBPACK_IMPORTED_MODULE_0__.SmartWalletConnector {\n  constructor(input) {\n    super({\n      ...input,\n      factoryAddress: input.registryAddress || _dist_utils_f58e7acc_browser_esm_js__WEBPACK_IMPORTED_MODULE_4__.E\n    });\n    this.tbaConfig = input;\n    // TODO default account implementation address\n  }\n  defaultFactoryInfo() {\n    return {\n      createAccount: async factory => {\n        return factory.prepare(\"createAccount\", [this.tbaConfig.accountImplementation, this.chainId, this.tbaConfig.tokenContract, this.tbaConfig.tokenId, this.tbaConfig.salt, ethers__WEBPACK_IMPORTED_MODULE_5__.toUtf8Bytes(\"\")]);\n      },\n      getAccountAddress: async factory => {\n        return await factory.call(\"account\", [this.tbaConfig.accountImplementation, this.chainId, this.tbaConfig.tokenContract, this.tbaConfig.tokenId, this.tbaConfig.salt]);\n      }\n    };\n  }\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AdGhpcmR3ZWItZGV2L3dhbGxldHMvZXZtL2Nvbm5lY3RvcnMvdG9rZW4tYm91bmQtc21hcnQtd2FsbGV0L2Rpc3QvdGhpcmR3ZWItZGV2LXdhbGxldHMtZXZtLWNvbm5lY3RvcnMtdG9rZW4tYm91bmQtc21hcnQtd2FsbGV0LmJyb3dzZXIuZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQWdDO0FBQytGO0FBQ3hDO0FBQzNCO0FBQ3JDO0FBQzJDO0FBQ1o7QUFDeEI7QUFDNEI7QUFDbEI7QUFDeUI7QUFDdEM7QUFDc0U7O0FBRWpHLDZDQUE2QyxvSUFBb0I7QUFDakU7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLGtFQUFnQjtBQUMvRCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0xBQWdMLCtDQUF3QjtBQUN4TSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUUwQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHRoaXJkd2ViLWRldi93YWxsZXRzL2V2bS9jb25uZWN0b3JzL3Rva2VuLWJvdW5kLXNtYXJ0LXdhbGxldC9kaXN0L3RoaXJkd2ViLWRldi13YWxsZXRzLWV2bS1jb25uZWN0b3JzLXRva2VuLWJvdW5kLXNtYXJ0LXdhbGxldC5icm93c2VyLmVzbS5qcz9kNGFlIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGV0aGVycyB9IGZyb20gJ2V0aGVycyc7XG5pbXBvcnQgeyBTbWFydFdhbGxldENvbm5lY3RvciB9IGZyb20gJy4uLy4uL3NtYXJ0LXdhbGxldC9kaXN0L3RoaXJkd2ViLWRldi13YWxsZXRzLWV2bS1jb25uZWN0b3JzLXNtYXJ0LXdhbGxldC5icm93c2VyLmVzbS5qcyc7XG5pbXBvcnQgeyBFIGFzIEVSQzY1NTFfUkVHSVNUUlkgfSBmcm9tICcuLi8uLi8uLi8uLi9kaXN0L3V0aWxzLWY1OGU3YWNjLmJyb3dzZXIuZXNtLmpzJztcbmltcG9ydCAnLi4vLi4vLi4vLi4vZGlzdC9jb25uZWN0b3ItMDU2ODlkNjguYnJvd3Nlci5lc20uanMnO1xuaW1wb3J0ICdldmVudGVtaXR0ZXIzJztcbmltcG9ydCAnLi4vLi4vLi4vLi4vZGlzdC9odHRwLXJwYy1jbGllbnQtMGEwNzllODAuYnJvd3Nlci5lc20uanMnO1xuaW1wb3J0ICcuLi8uLi8uLi8uLi9kaXN0L3VybC1hNDUyMTliZC5icm93c2VyLmVzbS5qcyc7XG5pbXBvcnQgJ0B0aGlyZHdlYi1kZXYvY2hhaW5zJztcbmltcG9ydCAnLi4vLi4vLi4vLi4vZGlzdC9oZWFkZXJzLTczM2E4MTk5LmJyb3dzZXIuZXNtLmpzJztcbmltcG9ydCAnQGFjY291bnQtYWJzdHJhY3Rpb24vY29udHJhY3RzJztcbmltcG9ydCAnLi4vLi4vLi4vLi4vZGlzdC9kZWZpbmVQcm9wZXJ0eS0zNTBmYzUwOC5icm93c2VyLmVzbS5qcyc7XG5pbXBvcnQgJ0B0aGlyZHdlYi1kZXYvc2RrJztcbmltcG9ydCAnLi4vLi4vLi4vd2FsbGV0cy9hYnN0cmFjdC9kaXN0L3RoaXJkd2ViLWRldi13YWxsZXRzLWV2bS13YWxsZXRzLWFic3RyYWN0LmJyb3dzZXIuZXNtLmpzJztcblxuY2xhc3MgVG9rZW5Cb3VuZFNtYXJ0V2FsbGV0Q29ubmVjdG9yIGV4dGVuZHMgU21hcnRXYWxsZXRDb25uZWN0b3Ige1xuICBjb25zdHJ1Y3RvcihpbnB1dCkge1xuICAgIHN1cGVyKHtcbiAgICAgIC4uLmlucHV0LFxuICAgICAgZmFjdG9yeUFkZHJlc3M6IGlucHV0LnJlZ2lzdHJ5QWRkcmVzcyB8fCBFUkM2NTUxX1JFR0lTVFJZXG4gICAgfSk7XG4gICAgdGhpcy50YmFDb25maWcgPSBpbnB1dDtcbiAgICAvLyBUT0RPIGRlZmF1bHQgYWNjb3VudCBpbXBsZW1lbnRhdGlvbiBhZGRyZXNzXG4gIH1cbiAgZGVmYXVsdEZhY3RvcnlJbmZvKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjcmVhdGVBY2NvdW50OiBhc3luYyBmYWN0b3J5ID0+IHtcbiAgICAgICAgcmV0dXJuIGZhY3RvcnkucHJlcGFyZShcImNyZWF0ZUFjY291bnRcIiwgW3RoaXMudGJhQ29uZmlnLmFjY291bnRJbXBsZW1lbnRhdGlvbiwgdGhpcy5jaGFpbklkLCB0aGlzLnRiYUNvbmZpZy50b2tlbkNvbnRyYWN0LCB0aGlzLnRiYUNvbmZpZy50b2tlbklkLCB0aGlzLnRiYUNvbmZpZy5zYWx0LCBldGhlcnMudXRpbHMudG9VdGY4Qnl0ZXMoXCJcIildKTtcbiAgICAgIH0sXG4gICAgICBnZXRBY2NvdW50QWRkcmVzczogYXN5bmMgZmFjdG9yeSA9PiB7XG4gICAgICAgIHJldHVybiBhd2FpdCBmYWN0b3J5LmNhbGwoXCJhY2NvdW50XCIsIFt0aGlzLnRiYUNvbmZpZy5hY2NvdW50SW1wbGVtZW50YXRpb24sIHRoaXMuY2hhaW5JZCwgdGhpcy50YmFDb25maWcudG9rZW5Db250cmFjdCwgdGhpcy50YmFDb25maWcudG9rZW5JZCwgdGhpcy50YmFDb25maWcuc2FsdF0pO1xuICAgICAgfVxuICAgIH07XG4gIH1cbn1cblxuZXhwb3J0IHsgVG9rZW5Cb3VuZFNtYXJ0V2FsbGV0Q29ubmVjdG9yIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@thirdweb-dev/wallets/evm/connectors/token-bound-smart-wallet/dist/thirdweb-dev-wallets-evm-connectors-token-bound-smart-wallet.browser.esm.js\n"));

/***/ })

}]);