"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@blocto";
exports.ids = ["vendor-chunks/@blocto"];
exports.modules = {

/***/ "(ssr)/./node_modules/@blocto/sdk/dist/blocto-sdk.module.js":
/*!************************************************************!*\
  !*** ./node_modules/@blocto/sdk/dist/blocto-sdk.module.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ BloctoSDK)\n/* harmony export */ });\n/* Version: 0.10.2 - May 3, 2024 04:32:29 */\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise, SuppressedError, Symbol */\r\n\r\n\r\nfunction __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nfunction __classPrivateFieldGet(receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n}\r\n\r\ntypeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\r\n    var e = new Error(message);\r\n    return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\r\n};\n\n// instead invariant from package, since all error will throw on production\nfunction invariant(condition, format) {\n    if (!condition) {\n        throw new Error(format);\n    }\n}\n\nvar KEY_SESSION;\n(function (KEY_SESSION) {\n    KEY_SESSION[\"prod\"] = \"BLOCTO_SDK\";\n    KEY_SESSION[\"dev\"] = \"BLOCTO_SDK_DEV\";\n    KEY_SESSION[\"staging\"] = \"BLOCTO_SDK_STAGING\";\n})(KEY_SESSION || (KEY_SESSION = {}));\nvar CHAIN;\n(function (CHAIN) {\n    CHAIN[\"ETHEREUM\"] = \"ethereum\";\n    CHAIN[\"APTOS\"] = \"aptos\";\n})(CHAIN || (CHAIN = {}));\n/* eth series constants begin */\nconst ETH_RPC_LIST = {\n    // This is the list of public RPC endpoints that we known to be working\n    // Used to help developers did not set up their own RPC endpoints\n    // BSC mainnet\n    56: 'https://bsc-dataseed1.binance.org',\n    // BSC testnet\n    97: 'https://data-seed-prebsc-1-s1.binance.org:8545',\n    // Polygon Mainnet\n    137: 'https://rpc-mainnet.maticvigil.com/',\n    // Polygon Amoy Testnet\n    80002: 'https://rpc-amoy.polygon.technology/',\n    // Avalanche Mainnet\n    43114: 'https://api.avax.network/ext/bc/C/rpc',\n    // Avalanche Fuji Testnet\n    43113: 'https://api.avax-test.network/ext/bc/C/rpc',\n    // Arbitrum Mainnet\n    42161: 'https://arb1.arbitrum.io/rpc',\n    // Arbitrum Sepolia Testnet\n    421614: 'https://arbitrum-sepolia.blockpi.network/v1/rpc/public',\n    // Optimism Mainnet\n    10: 'https://mainnet.optimism.io',\n    // Optimism Sepolia Testnet\n    11155420: 'https://sepolia.optimism.io',\n    // Base Mainnet\n    8453: 'https://mainnet.base.org',\n    // Base Sepolia Testnet\n    84532: 'https://sepolia.base.org',\n    // Zora\n    7777777: 'https://rpc.zora.energy',\n    // Zora Sepolia Testnet\n    999999999: 'https://sepolia.rpc.zora.energy',\n    // Scroll\n    534352: 'https://rpc.scroll.io',\n    // Scroll Sepolia Testnet\n    534351: 'https://sepolia-rpc.scroll.io',\n    // Linea\n    59144: 'https://rpc.linea.build',\n    // zKatana Sepolia Testnet\n    1261120: 'https://rpc.startale.com/zkatana',\n    // Blast\n    81457: 'https://rpc.blast.io',\n    // Blast Sepolia Testnet\n    168587773: 'https://sepolia.blast.io'\n};\nconst ETH_ENV_WALLET_SERVER_MAPPING = {\n    prod: 'https://wallet-v2.blocto.app',\n    staging: 'https://wallet-v2-staging.blocto.app',\n    dev: 'https://wallet-v2-dev.blocto.app',\n};\nconst ETH_SESSION_KEY_MAPPING = {\n    prod: KEY_SESSION.prod,\n    staging: KEY_SESSION.staging,\n    dev: KEY_SESSION.dev,\n};\n/* eth series constants end */\n/* aptos constants begin */\nconst APT_SESSION_KEY_MAPPING = {\n    1: KEY_SESSION.prod,\n    2: KEY_SESSION.dev,\n    3: KEY_SESSION.dev,\n    4: KEY_SESSION.dev,\n    5: KEY_SESSION.staging,\n};\nconst APT_CHAIN_ID_SERVER_MAPPING = {\n    // MAINNET\n    1: 'https://wallet-v2.blocto.app',\n    // TESTNET\n    2: 'https://wallet-v2-dev.blocto.app',\n    // DEVNET\n    3: 'https://wallet-v2-dev.blocto.app',\n    // TESTING\n    4: 'https://wallet-v2-dev.blocto.app',\n    // PREMAINNET\n    5: 'https://wallet-v2-staging.blocto.app',\n};\nvar WalletAdapterNetwork;\n(function (WalletAdapterNetwork) {\n    WalletAdapterNetwork[\"Mainnet\"] = \"mainnet\";\n    WalletAdapterNetwork[\"Testnet\"] = \"testnet\";\n    WalletAdapterNetwork[\"Devnet\"] = \"devnet\";\n    WalletAdapterNetwork[\"Testing\"] = \"testing\";\n    WalletAdapterNetwork[\"Premainnet\"] = \"premainnet\";\n})(WalletAdapterNetwork || (WalletAdapterNetwork = {}));\nconst APT_CHAIN_ID_NAME_MAPPING = {\n    1: WalletAdapterNetwork.Mainnet,\n    2: WalletAdapterNetwork.Testnet,\n    3: WalletAdapterNetwork.Devnet,\n    4: WalletAdapterNetwork.Testing,\n    5: WalletAdapterNetwork.Premainnet,\n};\nconst APT_CHAIN_ID_RPC_MAPPING = {\n    1: 'https://fullnode.mainnet.aptoslabs.com/v1',\n    2: 'https://fullnode.testnet.aptoslabs.com/v1',\n    3: 'https://fullnode.devnet.aptoslabs.com/v1',\n    4: '',\n    5: 'https://premainnet.aptosdev.com/v1',\n};\n/* aptos constants end */\nconst EIP1193_EVENTS = [\n    'connect',\n    'disconnect',\n    'message',\n    'chainChanged',\n    'accountsChanged',\n];\n// Preserve login for 1 day\nconst LOGIN_PERSISTING_TIME = 86400 * 1000;\nconst DEFAULT_APP_ID = '00000000-0000-0000-0000-000000000000';\n// Will inject the version of the SDK by rollup versionInjector during build time\nconst SDK_VERSION = '0.10.2';\n\n// The root class for all providers\nclass BloctoProvider {\n    constructor() {\n        this.isBlocto = true;\n        this.isConnecting = false;\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        this.eventListeners = {};\n        // alias removeListener\n        this.off = this.removeListener;\n        // init event listeners\n        EIP1193_EVENTS.forEach((event) => {\n            this.eventListeners[event] = [];\n        });\n        this.appId = DEFAULT_APP_ID;\n    }\n    // implement by children\n    // eslint-disable-next-line\n    request(payload) {\n        return __awaiter(this, void 0, void 0, function* () { });\n    }\n    on(event, listener) {\n        if (!EIP1193_EVENTS.includes(event))\n            return;\n        this.eventListeners[event].push(listener);\n    }\n    // @todo: implement it\n    // eslint-disable-next-line\n    once() { }\n    removeListener(event, listener) {\n        const listeners = this.eventListeners[event];\n        const index = listeners.findIndex((item) => item === listener);\n        if (index !== -1) {\n            this.eventListeners[event].splice(index, 1);\n        }\n    }\n}\n\nconst IFRAME_STYLE = 'width:100vw;height:100%;position:fixed;top:0;left:0;z-index:2147483646;border:none;box-sizing:border-box;color-scheme:light;inset:0px;display:block;pointer-events:auto;';\nfunction createFrame(url) {\n    const frame = document.createElement('iframe');\n    frame.setAttribute('src', url);\n    frame.setAttribute('style', IFRAME_STYLE);\n    return frame;\n}\nfunction attachFrame(frame) {\n    document.body.appendChild(frame);\n}\nfunction detatchFrame(frame) {\n    const parentNode = frame && frame.parentNode;\n    if (parentNode && parentNode.removeChild instanceof Function) {\n        parentNode.removeChild(frame);\n    }\n}\n\nvar addSelfRemovableHandler = (eventType, handler, target = window) => {\n    function listener(e) {\n        const removeEventListener = () => target.removeEventListener(eventType, listener);\n        handler(e, removeEventListener);\n    }\n    target.addEventListener(eventType, listener);\n};\n\nconst isStorageSupported = () => {\n    if (typeof window === 'undefined') {\n        return false;\n    }\n    try {\n        window.sessionStorage.setItem('local_storage_supported', '1');\n        const result = window.sessionStorage.getItem('local_storage_supported');\n        window.sessionStorage.removeItem('local_storage_supported');\n        return result === '1';\n    }\n    catch (error) {\n        return false;\n    }\n};\nclass MemoryStorage {\n    constructor() {\n        this.storage = {};\n    }\n    getItem(key) {\n        return this[key] || null;\n    }\n    setItem(key, value) {\n        this.storage[key] = value;\n    }\n    removeItem(key) {\n        delete this.storage[key];\n    }\n}\nconst memoryStorage = typeof window !== 'undefined' ? window.memoryStorage : new MemoryStorage();\n\nconst storage = isStorageSupported() ? window.sessionStorage : memoryStorage;\nconst getItem = (key, defaultValue = null) => {\n    const value = storage.getItem(key);\n    try {\n        return (value && JSON.parse(value)) || defaultValue;\n    }\n    catch (SyntaxError) {\n        return value || defaultValue;\n    }\n};\nconst setItem = (key, value) => storage.setItem(key, typeof value === 'string' ? value : JSON.stringify(value));\nconst removeItem = (key) => {\n    setItem(key, ''); // Due to some versions of browser bug can't removeItem correctly.\n    storage.removeItem(key);\n};\n/**\n * @param {KEY_SESSION} key - key to retrieve the data\n * @returns {ProviderSession | null} ProviderSession | null\n * @description\n * Get ProviderSession from storage.\n * If the data is expired, will remove the data and return null\n */\nconst getAccountStorage = (key) => {\n    const rawAccountStorage = getItem(key, null);\n    if (!rawAccountStorage)\n        return null;\n    // compare the expiry time of the item with the current time\n    if (new Date().getTime() > rawAccountStorage.expiry ||\n        rawAccountStorage.v !== SDK_VERSION) {\n        removeItem(key);\n        return null;\n    }\n    return rawAccountStorage === null || rawAccountStorage === void 0 ? void 0 : rawAccountStorage.data;\n};\n/**\n  @param {KEY_SESSION} key - key to store the data\n  @param {ProviderSession} data - Only the part of ProviderSession that needs to be updated\n  @param {number} expiry - expiry time of the data\n*/\nconst setAccountStorage = (key, data, expiry) => {\n    var _a, _b, _c;\n    const rawAccountStorage = getItem(key);\n    const newAccountStorage = {\n        data: {\n            code: (data === null || data === void 0 ? void 0 : data.code) || ((_a = rawAccountStorage === null || rawAccountStorage === void 0 ? void 0 : rawAccountStorage.data) === null || _a === void 0 ? void 0 : _a.code),\n            accounts: Object.assign(Object.assign({}, (_b = rawAccountStorage === null || rawAccountStorage === void 0 ? void 0 : rawAccountStorage.data) === null || _b === void 0 ? void 0 : _b.accounts), data === null || data === void 0 ? void 0 : data.accounts),\n            evm: Object.assign(Object.assign({}, (_c = rawAccountStorage === null || rawAccountStorage === void 0 ? void 0 : rawAccountStorage.data) === null || _c === void 0 ? void 0 : _c.evm), data === null || data === void 0 ? void 0 : data.evm),\n        },\n        expiry: expiry ||\n            (rawAccountStorage === null || rawAccountStorage === void 0 ? void 0 : rawAccountStorage.expiry) ||\n            new Date().getTime() + LOGIN_PERSISTING_TIME,\n        v: SDK_VERSION,\n    };\n    setItem(key, newAccountStorage);\n    return;\n};\nconst getChainAddress = (key, chain) => {\n    var _a, _b, _c;\n    if (!((_a = getAccountStorage(key)) === null || _a === void 0 ? void 0 : _a.code)) {\n        removeItem(key);\n        return null;\n    }\n    return ((_c = (_b = getAccountStorage(key)) === null || _b === void 0 ? void 0 : _b.accounts) === null || _c === void 0 ? void 0 : _c[chain]) || null;\n};\nconst setChainAddress = (key, chain, account) => {\n    setAccountStorage(key, { accounts: { [chain]: account } });\n    return;\n};\nconst removeChainAddress = (key, chain) => {\n    setAccountStorage(key, { accounts: { [chain]: undefined } });\n    return;\n};\nconst getEvmAddress = (key, chain) => {\n    var _a, _b, _c;\n    if (!((_a = getAccountStorage(key)) === null || _a === void 0 ? void 0 : _a.code)) {\n        removeItem(key);\n        return null;\n    }\n    return ((_c = (_b = getAccountStorage(key)) === null || _b === void 0 ? void 0 : _b.evm) === null || _c === void 0 ? void 0 : _c[chain]) || null;\n};\nconst setEvmAddress = (key, chain, accounts) => {\n    setAccountStorage(key, { evm: { [chain]: accounts } });\n    return;\n};\nconst removeAllEvmAddress = (key) => {\n    const newAccountStorage = getItem(key);\n    if (!newAccountStorage)\n        return;\n    newAccountStorage.data.evm = {};\n    setItem(key, newAccountStorage);\n    return;\n};\n\nfunction responseSessionGuard(response, key, disconnectHandler) {\n    return __awaiter(this, void 0, void 0, function* () {\n        if (response.status === 403 || response.status === 401) {\n            if (disconnectHandler) {\n                disconnectHandler();\n            }\n            removeItem(key);\n        }\n        if (!response.ok) {\n            const data = yield response.json();\n            const e = new Error((data === null || data === void 0 ? void 0 : data.message) || 'unknown error');\n            e.error_code = data === null || data === void 0 ? void 0 : data.error_code;\n            throw e;\n        }\n        return response.json();\n    });\n}\n\nconst isEmail = (value) => /\\S+@\\S+\\.\\S+/.test(value);\n\nvar ERROR_MESSAGE;\n(function (ERROR_MESSAGE) {\n    ERROR_MESSAGE[\"INVALID_TRANSACTION\"] = \"Invalid transaction\";\n    ERROR_MESSAGE[\"INVALID_TRANSACTIONS\"] = \"Invalid transactions\";\n    ERROR_MESSAGE[\"INVALID_TRANSACTION_VALUE\"] = \"Transaction params \\\"value\\\" should be hex-encoded string\";\n})(ERROR_MESSAGE || (ERROR_MESSAGE = {}));\n\nvar global$1 = (typeof global !== \"undefined\" ? global :\n  typeof self !== \"undefined\" ? self :\n  typeof window !== \"undefined\" ? window : {});\n\nvar lookup = [];\nvar revLookup = [];\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;\nvar inited = false;\nfunction init () {\n  inited = true;\n  var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n  for (var i = 0, len = code.length; i < len; ++i) {\n    lookup[i] = code[i];\n    revLookup[code.charCodeAt(i)] = i;\n  }\n\n  revLookup['-'.charCodeAt(0)] = 62;\n  revLookup['_'.charCodeAt(0)] = 63;\n}\n\nfunction toByteArray (b64) {\n  if (!inited) {\n    init();\n  }\n  var i, j, l, tmp, placeHolders, arr;\n  var len = b64.length;\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // the number of equal signs (place holders)\n  // if there are two placeholders, than the two characters before it\n  // represent one byte\n  // if there is only one, then the three characters before it represent 2 bytes\n  // this is just a cheap hack to not do indexOf twice\n  placeHolders = b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0;\n\n  // base64 is 4/3 + up to two characters of the original data\n  arr = new Arr(len * 3 / 4 - placeHolders);\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  l = placeHolders > 0 ? len - 4 : len;\n\n  var L = 0;\n\n  for (i = 0, j = 0; i < l; i += 4, j += 3) {\n    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)];\n    arr[L++] = (tmp >> 16) & 0xFF;\n    arr[L++] = (tmp >> 8) & 0xFF;\n    arr[L++] = tmp & 0xFF;\n  }\n\n  if (placeHolders === 2) {\n    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4);\n    arr[L++] = tmp & 0xFF;\n  } else if (placeHolders === 1) {\n    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2);\n    arr[L++] = (tmp >> 8) & 0xFF;\n    arr[L++] = tmp & 0xFF;\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp;\n  var output = [];\n  for (var i = start; i < end; i += 3) {\n    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2]);\n    output.push(tripletToBase64(tmp));\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  if (!inited) {\n    init();\n  }\n  var tmp;\n  var len = uint8.length;\n  var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes\n  var output = '';\n  var parts = [];\n  var maxChunkLength = 16383; // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)));\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1];\n    output += lookup[tmp >> 2];\n    output += lookup[(tmp << 4) & 0x3F];\n    output += '==';\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + (uint8[len - 1]);\n    output += lookup[tmp >> 10];\n    output += lookup[(tmp >> 4) & 0x3F];\n    output += lookup[(tmp << 2) & 0x3F];\n    output += '=';\n  }\n\n  parts.push(output);\n\n  return parts.join('')\n}\n\nfunction read (buffer, offset, isLE, mLen, nBytes) {\n  var e, m;\n  var eLen = nBytes * 8 - mLen - 1;\n  var eMax = (1 << eLen) - 1;\n  var eBias = eMax >> 1;\n  var nBits = -7;\n  var i = isLE ? (nBytes - 1) : 0;\n  var d = isLE ? -1 : 1;\n  var s = buffer[offset + i];\n\n  i += d;\n\n  e = s & ((1 << (-nBits)) - 1);\n  s >>= (-nBits);\n  nBits += eLen;\n  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1);\n  e >>= (-nBits);\n  nBits += mLen;\n  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias;\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen);\n    e = e - eBias;\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nfunction write (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c;\n  var eLen = nBytes * 8 - mLen - 1;\n  var eMax = (1 << eLen) - 1;\n  var eBias = eMax >> 1;\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0);\n  var i = isLE ? 0 : (nBytes - 1);\n  var d = isLE ? 1 : -1;\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;\n\n  value = Math.abs(value);\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0;\n    e = eMax;\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2);\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--;\n      c *= 2;\n    }\n    if (e + eBias >= 1) {\n      value += rt / c;\n    } else {\n      value += rt * Math.pow(2, 1 - eBias);\n    }\n    if (value * c >= 2) {\n      e++;\n      c /= 2;\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0;\n      e = eMax;\n    } else if (e + eBias >= 1) {\n      m = (value * c - 1) * Math.pow(2, mLen);\n      e = e + eBias;\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);\n      e = 0;\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m;\n  eLen += mLen;\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128;\n}\n\nvar toString = {}.toString;\n\nvar isArray = Array.isArray || function (arr) {\n  return toString.call(arr) == '[object Array]';\n};\n\n/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\n\nvar INSPECT_MAX_BYTES = 50;\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Use Object implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * Due to various browser bugs, sometimes the Object implementation will be used even\n * when the browser supports typed arrays.\n *\n * Note:\n *\n *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n *\n *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n *\n *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n *     incorrect length in some situations.\n\n * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n * get the Object implementation, which is slower but behaves correctly.\n */\nBuffer.TYPED_ARRAY_SUPPORT = global$1.TYPED_ARRAY_SUPPORT !== undefined\n  ? global$1.TYPED_ARRAY_SUPPORT\n  : true;\n\n/*\n * Export kMaxLength after typed array support is determined.\n */\nkMaxLength();\n\nfunction kMaxLength () {\n  return Buffer.TYPED_ARRAY_SUPPORT\n    ? 0x7fffffff\n    : 0x3fffffff\n}\n\nfunction createBuffer (that, length) {\n  if (kMaxLength() < length) {\n    throw new RangeError('Invalid typed array length')\n  }\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = new Uint8Array(length);\n    that.__proto__ = Buffer.prototype;\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    if (that === null) {\n      that = new Buffer(length);\n    }\n    that.length = length;\n  }\n\n  return that\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {\n    return new Buffer(arg, encodingOrOffset, length)\n  }\n\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new Error(\n        'If encoding is specified then the first argument must be a string'\n      )\n    }\n    return allocUnsafe(this, arg)\n  }\n  return from(this, arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192; // not used by this implementation\n\n// TODO: Legacy, not needed anymore. Remove in next major version.\nBuffer._augment = function (arr) {\n  arr.__proto__ = Buffer.prototype;\n  return arr\n};\n\nfunction from (that, value, encodingOrOffset, length) {\n  if (typeof value === 'number') {\n    throw new TypeError('\"value\" argument must not be a number')\n  }\n\n  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {\n    return fromArrayBuffer(that, value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'string') {\n    return fromString(that, value, encodingOrOffset)\n  }\n\n  return fromObject(that, value)\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(null, value, encodingOrOffset, length)\n};\n\nif (Buffer.TYPED_ARRAY_SUPPORT) {\n  Buffer.prototype.__proto__ = Uint8Array.prototype;\n  Buffer.__proto__ = Uint8Array;\n  if (typeof Symbol !== 'undefined' && Symbol.species &&\n      Buffer[Symbol.species] === Buffer) ;\n}\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be a number')\n  } else if (size < 0) {\n    throw new RangeError('\"size\" argument must not be negative')\n  }\n}\n\nfunction alloc (that, size, fill, encoding) {\n  assertSize(size);\n  if (size <= 0) {\n    return createBuffer(that, size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpretted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(that, size).fill(fill, encoding)\n      : createBuffer(that, size).fill(fill)\n  }\n  return createBuffer(that, size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(null, size, fill, encoding)\n};\n\nfunction allocUnsafe (that, size) {\n  assertSize(size);\n  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n    for (var i = 0; i < size; ++i) {\n      that[i] = 0;\n    }\n  }\n  return that\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(null, size)\n};\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(null, size)\n};\n\nfunction fromString (that, string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8';\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('\"encoding\" must be a valid string encoding')\n  }\n\n  var length = byteLength(string, encoding) | 0;\n  that = createBuffer(that, length);\n\n  var actual = that.write(string, encoding);\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    that = that.slice(0, actual);\n  }\n\n  return that\n}\n\nfunction fromArrayLike (that, array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0;\n  that = createBuffer(that, length);\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255;\n  }\n  return that\n}\n\nfunction fromArrayBuffer (that, array, byteOffset, length) {\n  array.byteLength; // this throws if `array` is not a valid ArrayBuffer\n\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\\'offset\\' is out of bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\\'length\\' is out of bounds')\n  }\n\n  if (byteOffset === undefined && length === undefined) {\n    array = new Uint8Array(array);\n  } else if (length === undefined) {\n    array = new Uint8Array(array, byteOffset);\n  } else {\n    array = new Uint8Array(array, byteOffset, length);\n  }\n\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = array;\n    that.__proto__ = Buffer.prototype;\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that = fromArrayLike(that, array);\n  }\n  return that\n}\n\nfunction fromObject (that, obj) {\n  if (internalIsBuffer(obj)) {\n    var len = checked(obj.length) | 0;\n    that = createBuffer(that, len);\n\n    if (that.length === 0) {\n      return that\n    }\n\n    obj.copy(that, 0, 0, len);\n    return that\n  }\n\n  if (obj) {\n    if ((typeof ArrayBuffer !== 'undefined' &&\n        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {\n      if (typeof obj.length !== 'number' || isnan(obj.length)) {\n        return createBuffer(that, 0)\n      }\n      return fromArrayLike(that, obj)\n    }\n\n    if (obj.type === 'Buffer' && isArray(obj.data)) {\n      return fromArrayLike(that, obj.data)\n    }\n  }\n\n  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < kMaxLength()` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= kMaxLength()) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + kMaxLength().toString(16) + ' bytes')\n  }\n  return length | 0\n}\nBuffer.isBuffer = isBuffer;\nfunction internalIsBuffer (b) {\n  return !!(b != null && b._isBuffer)\n}\n\nBuffer.compare = function compare (a, b) {\n  if (!internalIsBuffer(a) || !internalIsBuffer(b)) {\n    throw new TypeError('Arguments must be Buffers')\n  }\n\n  if (a === b) return 0\n\n  var x = a.length;\n  var y = b.length;\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i];\n      y = b[i];\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n};\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n};\n\nBuffer.concat = function concat (list, length) {\n  if (!isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  var i;\n  if (length === undefined) {\n    length = 0;\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length;\n    }\n  }\n\n  var buffer = Buffer.allocUnsafe(length);\n  var pos = 0;\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i];\n    if (!internalIsBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    }\n    buf.copy(buffer, pos);\n    pos += buf.length;\n  }\n  return buffer\n};\n\nfunction byteLength (string, encoding) {\n  if (internalIsBuffer(string)) {\n    return string.length\n  }\n  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&\n      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    string = '' + string;\n  }\n\n  var len = string.length;\n  if (len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false;\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n      case undefined:\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n        encoding = ('' + encoding).toLowerCase();\n        loweredCase = true;\n    }\n  }\n}\nBuffer.byteLength = byteLength;\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false;\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0;\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length;\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0;\n  start >>>= 0;\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8';\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase();\n        loweredCase = true;\n    }\n  }\n}\n\n// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect\n// Buffer instances.\nBuffer.prototype._isBuffer = true;\n\nfunction swap (b, n, m) {\n  var i = b[n];\n  b[n] = b[m];\n  b[m] = i;\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  var len = this.length;\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1);\n  }\n  return this\n};\n\nBuffer.prototype.swap32 = function swap32 () {\n  var len = this.length;\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3);\n    swap(this, i + 1, i + 2);\n  }\n  return this\n};\n\nBuffer.prototype.swap64 = function swap64 () {\n  var len = this.length;\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (var i = 0; i < len; i += 8) {\n    swap(this, i, i + 7);\n    swap(this, i + 1, i + 6);\n    swap(this, i + 2, i + 5);\n    swap(this, i + 3, i + 4);\n  }\n  return this\n};\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length | 0;\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n};\n\nBuffer.prototype.equals = function equals (b) {\n  if (!internalIsBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n};\n\nBuffer.prototype.inspect = function inspect () {\n  var str = '';\n  var max = INSPECT_MAX_BYTES;\n  if (this.length > 0) {\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');\n    if (this.length > max) str += ' ... ';\n  }\n  return '<Buffer ' + str + '>'\n};\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (!internalIsBuffer(target)) {\n    throw new TypeError('Argument must be a Buffer')\n  }\n\n  if (start === undefined) {\n    start = 0;\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0;\n  }\n  if (thisStart === undefined) {\n    thisStart = 0;\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length;\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0;\n  end >>>= 0;\n  thisStart >>>= 0;\n  thisEnd >>>= 0;\n\n  if (this === target) return 0\n\n  var x = thisEnd - thisStart;\n  var y = end - start;\n  var len = Math.min(x, y);\n\n  var thisCopy = this.slice(thisStart, thisEnd);\n  var targetCopy = target.slice(start, end);\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i];\n      y = targetCopy[i];\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n};\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset;\n    byteOffset = 0;\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff;\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000;\n  }\n  byteOffset = +byteOffset;  // Coerce to Number.\n  if (isNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1);\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset;\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1;\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0;\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding);\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (internalIsBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF; // Search for a byte value [0-255]\n    if (Buffer.TYPED_ARRAY_SUPPORT &&\n        typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  var indexSize = 1;\n  var arrLength = arr.length;\n  var valLength = val.length;\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase();\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2;\n      arrLength /= 2;\n      valLength /= 2;\n      byteOffset /= 2;\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  var i;\n  if (dir) {\n    var foundIndex = -1;\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i;\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex;\n        foundIndex = -1;\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;\n    for (i = byteOffset; i >= 0; i--) {\n      var found = true;\n      for (var j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false;\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n};\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n};\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n};\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0;\n  var remaining = buf.length - offset;\n  if (!length) {\n    length = remaining;\n  } else {\n    length = Number(length);\n    if (length > remaining) {\n      length = remaining;\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length;\n  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')\n\n  if (length > strLen / 2) {\n    length = strLen / 2;\n  }\n  for (var i = 0; i < length; ++i) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16);\n    if (isNaN(parsed)) return i\n    buf[offset + i] = parsed;\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction latin1Write (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8';\n    length = this.length;\n    offset = 0;\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset;\n    length = this.length;\n    offset = 0;\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset | 0;\n    if (isFinite(length)) {\n      length = length | 0;\n      if (encoding === undefined) encoding = 'utf8';\n    } else {\n      encoding = length;\n      length = undefined;\n    }\n  // legacy write(string, encoding, offset, length) - remove in v0.13\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  var remaining = this.length - offset;\n  if (length === undefined || length > remaining) length = remaining;\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8';\n\n  var loweredCase = false;\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Write(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase();\n        loweredCase = true;\n    }\n  }\n};\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n};\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return fromByteArray(buf)\n  } else {\n    return fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end);\n  var res = [];\n\n  var i = start;\n  while (i < end) {\n    var firstByte = buf[i];\n    var codePoint = null;\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\n      : (firstByte > 0xDF) ? 3\n      : (firstByte > 0xBF) ? 2\n      : 1;\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint;\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte;\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1];\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F);\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint;\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1];\n          thirdByte = buf[i + 2];\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F);\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint;\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1];\n          thirdByte = buf[i + 2];\n          fourthByte = buf[i + 3];\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F);\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint;\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD;\n      bytesPerSequence = 1;\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000;\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800);\n      codePoint = 0xDC00 | codePoint & 0x3FF;\n    }\n\n    res.push(codePoint);\n    i += bytesPerSequence;\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000;\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length;\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = '';\n  var i = 0;\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    );\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = '';\n  end = Math.min(buf.length, end);\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F);\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  var ret = '';\n  end = Math.min(buf.length, end);\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i]);\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length;\n\n  if (!start || start < 0) start = 0;\n  if (!end || end < 0 || end > len) end = len;\n\n  var out = '';\n  for (var i = start; i < end; ++i) {\n    out += toHex(buf[i]);\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end);\n  var res = '';\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length;\n  start = ~~start;\n  end = end === undefined ? len : ~~end;\n\n  if (start < 0) {\n    start += len;\n    if (start < 0) start = 0;\n  } else if (start > len) {\n    start = len;\n  }\n\n  if (end < 0) {\n    end += len;\n    if (end < 0) end = 0;\n  } else if (end > len) {\n    end = len;\n  }\n\n  if (end < start) end = start;\n\n  var newBuf;\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    newBuf = this.subarray(start, end);\n    newBuf.__proto__ = Buffer.prototype;\n  } else {\n    var sliceLen = end - start;\n    newBuf = new Buffer(sliceLen, undefined);\n    for (var i = 0; i < sliceLen; ++i) {\n      newBuf[i] = this[i + start];\n    }\n  }\n\n  return newBuf\n};\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0;\n  byteLength = byteLength | 0;\n  if (!noAssert) checkOffset(offset, byteLength, this.length);\n\n  var val = this[offset];\n  var mul = 1;\n  var i = 0;\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul;\n  }\n\n  return val\n};\n\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0;\n  byteLength = byteLength | 0;\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length);\n  }\n\n  var val = this[offset + --byteLength];\n  var mul = 1;\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul;\n  }\n\n  return val\n};\n\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length);\n  return this[offset]\n};\n\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length);\n  return this[offset] | (this[offset + 1] << 8)\n};\n\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length);\n  return (this[offset] << 8) | this[offset + 1]\n};\n\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length);\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n};\n\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length);\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n};\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0;\n  byteLength = byteLength | 0;\n  if (!noAssert) checkOffset(offset, byteLength, this.length);\n\n  var val = this[offset];\n  var mul = 1;\n  var i = 0;\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul;\n  }\n  mul *= 0x80;\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength);\n\n  return val\n};\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0;\n  byteLength = byteLength | 0;\n  if (!noAssert) checkOffset(offset, byteLength, this.length);\n\n  var i = byteLength;\n  var mul = 1;\n  var val = this[offset + --i];\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul;\n  }\n  mul *= 0x80;\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength);\n\n  return val\n};\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length);\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n};\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length);\n  var val = this[offset] | (this[offset + 1] << 8);\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n};\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length);\n  var val = this[offset + 1] | (this[offset] << 8);\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n};\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length);\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n};\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length);\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n};\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length);\n  return read(this, offset, true, 23, 4)\n};\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length);\n  return read(this, offset, false, 23, 4)\n};\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length);\n  return read(this, offset, true, 52, 8)\n};\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length);\n  return read(this, offset, false, 52, 8)\n};\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!internalIsBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  byteLength = byteLength | 0;\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1;\n    checkInt(this, value, offset, byteLength, maxBytes, 0);\n  }\n\n  var mul = 1;\n  var i = 0;\n  this[offset] = value & 0xFF;\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF;\n  }\n\n  return offset + byteLength\n};\n\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  byteLength = byteLength | 0;\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1;\n    checkInt(this, value, offset, byteLength, maxBytes, 0);\n  }\n\n  var i = byteLength - 1;\n  var mul = 1;\n  this[offset + i] = value & 0xFF;\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF;\n  }\n\n  return offset + byteLength\n};\n\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);\n  this[offset] = (value & 0xff);\n  return offset + 1\n};\n\nfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffff + value + 1;\n  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {\n    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n      (littleEndian ? i : 1 - i) * 8;\n  }\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff);\n    this[offset + 1] = (value >>> 8);\n  } else {\n    objectWriteUInt16(this, value, offset, true);\n  }\n  return offset + 2\n};\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8);\n    this[offset + 1] = (value & 0xff);\n  } else {\n    objectWriteUInt16(this, value, offset, false);\n  }\n  return offset + 2\n};\n\nfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffffffff + value + 1;\n  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {\n    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff;\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset + 3] = (value >>> 24);\n    this[offset + 2] = (value >>> 16);\n    this[offset + 1] = (value >>> 8);\n    this[offset] = (value & 0xff);\n  } else {\n    objectWriteUInt32(this, value, offset, true);\n  }\n  return offset + 4\n};\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24);\n    this[offset + 1] = (value >>> 16);\n    this[offset + 2] = (value >>> 8);\n    this[offset + 3] = (value & 0xff);\n  } else {\n    objectWriteUInt32(this, value, offset, false);\n  }\n  return offset + 4\n};\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1);\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit);\n  }\n\n  var i = 0;\n  var mul = 1;\n  var sub = 0;\n  this[offset] = value & 0xFF;\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1;\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;\n  }\n\n  return offset + byteLength\n};\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1);\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit);\n  }\n\n  var i = byteLength - 1;\n  var mul = 1;\n  var sub = 0;\n  this[offset + i] = value & 0xFF;\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1;\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;\n  }\n\n  return offset + byteLength\n};\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);\n  if (value < 0) value = 0xff + value + 1;\n  this[offset] = (value & 0xff);\n  return offset + 1\n};\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff);\n    this[offset + 1] = (value >>> 8);\n  } else {\n    objectWriteUInt16(this, value, offset, true);\n  }\n  return offset + 2\n};\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8);\n    this[offset + 1] = (value & 0xff);\n  } else {\n    objectWriteUInt16(this, value, offset, false);\n  }\n  return offset + 2\n};\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff);\n    this[offset + 1] = (value >>> 8);\n    this[offset + 2] = (value >>> 16);\n    this[offset + 3] = (value >>> 24);\n  } else {\n    objectWriteUInt32(this, value, offset, true);\n  }\n  return offset + 4\n};\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);\n  if (value < 0) value = 0xffffffff + value + 1;\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24);\n    this[offset + 1] = (value >>> 16);\n    this[offset + 2] = (value >>> 8);\n    this[offset + 3] = (value & 0xff);\n  } else {\n    objectWriteUInt32(this, value, offset, false);\n  }\n  return offset + 4\n};\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4);\n  }\n  write(buf, value, offset, littleEndian, 23, 4);\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n};\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n};\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8);\n  }\n  write(buf, value, offset, littleEndian, 52, 8);\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n};\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n};\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!start) start = 0;\n  if (!end && end !== 0) end = this.length;\n  if (targetStart >= target.length) targetStart = target.length;\n  if (!targetStart) targetStart = 0;\n  if (end > 0 && end < start) end = start;\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length;\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start;\n  }\n\n  var len = end - start;\n  var i;\n\n  if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (i = len - 1; i >= 0; --i) {\n      target[i + targetStart] = this[i + start];\n    }\n  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n    // ascending copy from start\n    for (i = 0; i < len; ++i) {\n      target[i + targetStart] = this[i + start];\n    }\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, start + len),\n      targetStart\n    );\n  }\n\n  return len\n};\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start;\n      start = 0;\n      end = this.length;\n    } else if (typeof end === 'string') {\n      encoding = end;\n      end = this.length;\n    }\n    if (val.length === 1) {\n      var code = val.charCodeAt(0);\n      if (code < 256) {\n        val = code;\n      }\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255;\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0;\n  end = end === undefined ? this.length : end >>> 0;\n\n  if (!val) val = 0;\n\n  var i;\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val;\n    }\n  } else {\n    var bytes = internalIsBuffer(val)\n      ? val\n      : utf8ToBytes(new Buffer(val, encoding).toString());\n    var len = bytes.length;\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len];\n    }\n  }\n\n  return this\n};\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g;\n\nfunction base64clean (str) {\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = stringtrim(str).replace(INVALID_BASE64_RE, '');\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '=';\n  }\n  return str\n}\n\nfunction stringtrim (str) {\n  if (str.trim) return str.trim()\n  return str.replace(/^\\s+|\\s+$/g, '')\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity;\n  var codePoint;\n  var length = string.length;\n  var leadSurrogate = null;\n  var bytes = [];\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i);\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint;\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n        leadSurrogate = codePoint;\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n    }\n\n    leadSurrogate = null;\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint);\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      );\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      );\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      );\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = [];\n  for (var i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF);\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo;\n  var byteArray = [];\n  for (var i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i);\n    hi = c >> 8;\n    lo = c % 256;\n    byteArray.push(lo);\n    byteArray.push(hi);\n  }\n\n  return byteArray\n}\n\n\nfunction base64ToBytes (str) {\n  return toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i];\n  }\n  return i\n}\n\nfunction isnan (val) {\n  return val !== val // eslint-disable-line no-self-compare\n}\n\n\n// the following is from is-buffer, also by Feross Aboukhadijeh and with same lisence\n// The _isBuffer check is for Safari 5-7 support, because it's missing\n// Object.prototype.constructor. Remove this eventually\nfunction isBuffer(obj) {\n  return obj != null && (!!obj._isBuffer || isFastBuffer(obj) || isSlowBuffer(obj))\n}\n\nfunction isFastBuffer (obj) {\n  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)\n}\n\n// For Node v0.10 support. Remove this eventually.\nfunction isSlowBuffer (obj) {\n  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isFastBuffer(obj.slice(0, 0))\n}\n\nconst isHexString = (hex) => typeof hex === 'string' && /^0x[0-9A-Fa-f]*$/.test(hex);\nconst utf8ToHex = (str) => {\n    return Buffer.from(str, 'utf8').toString('hex');\n};\n\nconst isValidTransaction = (transaction) => {\n    if (!transaction ||\n        typeof transaction !== 'object' ||\n        !('from' in transaction)) {\n        return { isValid: false, invalidMsg: ERROR_MESSAGE.INVALID_TRANSACTION };\n    }\n    if (transaction.value && !isHexString(transaction.value)) {\n        return {\n            isValid: false,\n            invalidMsg: ERROR_MESSAGE.INVALID_TRANSACTION_VALUE,\n        };\n    }\n    return { isValid: true };\n};\nconst isValidTransactions = (transactions) => {\n    if (!Array.isArray(transactions)) {\n        return { isValid: false, invalidMsg: ERROR_MESSAGE.INVALID_TRANSACTIONS };\n    }\n    for (let i = 0; i < transactions.length; i++) {\n        const { isValid, invalidMsg } = isValidTransaction(transactions[i]);\n        if (!isValid) {\n            return { isValid, invalidMsg };\n        }\n    }\n    return { isValid: true };\n};\n\nfunction getEvmSupport() {\n    return __awaiter(this, void 0, void 0, function* () {\n        const { networks } = yield fetch('https://api.blocto.app/networks/evm').then((response) => response.json());\n        const evmSupportMap = networks.reduce((a, v) => (Object.assign(Object.assign({}, a), { [v.chain_id]: v })), {});\n        return evmSupportMap;\n    });\n}\n\nvar dist = {};\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _typeof(o) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) {\n    return typeof o;\n  } : function (o) {\n    return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n  }, _typeof(o);\n}\n\nfunction _toPrimitive(input, hint) {\n  if (_typeof(input) !== \"object\" || input === null) return input;\n  var prim = input[Symbol.toPrimitive];\n  if (prim !== undefined) {\n    var res = prim.call(input, hint || \"default\");\n    if (_typeof(res) !== \"object\") return res;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (hint === \"string\" ? String : Number)(input);\n}\n\nfunction _toPropertyKey(arg) {\n  var key = _toPrimitive(arg, \"string\");\n  return _typeof(key) === \"symbol\" ? key : String(key);\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n  return _setPrototypeOf(o, p);\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  Object.defineProperty(subClass, \"prototype\", {\n    writable: false\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n  return self;\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  } else if (call !== void 0) {\n    throw new TypeError(\"Derived constructors may only return object or undefined\");\n  }\n  return _assertThisInitialized(self);\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nfunction _isNativeFunction(fn) {\n  return Function.toString.call(fn).indexOf(\"[native code]\") !== -1;\n}\n\nfunction _isNativeReflectConstruct$1() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction _construct(Parent, args, Class) {\n  if (_isNativeReflectConstruct$1()) {\n    _construct = Reflect.construct.bind();\n  } else {\n    _construct = function _construct(Parent, args, Class) {\n      var a = [null];\n      a.push.apply(a, args);\n      var Constructor = Function.bind.apply(Parent, a);\n      var instance = new Constructor();\n      if (Class) _setPrototypeOf(instance, Class.prototype);\n      return instance;\n    };\n  }\n  return _construct.apply(null, arguments);\n}\n\nfunction _wrapNativeSuper(Class) {\n  var _cache = typeof Map === \"function\" ? new Map() : undefined;\n  _wrapNativeSuper = function _wrapNativeSuper(Class) {\n    if (Class === null || !_isNativeFunction(Class)) return Class;\n    if (typeof Class !== \"function\") {\n      throw new TypeError(\"Super expression must either be null or a function\");\n    }\n    if (typeof _cache !== \"undefined\") {\n      if (_cache.has(Class)) return _cache.get(Class);\n      _cache.set(Class, Wrapper);\n    }\n    function Wrapper() {\n      return _construct(Class, arguments, _getPrototypeOf(this).constructor);\n    }\n    Wrapper.prototype = Object.create(Class.prototype, {\n      constructor: {\n        value: Wrapper,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n    return _setPrototypeOf(Wrapper, Class);\n  };\n  return _wrapNativeSuper(Class);\n}\n\nvar classes = {};\n\nvar fastSafeStringify = stringify;\nstringify[\"default\"] = stringify;\nstringify.stable = deterministicStringify;\nstringify.stableStringify = deterministicStringify;\nvar LIMIT_REPLACE_NODE = '[...]';\nvar CIRCULAR_REPLACE_NODE = '[Circular]';\nvar arr = [];\nvar replacerStack = [];\nfunction defaultOptions() {\n  return {\n    depthLimit: Number.MAX_SAFE_INTEGER,\n    edgesLimit: Number.MAX_SAFE_INTEGER\n  };\n}\n\n// Regular stringify\nfunction stringify(obj, replacer, spacer, options) {\n  if (typeof options === 'undefined') {\n    options = defaultOptions();\n  }\n  decirc(obj, '', 0, [], undefined, 0, options);\n  var res;\n  try {\n    if (replacerStack.length === 0) {\n      res = JSON.stringify(obj, replacer, spacer);\n    } else {\n      res = JSON.stringify(obj, replaceGetterValues(replacer), spacer);\n    }\n  } catch (_) {\n    return JSON.stringify('[unable to serialize, circular reference is too complex to analyze]');\n  } finally {\n    while (arr.length !== 0) {\n      var part = arr.pop();\n      if (part.length === 4) {\n        Object.defineProperty(part[0], part[1], part[3]);\n      } else {\n        part[0][part[1]] = part[2];\n      }\n    }\n  }\n  return res;\n}\nfunction setReplace(replace, val, k, parent) {\n  var propertyDescriptor = Object.getOwnPropertyDescriptor(parent, k);\n  if (propertyDescriptor.get !== undefined) {\n    if (propertyDescriptor.configurable) {\n      Object.defineProperty(parent, k, {\n        value: replace\n      });\n      arr.push([parent, k, val, propertyDescriptor]);\n    } else {\n      replacerStack.push([val, k, replace]);\n    }\n  } else {\n    parent[k] = replace;\n    arr.push([parent, k, val]);\n  }\n}\nfunction decirc(val, k, edgeIndex, stack, parent, depth, options) {\n  depth += 1;\n  var i;\n  if (_typeof(val) === 'object' && val !== null) {\n    for (i = 0; i < stack.length; i++) {\n      if (stack[i] === val) {\n        setReplace(CIRCULAR_REPLACE_NODE, val, k, parent);\n        return;\n      }\n    }\n    if (typeof options.depthLimit !== 'undefined' && depth > options.depthLimit) {\n      setReplace(LIMIT_REPLACE_NODE, val, k, parent);\n      return;\n    }\n    if (typeof options.edgesLimit !== 'undefined' && edgeIndex + 1 > options.edgesLimit) {\n      setReplace(LIMIT_REPLACE_NODE, val, k, parent);\n      return;\n    }\n    stack.push(val);\n    // Optimize for Arrays. Big arrays could kill the performance otherwise!\n    if (Array.isArray(val)) {\n      for (i = 0; i < val.length; i++) {\n        decirc(val[i], i, i, stack, val, depth, options);\n      }\n    } else {\n      var keys = Object.keys(val);\n      for (i = 0; i < keys.length; i++) {\n        var key = keys[i];\n        decirc(val[key], key, i, stack, val, depth, options);\n      }\n    }\n    stack.pop();\n  }\n}\n\n// Stable-stringify\nfunction compareFunction(a, b) {\n  if (a < b) {\n    return -1;\n  }\n  if (a > b) {\n    return 1;\n  }\n  return 0;\n}\nfunction deterministicStringify(obj, replacer, spacer, options) {\n  if (typeof options === 'undefined') {\n    options = defaultOptions();\n  }\n  var tmp = deterministicDecirc(obj, '', 0, [], undefined, 0, options) || obj;\n  var res;\n  try {\n    if (replacerStack.length === 0) {\n      res = JSON.stringify(tmp, replacer, spacer);\n    } else {\n      res = JSON.stringify(tmp, replaceGetterValues(replacer), spacer);\n    }\n  } catch (_) {\n    return JSON.stringify('[unable to serialize, circular reference is too complex to analyze]');\n  } finally {\n    // Ensure that we restore the object as it was.\n    while (arr.length !== 0) {\n      var part = arr.pop();\n      if (part.length === 4) {\n        Object.defineProperty(part[0], part[1], part[3]);\n      } else {\n        part[0][part[1]] = part[2];\n      }\n    }\n  }\n  return res;\n}\nfunction deterministicDecirc(val, k, edgeIndex, stack, parent, depth, options) {\n  depth += 1;\n  var i;\n  if (_typeof(val) === 'object' && val !== null) {\n    for (i = 0; i < stack.length; i++) {\n      if (stack[i] === val) {\n        setReplace(CIRCULAR_REPLACE_NODE, val, k, parent);\n        return;\n      }\n    }\n    try {\n      if (typeof val.toJSON === 'function') {\n        return;\n      }\n    } catch (_) {\n      return;\n    }\n    if (typeof options.depthLimit !== 'undefined' && depth > options.depthLimit) {\n      setReplace(LIMIT_REPLACE_NODE, val, k, parent);\n      return;\n    }\n    if (typeof options.edgesLimit !== 'undefined' && edgeIndex + 1 > options.edgesLimit) {\n      setReplace(LIMIT_REPLACE_NODE, val, k, parent);\n      return;\n    }\n    stack.push(val);\n    // Optimize for Arrays. Big arrays could kill the performance otherwise!\n    if (Array.isArray(val)) {\n      for (i = 0; i < val.length; i++) {\n        deterministicDecirc(val[i], i, i, stack, val, depth, options);\n      }\n    } else {\n      // Create a temporary object in the required way\n      var tmp = {};\n      var keys = Object.keys(val).sort(compareFunction);\n      for (i = 0; i < keys.length; i++) {\n        var key = keys[i];\n        deterministicDecirc(val[key], key, i, stack, val, depth, options);\n        tmp[key] = val[key];\n      }\n      if (typeof parent !== 'undefined') {\n        arr.push([parent, k, val]);\n        parent[k] = tmp;\n      } else {\n        return tmp;\n      }\n    }\n    stack.pop();\n  }\n}\n\n// wraps replacer function to handle values we couldn't replace\n// and mark them as replaced value\nfunction replaceGetterValues(replacer) {\n  replacer = typeof replacer !== 'undefined' ? replacer : function (k, v) {\n    return v;\n  };\n  return function (key, val) {\n    if (replacerStack.length > 0) {\n      for (var i = 0; i < replacerStack.length; i++) {\n        var part = replacerStack[i];\n        if (part[1] === key && part[0] === val) {\n          val = part[2];\n          replacerStack.splice(i, 1);\n          break;\n        }\n      }\n    }\n    return replacer.call(this, key, val);\n  };\n}\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nObject.defineProperty(classes, \"__esModule\", {\n  value: true\n});\nclasses.EthereumProviderError = classes.EthereumRpcError = void 0;\nvar fast_safe_stringify_1 = fastSafeStringify;\n/**\n * Error subclass implementing JSON RPC 2.0 errors and Ethereum RPC errors\n * per EIP-1474.\n * Permits any integer error code.\n */\nvar EthereumRpcError = /*#__PURE__*/function (_Error) {\n  _inherits(EthereumRpcError, _Error);\n  var _super = _createSuper(EthereumRpcError);\n  function EthereumRpcError(code, message, data) {\n    var _this;\n    _classCallCheck(this, EthereumRpcError);\n    if (!Number.isInteger(code)) {\n      throw new Error('\"code\" must be an integer.');\n    }\n    if (!message || typeof message !== 'string') {\n      throw new Error('\"message\" must be a nonempty string.');\n    }\n    _this = _super.call(this, message);\n    _this.code = code;\n    if (data !== undefined) {\n      _this.data = data;\n    }\n    return _this;\n  }\n  /**\n   * Returns a plain object with all public class properties.\n   */\n  _createClass(EthereumRpcError, [{\n    key: \"serialize\",\n    value: function serialize() {\n      var serialized = {\n        code: this.code,\n        message: this.message\n      };\n      if (this.data !== undefined) {\n        serialized.data = this.data;\n      }\n      if (this.stack) {\n        serialized.stack = this.stack;\n      }\n      return serialized;\n    }\n    /**\n     * Return a string representation of the serialized error, omitting\n     * any circular references.\n     */\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return fast_safe_stringify_1[\"default\"](this.serialize(), stringifyReplacer, 2);\n    }\n  }]);\n  return EthereumRpcError;\n}( /*#__PURE__*/_wrapNativeSuper(Error));\nclasses.EthereumRpcError = EthereumRpcError;\n/**\n * Error subclass implementing Ethereum Provider errors per EIP-1193.\n * Permits integer error codes in the [ 1000 <= 4999 ] range.\n */\nvar EthereumProviderError = /*#__PURE__*/function (_EthereumRpcError) {\n  _inherits(EthereumProviderError, _EthereumRpcError);\n  var _super2 = _createSuper(EthereumProviderError);\n  /**\n   * Create an Ethereum Provider JSON-RPC error.\n   * `code` must be an integer in the 1000 <= 4999 range.\n   */\n  function EthereumProviderError(code, message, data) {\n    _classCallCheck(this, EthereumProviderError);\n    if (!isValidEthProviderCode(code)) {\n      throw new Error('\"code\" must be an integer such that: 1000 <= code <= 4999');\n    }\n    return _super2.call(this, code, message, data);\n  }\n  return _createClass(EthereumProviderError);\n}(EthereumRpcError);\nclasses.EthereumProviderError = EthereumProviderError;\n// Internal\nfunction isValidEthProviderCode(code) {\n  return Number.isInteger(code) && code >= 1000 && code <= 4999;\n}\nfunction stringifyReplacer(_, value) {\n  if (value === '[Circular]') {\n    return undefined;\n  }\n  return value;\n}\n\nvar utils = {};\n\nvar errorConstants = {};\n\nObject.defineProperty(errorConstants, \"__esModule\", {\n  value: true\n});\nerrorConstants.errorValues = errorConstants.errorCodes = void 0;\nerrorConstants.errorCodes = {\n  rpc: {\n    invalidInput: -32000,\n    resourceNotFound: -32001,\n    resourceUnavailable: -32002,\n    transactionRejected: -32003,\n    methodNotSupported: -32004,\n    limitExceeded: -32005,\n    parse: -32700,\n    invalidRequest: -32600,\n    methodNotFound: -32601,\n    invalidParams: -32602,\n    internal: -32603\n  },\n  provider: {\n    userRejectedRequest: 4001,\n    unauthorized: 4100,\n    unsupportedMethod: 4200,\n    disconnected: 4900,\n    chainDisconnected: 4901\n  }\n};\nerrorConstants.errorValues = {\n  '-32700': {\n    standard: 'JSON RPC 2.0',\n    message: 'Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text.'\n  },\n  '-32600': {\n    standard: 'JSON RPC 2.0',\n    message: 'The JSON sent is not a valid Request object.'\n  },\n  '-32601': {\n    standard: 'JSON RPC 2.0',\n    message: 'The method does not exist / is not available.'\n  },\n  '-32602': {\n    standard: 'JSON RPC 2.0',\n    message: 'Invalid method parameter(s).'\n  },\n  '-32603': {\n    standard: 'JSON RPC 2.0',\n    message: 'Internal JSON-RPC error.'\n  },\n  '-32000': {\n    standard: 'EIP-1474',\n    message: 'Invalid input.'\n  },\n  '-32001': {\n    standard: 'EIP-1474',\n    message: 'Resource not found.'\n  },\n  '-32002': {\n    standard: 'EIP-1474',\n    message: 'Resource unavailable.'\n  },\n  '-32003': {\n    standard: 'EIP-1474',\n    message: 'Transaction rejected.'\n  },\n  '-32004': {\n    standard: 'EIP-1474',\n    message: 'Method not supported.'\n  },\n  '-32005': {\n    standard: 'EIP-1474',\n    message: 'Request limit exceeded.'\n  },\n  '4001': {\n    standard: 'EIP-1193',\n    message: 'User rejected the request.'\n  },\n  '4100': {\n    standard: 'EIP-1193',\n    message: 'The requested account and/or method has not been authorized by the user.'\n  },\n  '4200': {\n    standard: 'EIP-1193',\n    message: 'The requested method is not supported by this Ethereum provider.'\n  },\n  '4900': {\n    standard: 'EIP-1193',\n    message: 'The provider is disconnected from all chains.'\n  },\n  '4901': {\n    standard: 'EIP-1193',\n    message: 'The provider is disconnected from the specified chain.'\n  }\n};\n\n(function (exports) {\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.serializeError = exports.isValidCode = exports.getMessageFromCode = exports.JSON_RPC_SERVER_ERROR_MESSAGE = void 0;\n  var error_constants_1 = errorConstants;\n  var classes_1 = classes;\n  var FALLBACK_ERROR_CODE = error_constants_1.errorCodes.rpc.internal;\n  var FALLBACK_MESSAGE = 'Unspecified error message. This is a bug, please report it.';\n  var FALLBACK_ERROR = {\n    code: FALLBACK_ERROR_CODE,\n    message: getMessageFromCode(FALLBACK_ERROR_CODE)\n  };\n  exports.JSON_RPC_SERVER_ERROR_MESSAGE = 'Unspecified server error.';\n  /**\n   * Gets the message for a given code, or a fallback message if the code has\n   * no corresponding message.\n   */\n  function getMessageFromCode(code) {\n    var fallbackMessage = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : FALLBACK_MESSAGE;\n    if (Number.isInteger(code)) {\n      var codeString = code.toString();\n      if (hasKey(error_constants_1.errorValues, codeString)) {\n        return error_constants_1.errorValues[codeString].message;\n      }\n      if (isJsonRpcServerError(code)) {\n        return exports.JSON_RPC_SERVER_ERROR_MESSAGE;\n      }\n    }\n    return fallbackMessage;\n  }\n  exports.getMessageFromCode = getMessageFromCode;\n  /**\n   * Returns whether the given code is valid.\n   * A code is only valid if it has a message.\n   */\n  function isValidCode(code) {\n    if (!Number.isInteger(code)) {\n      return false;\n    }\n    var codeString = code.toString();\n    if (error_constants_1.errorValues[codeString]) {\n      return true;\n    }\n    if (isJsonRpcServerError(code)) {\n      return true;\n    }\n    return false;\n  }\n  exports.isValidCode = isValidCode;\n  /**\n   * Serializes the given error to an Ethereum JSON RPC-compatible error object.\n   * Merely copies the given error's values if it is already compatible.\n   * If the given error is not fully compatible, it will be preserved on the\n   * returned object's data.originalError property.\n   */\n  function serializeError(error) {\n    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n      _ref$fallbackError = _ref.fallbackError,\n      fallbackError = _ref$fallbackError === void 0 ? FALLBACK_ERROR : _ref$fallbackError,\n      _ref$shouldIncludeSta = _ref.shouldIncludeStack,\n      shouldIncludeStack = _ref$shouldIncludeSta === void 0 ? false : _ref$shouldIncludeSta;\n    var _a, _b;\n    if (!fallbackError || !Number.isInteger(fallbackError.code) || typeof fallbackError.message !== 'string') {\n      throw new Error('Must provide fallback error with integer number code and string message.');\n    }\n    if (error instanceof classes_1.EthereumRpcError) {\n      return error.serialize();\n    }\n    var serialized = {};\n    if (error && _typeof(error) === 'object' && !Array.isArray(error) && hasKey(error, 'code') && isValidCode(error.code)) {\n      var _error = error;\n      serialized.code = _error.code;\n      if (_error.message && typeof _error.message === 'string') {\n        serialized.message = _error.message;\n        if (hasKey(_error, 'data')) {\n          serialized.data = _error.data;\n        }\n      } else {\n        serialized.message = getMessageFromCode(serialized.code);\n        serialized.data = {\n          originalError: assignOriginalError(error)\n        };\n      }\n    } else {\n      serialized.code = fallbackError.code;\n      var message = (_a = error) === null || _a === void 0 ? void 0 : _a.message;\n      serialized.message = message && typeof message === 'string' ? message : fallbackError.message;\n      serialized.data = {\n        originalError: assignOriginalError(error)\n      };\n    }\n    var stack = (_b = error) === null || _b === void 0 ? void 0 : _b.stack;\n    if (shouldIncludeStack && error && stack && typeof stack === 'string') {\n      serialized.stack = stack;\n    }\n    return serialized;\n  }\n  exports.serializeError = serializeError;\n  // Internal\n  function isJsonRpcServerError(code) {\n    return code >= -32099 && code <= -32000;\n  }\n  function assignOriginalError(error) {\n    if (error && _typeof(error) === 'object' && !Array.isArray(error)) {\n      return Object.assign({}, error);\n    }\n    return error;\n  }\n  function hasKey(obj, key) {\n    return Object.prototype.hasOwnProperty.call(obj, key);\n  }\n})(utils);\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction _iterableToArrayLimit(r, l) {\n  var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"];\n  if (null != t) {\n    var e,\n      n,\n      i,\n      u,\n      a = [],\n      f = !0,\n      o = !1;\n    try {\n      if (i = (t = t.call(r)).next, 0 === l) {\n        if (Object(t) !== t) return;\n        f = !1;\n      } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);\n    } catch (r) {\n      o = !0, n = r;\n    } finally {\n      try {\n        if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return;\n      } finally {\n        if (o) throw n;\n      }\n    }\n    return a;\n  }\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n  return arr2;\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\n\nvar errors = {};\n\nObject.defineProperty(errors, \"__esModule\", {\n  value: true\n});\nerrors.ethErrors = void 0;\nvar classes_1 = classes;\nvar utils_1 = utils;\nvar error_constants_1 = errorConstants;\nerrors.ethErrors = {\n  rpc: {\n    /**\n     * Get a JSON RPC 2.0 Parse (-32700) error.\n     */\n    parse: function parse(arg) {\n      return getEthJsonRpcError(error_constants_1.errorCodes.rpc.parse, arg);\n    },\n    /**\n     * Get a JSON RPC 2.0 Invalid Request (-32600) error.\n     */\n    invalidRequest: function invalidRequest(arg) {\n      return getEthJsonRpcError(error_constants_1.errorCodes.rpc.invalidRequest, arg);\n    },\n    /**\n     * Get a JSON RPC 2.0 Invalid Params (-32602) error.\n     */\n    invalidParams: function invalidParams(arg) {\n      return getEthJsonRpcError(error_constants_1.errorCodes.rpc.invalidParams, arg);\n    },\n    /**\n     * Get a JSON RPC 2.0 Method Not Found (-32601) error.\n     */\n    methodNotFound: function methodNotFound(arg) {\n      return getEthJsonRpcError(error_constants_1.errorCodes.rpc.methodNotFound, arg);\n    },\n    /**\n     * Get a JSON RPC 2.0 Internal (-32603) error.\n     */\n    internal: function internal(arg) {\n      return getEthJsonRpcError(error_constants_1.errorCodes.rpc.internal, arg);\n    },\n    /**\n     * Get a JSON RPC 2.0 Server error.\n     * Permits integer error codes in the [ -32099 <= -32005 ] range.\n     * Codes -32000 through -32004 are reserved by EIP-1474.\n     */\n    server: function server(opts) {\n      if (!opts || _typeof(opts) !== 'object' || Array.isArray(opts)) {\n        throw new Error('Ethereum RPC Server errors must provide single object argument.');\n      }\n      var code = opts.code;\n      if (!Number.isInteger(code) || code > -32005 || code < -32099) {\n        throw new Error('\"code\" must be an integer such that: -32099 <= code <= -32005');\n      }\n      return getEthJsonRpcError(code, opts);\n    },\n    /**\n     * Get an Ethereum JSON RPC Invalid Input (-32000) error.\n     */\n    invalidInput: function invalidInput(arg) {\n      return getEthJsonRpcError(error_constants_1.errorCodes.rpc.invalidInput, arg);\n    },\n    /**\n     * Get an Ethereum JSON RPC Resource Not Found (-32001) error.\n     */\n    resourceNotFound: function resourceNotFound(arg) {\n      return getEthJsonRpcError(error_constants_1.errorCodes.rpc.resourceNotFound, arg);\n    },\n    /**\n     * Get an Ethereum JSON RPC Resource Unavailable (-32002) error.\n     */\n    resourceUnavailable: function resourceUnavailable(arg) {\n      return getEthJsonRpcError(error_constants_1.errorCodes.rpc.resourceUnavailable, arg);\n    },\n    /**\n     * Get an Ethereum JSON RPC Transaction Rejected (-32003) error.\n     */\n    transactionRejected: function transactionRejected(arg) {\n      return getEthJsonRpcError(error_constants_1.errorCodes.rpc.transactionRejected, arg);\n    },\n    /**\n     * Get an Ethereum JSON RPC Method Not Supported (-32004) error.\n     */\n    methodNotSupported: function methodNotSupported(arg) {\n      return getEthJsonRpcError(error_constants_1.errorCodes.rpc.methodNotSupported, arg);\n    },\n    /**\n     * Get an Ethereum JSON RPC Limit Exceeded (-32005) error.\n     */\n    limitExceeded: function limitExceeded(arg) {\n      return getEthJsonRpcError(error_constants_1.errorCodes.rpc.limitExceeded, arg);\n    }\n  },\n  provider: {\n    /**\n     * Get an Ethereum Provider User Rejected Request (4001) error.\n     */\n    userRejectedRequest: function userRejectedRequest(arg) {\n      return getEthProviderError(error_constants_1.errorCodes.provider.userRejectedRequest, arg);\n    },\n    /**\n     * Get an Ethereum Provider Unauthorized (4100) error.\n     */\n    unauthorized: function unauthorized(arg) {\n      return getEthProviderError(error_constants_1.errorCodes.provider.unauthorized, arg);\n    },\n    /**\n     * Get an Ethereum Provider Unsupported Method (4200) error.\n     */\n    unsupportedMethod: function unsupportedMethod(arg) {\n      return getEthProviderError(error_constants_1.errorCodes.provider.unsupportedMethod, arg);\n    },\n    /**\n     * Get an Ethereum Provider Not Connected (4900) error.\n     */\n    disconnected: function disconnected(arg) {\n      return getEthProviderError(error_constants_1.errorCodes.provider.disconnected, arg);\n    },\n    /**\n     * Get an Ethereum Provider Chain Not Connected (4901) error.\n     */\n    chainDisconnected: function chainDisconnected(arg) {\n      return getEthProviderError(error_constants_1.errorCodes.provider.chainDisconnected, arg);\n    },\n    /**\n     * Get a custom Ethereum Provider error.\n     */\n    custom: function custom(opts) {\n      if (!opts || _typeof(opts) !== 'object' || Array.isArray(opts)) {\n        throw new Error('Ethereum Provider custom errors must provide single object argument.');\n      }\n      var code = opts.code,\n        message = opts.message,\n        data = opts.data;\n      if (!message || typeof message !== 'string') {\n        throw new Error('\"message\" must be a nonempty string');\n      }\n      return new classes_1.EthereumProviderError(code, message, data);\n    }\n  }\n};\n// Internal\nfunction getEthJsonRpcError(code, arg) {\n  var _parseOpts = parseOpts(arg),\n    _parseOpts2 = _slicedToArray(_parseOpts, 2),\n    message = _parseOpts2[0],\n    data = _parseOpts2[1];\n  return new classes_1.EthereumRpcError(code, message || utils_1.getMessageFromCode(code), data);\n}\nfunction getEthProviderError(code, arg) {\n  var _parseOpts3 = parseOpts(arg),\n    _parseOpts4 = _slicedToArray(_parseOpts3, 2),\n    message = _parseOpts4[0],\n    data = _parseOpts4[1];\n  return new classes_1.EthereumProviderError(code, message || utils_1.getMessageFromCode(code), data);\n}\nfunction parseOpts(arg) {\n  if (arg) {\n    if (typeof arg === 'string') {\n      return [arg];\n    } else if (_typeof(arg) === 'object' && !Array.isArray(arg)) {\n      var message = arg.message,\n        data = arg.data;\n      if (message && typeof message !== 'string') {\n        throw new Error('Must specify string message.');\n      }\n      return [message || undefined, data];\n    }\n  }\n  return [];\n}\n\n(function (exports) {\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.getMessageFromCode = exports.serializeError = exports.EthereumProviderError = exports.EthereumRpcError = exports.ethErrors = exports.errorCodes = void 0;\n  var classes_1 = classes;\n  Object.defineProperty(exports, \"EthereumRpcError\", {\n    enumerable: true,\n    get: function get() {\n      return classes_1.EthereumRpcError;\n    }\n  });\n  Object.defineProperty(exports, \"EthereumProviderError\", {\n    enumerable: true,\n    get: function get() {\n      return classes_1.EthereumProviderError;\n    }\n  });\n  var utils_1 = utils;\n  Object.defineProperty(exports, \"serializeError\", {\n    enumerable: true,\n    get: function get() {\n      return utils_1.serializeError;\n    }\n  });\n  Object.defineProperty(exports, \"getMessageFromCode\", {\n    enumerable: true,\n    get: function get() {\n      return utils_1.getMessageFromCode;\n    }\n  });\n  var errors_1 = errors;\n  Object.defineProperty(exports, \"ethErrors\", {\n    enumerable: true,\n    get: function get() {\n      return errors_1.ethErrors;\n    }\n  });\n  var error_constants_1 = errorConstants;\n  Object.defineProperty(exports, \"errorCodes\", {\n    enumerable: true,\n    get: function get() {\n      return error_constants_1.errorCodes;\n    }\n  });\n})(dist);\n\nvar _EthereumProvider_instances, _EthereumProvider_getBloctoProperties, _EthereumProvider_addToSwitchable, _EthereumProvider_checkNetworkMatched, _EthereumProvider_createAuthzFrame;\nfunction parseChainId(chainId) {\n    if (!chainId) {\n        return 1;\n    }\n    if (typeof chainId === 'number') {\n        return chainId;\n    }\n    else if (chainId.startsWith('0x')) {\n        return parseInt(chainId, 16);\n    }\n    return parseInt(chainId, 10);\n}\nclass EthereumProvider extends BloctoProvider {\n    get existedSDK() {\n        if (typeof window === 'undefined')\n            return undefined;\n        return window.ethereum;\n    }\n    constructor(config) {\n        var _a;\n        super();\n        _EthereumProvider_instances.add(this);\n        this.networkVersion = '1'; // same as chainId but in decimal\n        this.off = this.removeListener;\n        this.injectedWalletServer = config.walletServer;\n        this._blocto = {\n            sessionKeyEnv: KEY_SESSION.prod,\n            walletServer: this.injectedWalletServer || '',\n            blockchainName: '',\n            networkType: '',\n            switchableNetwork: {},\n        };\n        this.appId = config.appId || DEFAULT_APP_ID;\n        if ('chainId' in config) {\n            const { chainId, rpc } = config;\n            invariant(chainId, \"'chainId' is required\");\n            this.networkVersion = `${parseChainId(chainId)}`;\n            this.chainId = `0x${parseChainId(chainId).toString(16)}`;\n            // setup rpc\n            this.rpc = rpc || ETH_RPC_LIST[this.networkVersion];\n            invariant(this.rpc, \"'rpc' is required\");\n        }\n        else {\n            const { defaultChainId, switchableChains } = config;\n            invariant(defaultChainId, \"'defaultChainId' is required\");\n            this.networkVersion = `${parseChainId(defaultChainId)}`;\n            this.chainId = `0x${parseChainId(defaultChainId).toString(16)}`;\n            // get config from switchableChains array\n            const chainConfig = switchableChains.find((chain) => parseChainId(chain.chainId) === parseChainId(defaultChainId));\n            if (!chainConfig) {\n                throw dist.ethErrors.provider.custom({\n                    code: 1001,\n                    message: `Chain ${defaultChainId} is not in switchableChains list`,\n                });\n            }\n            this.rpc = ((_a = chainConfig.rpcUrls) === null || _a === void 0 ? void 0 : _a[0]) || ETH_RPC_LIST[this.networkVersion];\n            invariant(this.rpc, \"'rpc' is required\");\n            this._blocto.unloadedNetwork = switchableChains;\n        }\n    }\n    // DEPRECATED API: see https://docs.metamask.io/guide/ethereum-provider.html#ethereum-send-deprecated\n    send(methodOrPayload, paramsOrCallback) {\n        return __awaiter(this, void 0, void 0, function* () {\n            switch (true) {\n                // signature type 1: arg1 - JSON-RPC payload, arg2 - callback;\n                // ethereum.send(payload: JsonRpcRequest, callback: JsonRpcCallback): void;\n                // This signature is exactly like ethereum.sendAsync()\n                case paramsOrCallback instanceof Function:\n                    return this.sendAsync(methodOrPayload, paramsOrCallback);\n                // signature type 2: arg1 - JSON-RPC method name, arg2 - params array;\n                // ethereum.send(method: string, params?: Array<unknown>): Promise<JsonRpcResponse>;\n                // This signature is like an async ethereum.sendAsync() with method and params as arguments,\n                // instead of a JSON-RPC payload and callback\n                case typeof methodOrPayload === 'string' &&\n                    Array.isArray(paramsOrCallback):\n                    return this.sendAsync({\n                        jsonrpc: '2.0',\n                        method: methodOrPayload,\n                        params: paramsOrCallback,\n                    });\n                // signature type 3: arg1 - JSON-RPC payload(should be synchronous methods)\n                // ethereum.send(payload: JsonRpcRequest): unknown;\n                // This signature enables you to call some type of RPC methods synchronously\n                default:\n                    return this.sendAsync(methodOrPayload);\n            }\n        });\n    }\n    // DEPRECATED API: see https://docs.metamask.io/guide/ethereum-provider.html#legacy-methods implementation\n    // web3 v1.x BatchRequest still depends on it so we need to implement anyway \\_()_/\n    sendAsync(payload, callback) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const separateRequests = (payload) => {\n                return payload.reduce((acc, request) => {\n                    var _a;\n                    if (request.method === 'eth_sendTransaction') {\n                        acc.sendRequests.push((_a = request.params) === null || _a === void 0 ? void 0 : _a[0]);\n                    }\n                    else {\n                        acc.otherRequests.push(this.request(request));\n                    }\n                    return acc;\n                }, { sendRequests: [], otherRequests: [] });\n            };\n            function createBaseResponse(item) {\n                return {\n                    id: String(item.id),\n                    jsonrpc: '2.0',\n                    method: item.method,\n                };\n            }\n            function processResponses(payload, responses) {\n                const processedResponses = [];\n                let responseIndex = 1;\n                payload.forEach((item) => {\n                    const baseResponse = createBaseResponse(item);\n                    if (item.method === 'eth_sendTransaction') {\n                        baseResponse.result = responses[0].value;\n                        baseResponse.error =\n                            responses[0].status !== 'fulfilled'\n                                ? responses[0].reason\n                                : undefined;\n                    }\n                    else {\n                        if (responseIndex < responses.length) {\n                            baseResponse.result = responses[responseIndex].value;\n                            baseResponse.error =\n                                responses[responseIndex].status !== 'fulfilled'\n                                    ? responses[responseIndex].reason\n                                    : undefined;\n                            responseIndex++;\n                        }\n                    }\n                    processedResponses.push(baseResponse);\n                });\n                return processedResponses;\n            }\n            const handleRequest = new Promise((resolve) => {\n                // web3 v1.x concat batched JSON-RPC requests to an array, handle it here\n                if (Array.isArray(payload)) {\n                    const { sendRequests, otherRequests } = separateRequests(payload);\n                    // collect transactions and send batch with custom method\n                    const batchReqPayload = {\n                        method: 'wallet_sendMultiCallTransaction',\n                        params: [sendRequests, false],\n                    };\n                    const isSendRequestsEmpty = sendRequests.length === 0;\n                    const idBase = Math.floor(Math.random() * 10000);\n                    const allPromise = isSendRequestsEmpty\n                        ? [...otherRequests]\n                        : [this.request(batchReqPayload), ...otherRequests];\n                    // resolve response when all request are executed\n                    Promise.allSettled(allPromise)\n                        .then((responses) => {\n                        if (isSendRequestsEmpty) {\n                            return resolve(responses.map((response, index) => {\n                                var _a;\n                                return {\n                                    id: String(((_a = payload[index]) === null || _a === void 0 ? void 0 : _a.id) || idBase + index + 1),\n                                    jsonrpc: '2.0',\n                                    method: payload[index].method,\n                                    result: response.status === 'fulfilled'\n                                        ? response.value\n                                        : undefined,\n                                    error: response.status !== 'fulfilled'\n                                        ? response.reason\n                                        : undefined,\n                                };\n                            }));\n                        }\n                        const originalLengthResponse = processResponses(payload, responses);\n                        return resolve(originalLengthResponse);\n                    })\n                        .catch((error) => {\n                        throw dist.ethErrors.rpc.internal(error === null || error === void 0 ? void 0 : error.message);\n                    });\n                }\n                else {\n                    this.request(Object.assign(Object.assign({}, payload), { id: Number(payload.id) })).then(resolve);\n                }\n            });\n            // execute callback or return promise, depdends on callback arg given or not\n            if (typeof callback === 'function') {\n                handleRequest\n                    .then((data) => {\n                    return callback(null, data);\n                })\n                    .catch((error) => callback(error));\n            }\n            else {\n                return handleRequest;\n            }\n        });\n    }\n    /**\n     * Sending userOperation using Blocto SDK.\n     * @param {IUserOperation} userOp - userOperation object\n     * @remarks No need to include nonce, initCode, and signature as parameters when using BloctoSDK to send userOperation.\n     * These parameters will be ignored.\n     * @returns {Promise<string>} - userOperation hash\n     */\n    sendUserOperation(userOp) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.request({\n                method: 'eth_sendUserOperation',\n                params: [userOp],\n            });\n        });\n    }\n    request(payload) {\n        var _a, _b, _c, _d, _e, _f, _g, _h;\n        return __awaiter(this, void 0, void 0, function* () {\n            // web3.js v4 batch entry point\n            if (Array.isArray(payload)) {\n                return this.sendAsync(payload);\n            }\n            if (!(payload === null || payload === void 0 ? void 0 : payload.method))\n                throw dist.ethErrors.rpc.invalidRequest();\n            const { blockchainName, switchableNetwork, sessionKeyEnv } = yield __classPrivateFieldGet(this, _EthereumProvider_instances, \"m\", _EthereumProvider_getBloctoProperties).call(this);\n            if ((_a = this.existedSDK) === null || _a === void 0 ? void 0 : _a.isBlocto) {\n                if (payload.method === 'wallet_switchEthereumChain') {\n                    if (!((_c = (_b = payload === null || payload === void 0 ? void 0 : payload.params) === null || _b === void 0 ? void 0 : _b[0]) === null || _c === void 0 ? void 0 : _c.chainId)) {\n                        throw dist.ethErrors.rpc.invalidParams();\n                    }\n                    return this.existedSDK.request(payload).then(() => {\n                        var _a, _b, _c;\n                        this.networkVersion = `${parseChainId((_a = payload === null || payload === void 0 ? void 0 : payload.params) === null || _a === void 0 ? void 0 : _a[0].chainId)}`;\n                        this.chainId = `0x${parseChainId((_b = payload === null || payload === void 0 ? void 0 : payload.params) === null || _b === void 0 ? void 0 : _b[0].chainId).toString(16)}`;\n                        this.rpc = (_c = switchableNetwork === null || switchableNetwork === void 0 ? void 0 : switchableNetwork[this.networkVersion]) === null || _c === void 0 ? void 0 : _c.rpc_url;\n                        return null;\n                    });\n                }\n                return this.existedSDK.request(payload);\n            }\n            // method that doesn't require user to be connected\n            switch (payload.method) {\n                case 'eth_chainId': {\n                    return this.chainId;\n                }\n                case 'net_version': {\n                    return this.networkVersion;\n                }\n                case 'wallet_addEthereumChain': {\n                    return this.loadSwitchableNetwork((payload === null || payload === void 0 ? void 0 : payload.params) || []);\n                }\n                case 'eth_blockNumber':\n                case 'web3_clientVersion':\n                case 'eth_call': {\n                    const response = yield this.handleReadRequests(payload);\n                    if (!response || (response && !response.result && response.error)) {\n                        const errorMessage = ((_d = response === null || response === void 0 ? void 0 : response.error) === null || _d === void 0 ? void 0 : _d.message)\n                            ? response.error.message\n                            : 'Request failed';\n                        throw dist.ethErrors.rpc.internal(errorMessage);\n                    }\n                    if (typeof (payload === null || payload === void 0 ? void 0 : payload.callback) === 'function') {\n                        payload.callback(null, response.result);\n                    }\n                    return response.result;\n                }\n                case 'wallet_switchEthereumChain': {\n                    return this.handleSwitchChain((_f = (_e = payload === null || payload === void 0 ? void 0 : payload.params) === null || _e === void 0 ? void 0 : _e[0]) === null || _f === void 0 ? void 0 : _f.chainId);\n                }\n                case 'wallet_disconnect': {\n                    return this.handleDisconnect();\n                }\n                case 'eth_accounts': {\n                    return getEvmAddress(sessionKeyEnv, blockchainName) || [];\n                }\n            }\n            // Method that requires user to be connected\n            if (!getEvmAddress(sessionKeyEnv, blockchainName)) {\n                const email = (_g = payload === null || payload === void 0 ? void 0 : payload.params) === null || _g === void 0 ? void 0 : _g[0];\n                if (payload.method === 'eth_requestAccounts' && isEmail(email)) {\n                    yield this.enable(email);\n                }\n                else {\n                    yield this.enable();\n                }\n            }\n            try {\n                let response = null;\n                let result = null;\n                switch (payload.method) {\n                    case 'eth_requestAccounts': {\n                        result = yield this.fetchAccounts();\n                        break;\n                    }\n                    // eslint-disable-next-line\n                    case 'eth_coinbase': {\n                        result = (_h = getEvmAddress(sessionKeyEnv, blockchainName)) === null || _h === void 0 ? void 0 : _h[0];\n                        break;\n                    }\n                    case 'eth_signTypedData_v3':\n                    case 'eth_signTypedData':\n                    case 'eth_signTypedData_v4':\n                    case 'personal_sign': {\n                        result = yield this.handleSign(payload);\n                        break;\n                    }\n                    case 'eth_sign':\n                        throw dist.ethErrors.rpc.methodNotFound('Method Not Supported: eth_sign has been disabled');\n                    case 'eth_sendTransaction':\n                        result = yield this.handleSendTransaction(payload);\n                        break;\n                    case 'wallet_sendMultiCallTransaction':\n                        result = yield this.handleSendBatchTransaction(payload);\n                        break;\n                    case 'eth_signTransaction':\n                    case 'eth_sendRawTransaction': {\n                        throw dist.ethErrors.rpc.methodNotSupported('Method Not Supported: ' + payload.method);\n                    }\n                    case 'eth_sendUserOperation':\n                        result = yield this.handleSendUserOperation(payload);\n                        break;\n                    case 'eth_estimateUserOperationGas':\n                    case 'eth_getUserOperationByHash':\n                    case 'eth_getUserOperationReceipt':\n                    case 'eth_supportedEntryPoints':\n                        result = yield this.handleBundler(payload);\n                        break;\n                    default:\n                        response = yield this.handleReadRequests(payload);\n                }\n                if (response && !response.result && response.error) {\n                    const errorMessage = response.error.message\n                        ? response.error.message\n                        : 'Request failed';\n                    throw dist.ethErrors.rpc.internal(errorMessage);\n                }\n                if (response)\n                    return response.result;\n                return result;\n            }\n            catch (error) {\n                throw dist.ethErrors.rpc.internal(error === null || error === void 0 ? void 0 : error.message);\n            }\n        });\n    }\n    bloctoApi(url, options) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            const { walletServer, blockchainName, sessionKeyEnv } = yield __classPrivateFieldGet(this, _EthereumProvider_instances, \"m\", _EthereumProvider_getBloctoProperties).call(this);\n            const sessionId = ((_a = getAccountStorage(sessionKeyEnv)) === null || _a === void 0 ? void 0 : _a.code) || '';\n            if (!sessionId) {\n                throw dist.ethErrors.provider.unauthorized();\n            }\n            return fetch(`${walletServer}/api/${blockchainName}${url}`, Object.assign({ headers: {\n                    'Content-Type': 'application/json',\n                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                    'Blocto-Application-Identifier': this.appId,\n                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                    'Blocto-Session-Identifier': sessionId,\n                } }, options))\n                .then((response) => responseSessionGuard(response, sessionKeyEnv, () => {\n                var _a;\n                (_a = this.eventListeners) === null || _a === void 0 ? void 0 : _a.disconnect.forEach((listener) => listener(dist.ethErrors.provider.disconnected()));\n            }))\n                .catch((e) => {\n                if ((e === null || e === void 0 ? void 0 : e.error_code) === 'unsupported_method') {\n                    throw dist.ethErrors.rpc.methodNotSupported('Method Not Supported: ' + e.message);\n                }\n                else {\n                    throw dist.ethErrors.rpc.server({\n                        code: -32005,\n                        message: `Blocto server error: ${e.message}`,\n                    });\n                }\n            });\n        });\n    }\n    responseListener(frame, objectKey) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const { walletServer } = yield __classPrivateFieldGet(this, _EthereumProvider_instances, \"m\", _EthereumProvider_getBloctoProperties).call(this);\n            return new Promise((resolve, reject) => addSelfRemovableHandler('message', (event, removeEventListener) => {\n                const e = event;\n                if (e.origin === walletServer &&\n                    e.data.type === 'ETH:FRAME:RESPONSE') {\n                    if (e.data.status === 'APPROVED') {\n                        removeEventListener();\n                        detatchFrame(frame);\n                        resolve(e.data[objectKey]);\n                    }\n                    if (e.data.status === 'DECLINED') {\n                        removeEventListener();\n                        detatchFrame(frame);\n                        if (e.data.errorCode === 'incorrect_session_id') {\n                            this.handleDisconnect();\n                        }\n                        reject(dist.ethErrors.provider.userRejectedRequest(e.data.errorMessage));\n                    }\n                }\n                if (e.data.type === 'ETH:FRAME:CLOSE') {\n                    removeEventListener();\n                    detatchFrame(frame);\n                    reject(dist.ethErrors.provider.userRejectedRequest('User declined the request'));\n                }\n            }));\n        });\n    }\n    setIframe(url, blockchain) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (typeof window === 'undefined') {\n                throw dist.ethErrors.provider.custom({\n                    code: 1001,\n                    message: 'Blocto SDK only works in browser environment',\n                });\n            }\n            const { walletServer, blockchainName } = yield __classPrivateFieldGet(this, _EthereumProvider_instances, \"m\", _EthereumProvider_getBloctoProperties).call(this);\n            const frame = createFrame(`${walletServer}/${this.appId}/${blockchain || blockchainName}${url}`);\n            attachFrame(frame);\n            return frame;\n        });\n    }\n    // eip-1102 alias\n    // DEPRECATED API: https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1102.md\n    enable(email) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            if (typeof window === 'undefined') {\n                throw dist.ethErrors.provider.custom({\n                    code: 1001,\n                    message: 'Blocto SDK only works in browser environment',\n                });\n            }\n            const { walletServer, blockchainName, sessionKeyEnv } = yield __classPrivateFieldGet(this, _EthereumProvider_instances, \"m\", _EthereumProvider_getBloctoProperties).call(this);\n            if ((_a = this.existedSDK) === null || _a === void 0 ? void 0 : _a.isBlocto) {\n                if (this.existedSDK.chainId !== this.chainId) {\n                    yield this.existedSDK.request({\n                        method: 'wallet_addEthereumChain',\n                        params: [{ chainId: this.chainId }],\n                    });\n                    yield this.existedSDK.request({\n                        method: 'wallet_switchEthereumChain',\n                        params: [{ chainId: this.chainId }],\n                    });\n                    setEvmAddress(sessionKeyEnv, blockchainName, [this.existedSDK.address]);\n                }\n                return new Promise((resolve, reject) => \n                // add a small delay to make sure the network has been switched\n                setTimeout(() => this.existedSDK.enable().then(resolve).catch(reject), 10));\n            }\n            const address = getEvmAddress(sessionKeyEnv, blockchainName);\n            if (address) {\n                return new Promise((resolve) => {\n                    resolve(address);\n                });\n            }\n            const params = new URLSearchParams();\n            params.set('l6n', window.location.origin);\n            params.set('v', SDK_VERSION);\n            params.set('q', `${window.location.pathname}${window.location.search}`);\n            const emailParam = email && isEmail(email) ? `/${email}` : '';\n            const loginFrame = yield this.setIframe(`/authn${emailParam}?${params.toString()}`);\n            return new Promise((resolve, reject) => {\n                addSelfRemovableHandler('message', (event, removeListener) => {\n                    var _a, _b;\n                    const e = event;\n                    if (e.origin === walletServer) {\n                        if (e.data.type === 'ETH:FRAME:RESPONSE') {\n                            removeListener();\n                            detatchFrame(loginFrame);\n                            (_a = this.eventListeners) === null || _a === void 0 ? void 0 : _a.connect.forEach((listener) => listener({ chainId: this.chainId }));\n                            setAccountStorage(sessionKeyEnv, {\n                                code: e.data.code,\n                                evm: {\n                                    [blockchainName]: [e.data.addr],\n                                },\n                            }, e.data.exp);\n                            if ((_b = e.data) === null || _b === void 0 ? void 0 : _b.isAccountChanged) {\n                                postMessage({\n                                    originChain: CHAIN.ETHEREUM,\n                                    type: 'BLOCTO_SDK:ACCOUNT_CHANGED',\n                                });\n                            }\n                            addSelfRemovableHandler('message', (event, removeListener) => {\n                                var _a, _b, _c;\n                                const messageEvent = event;\n                                const isAccountChanged = ((_a = messageEvent.data) === null || _a === void 0 ? void 0 : _a.type) === 'BLOCTO_SDK:ACCOUNT_CHANGED';\n                                const isAnotherChain = ((_b = messageEvent.data) === null || _b === void 0 ? void 0 : _b.originChain) !== CHAIN.ETHEREUM;\n                                if (isAccountChanged) {\n                                    (_c = this.eventListeners) === null || _c === void 0 ? void 0 : _c.accountsChanged.forEach((listener) => listener([e.data.addr]));\n                                }\n                                if (isAccountChanged && isAnotherChain) {\n                                    this.handleDisconnect();\n                                    removeListener();\n                                }\n                            });\n                            resolve([e.data.addr]);\n                        }\n                        if (e.data.type === 'ETH:FRAME:CLOSE') {\n                            removeListener();\n                            detatchFrame(loginFrame);\n                            reject(dist.ethErrors.provider.userRejectedRequest());\n                        }\n                    }\n                });\n            });\n        });\n    }\n    fetchAccounts() {\n        return __awaiter(this, void 0, void 0, function* () {\n            __classPrivateFieldGet(this, _EthereumProvider_instances, \"m\", _EthereumProvider_checkNetworkMatched).call(this);\n            const { blockchainName, sessionKeyEnv } = yield __classPrivateFieldGet(this, _EthereumProvider_instances, \"m\", _EthereumProvider_getBloctoProperties).call(this);\n            const { accounts } = yield this.bloctoApi(`/accounts`);\n            setEvmAddress(sessionKeyEnv, blockchainName, accounts);\n            return accounts;\n        });\n    }\n    handleReadRequests(payload) {\n        return __awaiter(this, void 0, void 0, function* () {\n            __classPrivateFieldGet(this, _EthereumProvider_instances, \"m\", _EthereumProvider_checkNetworkMatched).call(this);\n            return fetch(this.rpc, {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                },\n                body: JSON.stringify(Object.assign({ id: 1, jsonrpc: '2.0' }, payload)),\n            })\n                .then((response) => response.json())\n                .catch((e) => {\n                throw dist.ethErrors.rpc.internal(e);\n            });\n        });\n    }\n    handleSign({ method, params }) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let message = '';\n            if (Array.isArray(params)) {\n                if (method === 'personal_sign') {\n                    message = isHexString(params[0])\n                        ? params[0].slice(2)\n                        : utf8ToHex(params[0]);\n                }\n                else if ([\n                    'eth_signTypedData',\n                    'eth_signTypedData_v3',\n                    'eth_signTypedData_v4',\n                ].includes(method)) {\n                    message = params[1];\n                    const { domain } = JSON.parse(message);\n                    if (isHexString(domain.chainId)) {\n                        throw dist.ethErrors.rpc.invalidParams(`Provided chainId \"${domain.chainId}\" must be a number`);\n                    }\n                    if (parseChainId(domain.chainId) !== parseChainId(this.chainId)) {\n                        throw dist.ethErrors.rpc.invalidParams(`Provided chainId \"${domain.chainId}\" must match the active chainId \"${parseChainId(this.chainId)}\"`);\n                    }\n                }\n            }\n            __classPrivateFieldGet(this, _EthereumProvider_instances, \"m\", _EthereumProvider_checkNetworkMatched).call(this);\n            const { signatureId } = yield this.bloctoApi(`/user-signature`, { method: 'POST', body: JSON.stringify({ method, message }) });\n            const signFrame = yield this.setIframe(`/user-signature/${signatureId}`);\n            return this.responseListener(signFrame, 'signature');\n        });\n    }\n    handleSwitchChain(targetChainId) {\n        var _a, _b;\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!targetChainId) {\n                throw dist.ethErrors.rpc.invalidParams();\n            }\n            const { walletServer, blockchainName, sessionKeyEnv, switchableNetwork } = yield __classPrivateFieldGet(this, _EthereumProvider_instances, \"m\", _EthereumProvider_getBloctoProperties).call(this);\n            const oldAccount = (_a = getEvmAddress(sessionKeyEnv, blockchainName)) === null || _a === void 0 ? void 0 : _a[0];\n            const oldChainId = parseChainId(this.chainId);\n            const newChainId = parseChainId(targetChainId);\n            if (oldChainId === newChainId) {\n                return null;\n            }\n            if (!switchableNetwork[newChainId]) {\n                throw dist.ethErrors.provider.custom({\n                    code: 4902,\n                    message: `Unrecognized chain ID \"${newChainId}\". Try adding the chain using wallet_addEthereumChain first.`,\n                });\n            }\n            this.networkVersion = `${newChainId}`;\n            this.chainId = `0x${newChainId.toString(16)}`;\n            this.rpc = switchableNetwork[newChainId].rpc_url;\n            this._blocto = Object.assign(Object.assign({}, this._blocto), { blockchainName: '', networkType: '' });\n            if (!oldAccount) {\n                (_b = this.eventListeners) === null || _b === void 0 ? void 0 : _b.chainChanged.forEach((listener) => listener(this.chainId));\n                yield __classPrivateFieldGet(this, _EthereumProvider_instances, \"m\", _EthereumProvider_getBloctoProperties).call(this);\n                return null;\n            }\n            // Go login flow when switching to a different blocto server\n            if (switchableNetwork[newChainId].wallet_web_url !==\n                switchableNetwork[oldChainId].wallet_web_url) {\n                return this.enable()\n                    .then(([newAccount]) => {\n                    var _a;\n                    if (newAccount !== oldAccount) {\n                        (_a = this.eventListeners) === null || _a === void 0 ? void 0 : _a.accountsChanged.forEach((listener) => listener([newAccount]));\n                    }\n                    this.eventListeners.chainChanged.forEach((listener) => listener(this.chainId));\n                    return null;\n                })\n                    .catch((error) => {\n                    this.networkVersion = `${oldChainId}`;\n                    this.chainId = `0x${oldChainId.toString(16)}`;\n                    this.rpc = switchableNetwork[oldChainId].rpc_url;\n                    this._blocto = Object.assign(Object.assign({}, this._blocto), { blockchainName: '', networkType: '' });\n                    __classPrivateFieldGet(this, _EthereumProvider_instances, \"m\", _EthereumProvider_getBloctoProperties).call(this);\n                    throw error;\n                });\n            }\n            const switchChainFrame = yield this.setIframe(`/switch-chain?to=${switchableNetwork[newChainId].name}`, switchableNetwork[oldChainId].name);\n            return new Promise((resolve, reject) => {\n                addSelfRemovableHandler('message', (event, removeListener) => {\n                    var _a, _b, _c, _d, _e, _f, _g, _h;\n                    const e = event;\n                    if (e.origin === walletServer) {\n                        if (e.data.type === 'ETH:FRAME:RESPONSE') {\n                            removeListener();\n                            detatchFrame(switchChainFrame);\n                            if (((_a = e.data) === null || _a === void 0 ? void 0 : _a.addr) && oldAccount) {\n                                setAccountStorage(sessionKeyEnv, {\n                                    code: (_b = e.data) === null || _b === void 0 ? void 0 : _b.code,\n                                    evm: {\n                                        [switchableNetwork[newChainId].name]: [e.data.addr],\n                                    },\n                                }, (_c = e.data) === null || _c === void 0 ? void 0 : _c.exp);\n                                if (e.data.addr !== oldAccount) {\n                                    (_d = this.eventListeners) === null || _d === void 0 ? void 0 : _d.accountsChanged.forEach((listener) => listener([e.data.addr]));\n                                }\n                            }\n                            (_e = this.eventListeners) === null || _e === void 0 ? void 0 : _e.chainChanged.forEach((listener) => listener(this.chainId));\n                            __classPrivateFieldGet(this, _EthereumProvider_instances, \"m\", _EthereumProvider_getBloctoProperties).call(this);\n                            resolve(null);\n                        }\n                        if (e.data.type === 'ETH:FRAME:CLOSE') {\n                            removeListener();\n                            detatchFrame(switchChainFrame);\n                            if ((_f = e.data) === null || _f === void 0 ? void 0 : _f.hasApprovedSwitchChain) {\n                                (_g = this.eventListeners) === null || _g === void 0 ? void 0 : _g.chainChanged.forEach((listener) => listener(this.chainId));\n                                removeAllEvmAddress(sessionKeyEnv);\n                                (_h = this.eventListeners) === null || _h === void 0 ? void 0 : _h.disconnect.forEach((listener) => listener(dist.ethErrors.provider.disconnected()));\n                                __classPrivateFieldGet(this, _EthereumProvider_instances, \"m\", _EthereumProvider_getBloctoProperties).call(this);\n                                resolve(null);\n                            }\n                            else {\n                                this.networkVersion = `${oldChainId}`;\n                                this.chainId = `0x${oldChainId.toString(16)}`;\n                                this.rpc = switchableNetwork[oldChainId].rpc_url;\n                                this._blocto = Object.assign(Object.assign({}, this._blocto), { blockchainName: '', networkType: '' });\n                                __classPrivateFieldGet(this, _EthereumProvider_instances, \"m\", _EthereumProvider_getBloctoProperties).call(this);\n                                reject(dist.ethErrors.provider.userRejectedRequest());\n                            }\n                        }\n                    }\n                });\n            });\n        });\n    }\n    handleSendTransaction(payload) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            __classPrivateFieldGet(this, _EthereumProvider_instances, \"m\", _EthereumProvider_checkNetworkMatched).call(this);\n            const { isValid, invalidMsg } = isValidTransaction((_a = payload.params) === null || _a === void 0 ? void 0 : _a[0]);\n            if (!isValid) {\n                throw dist.ethErrors.rpc.invalidParams(invalidMsg);\n            }\n            return __classPrivateFieldGet(this, _EthereumProvider_instances, \"m\", _EthereumProvider_createAuthzFrame).call(this, payload.params);\n        });\n    }\n    handleSendBatchTransaction(payload) {\n        return __awaiter(this, void 0, void 0, function* () {\n            __classPrivateFieldGet(this, _EthereumProvider_instances, \"m\", _EthereumProvider_checkNetworkMatched).call(this);\n            let originalParams, revertFlag;\n            if (Array.isArray(payload.params) && payload.params.length >= 2) {\n                [originalParams, revertFlag] = payload.params;\n            }\n            else {\n                originalParams = payload.params;\n                revertFlag = false;\n            }\n            const revert = revertFlag ? revertFlag : false;\n            const { isValid, invalidMsg } = isValidTransactions(originalParams);\n            if (!isValid) {\n                throw dist.ethErrors.rpc.invalidParams(invalidMsg);\n            }\n            return __classPrivateFieldGet(this, _EthereumProvider_instances, \"m\", _EthereumProvider_createAuthzFrame).call(this, originalParams, revert);\n        });\n    }\n    handleSendUserOperation(payload) {\n        return __awaiter(this, void 0, void 0, function* () {\n            __classPrivateFieldGet(this, _EthereumProvider_instances, \"m\", _EthereumProvider_checkNetworkMatched).call(this);\n            const { authorizationId } = yield this.bloctoApi(`/user-operation`, {\n                method: 'POST',\n                body: JSON.stringify(payload.params),\n            });\n            const userOPFrame = yield this.setIframe(`/user-operation/${authorizationId}`);\n            return this.responseListener(userOPFrame, 'userOpHash');\n        });\n    }\n    handleBundler(payload) {\n        return __awaiter(this, void 0, void 0, function* () {\n            __classPrivateFieldGet(this, _EthereumProvider_instances, \"m\", _EthereumProvider_checkNetworkMatched).call(this);\n            return this.bloctoApi(`/rpc/bundler`, {\n                method: 'POST',\n                body: JSON.stringify(Object.assign({ id: 1, jsonrpc: '2.0' }, payload)),\n            });\n        });\n    }\n    handleDisconnect() {\n        var _a, _b;\n        return __awaiter(this, void 0, void 0, function* () {\n            if ((_a = this.existedSDK) === null || _a === void 0 ? void 0 : _a.isBlocto) {\n                return this.existedSDK.request({ method: 'wallet_disconnect' });\n            }\n            const { sessionKeyEnv } = yield __classPrivateFieldGet(this, _EthereumProvider_instances, \"m\", _EthereumProvider_getBloctoProperties).call(this);\n            removeAllEvmAddress(sessionKeyEnv);\n            (_b = this.eventListeners) === null || _b === void 0 ? void 0 : _b.disconnect.forEach((listener) => listener(dist.ethErrors.provider.disconnected()));\n        });\n    }\n    loadSwitchableNetwork(networkList) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // setup switchable list if user set networkList\n            if (networkList === null || networkList === void 0 ? void 0 : networkList.length) {\n                const listToAdd = networkList.map(({ chainId, rpcUrls }) => {\n                    if (!chainId)\n                        throw dist.ethErrors.rpc.invalidParams('Empty chainId');\n                    const parsedChainId = `${parseChainId(chainId)}`;\n                    // skip if chainId already exists\n                    if (this._blocto.switchableNetwork[parsedChainId])\n                        return null;\n                    const parsedRpc = (rpcUrls === null || rpcUrls === void 0 ? void 0 : rpcUrls[0]) || ETH_RPC_LIST[parsedChainId];\n                    if (!parsedRpc)\n                        throw dist.ethErrors.rpc.invalidParams('rpcUrls required');\n                    return __classPrivateFieldGet(this, _EthereumProvider_instances, \"m\", _EthereumProvider_addToSwitchable).call(this, {\n                        chainId: parsedChainId,\n                        rpcUrls: [parsedRpc],\n                    });\n                });\n                return Promise.all(listToAdd).then(() => null);\n            }\n            else {\n                throw dist.ethErrors.rpc.invalidParams('Empty networkList');\n            }\n        });\n    }\n    supportChainList() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const supportNetworkList = yield getEvmSupport().catch((e) => {\n                throw dist.ethErrors.provider.custom({\n                    code: 1001,\n                    message: `Get blocto server failed: ${e.message}`,\n                });\n            });\n            return Object.keys(supportNetworkList).map((chainId) => {\n                const { display_name } = supportNetworkList[chainId];\n                return {\n                    chainId,\n                    chainName: display_name,\n                };\n            });\n        });\n    }\n    on(event, listener) {\n        var _a;\n        if ((_a = this.existedSDK) === null || _a === void 0 ? void 0 : _a.isBlocto)\n            this.existedSDK.on(event, listener);\n        super.on(event, listener);\n    }\n    removeListener(event, listener) {\n        var _a;\n        if ((_a = this.existedSDK) === null || _a === void 0 ? void 0 : _a.isBlocto)\n            this.existedSDK.off(event, listener);\n        super.removeListener(event, listener);\n    }\n}\n_EthereumProvider_instances = new WeakSet(), _EthereumProvider_getBloctoProperties = function _EthereumProvider_getBloctoProperties() {\n    var _a, _b;\n    return __awaiter(this, void 0, void 0, function* () {\n        if ((_a = this._blocto) === null || _a === void 0 ? void 0 : _a.unloadedNetwork) {\n            yield this.loadSwitchableNetwork(this._blocto.unloadedNetwork);\n            delete this._blocto.unloadedNetwork;\n        }\n        if (this._blocto.sessionKeyEnv &&\n            this._blocto.walletServer &&\n            this._blocto.blockchainName &&\n            this._blocto.networkType &&\n            this._blocto.switchableNetwork) {\n            return this._blocto;\n        }\n        const supportNetworkList = yield getEvmSupport().catch((e) => {\n            throw dist.ethErrors.provider.custom({\n                code: 1001,\n                message: `Get blocto server failed: ${e.message}`,\n            });\n        });\n        const { chain_id, name, network_type, blocto_service_environment, display_name, } = (_b = supportNetworkList[this.networkVersion]) !== null && _b !== void 0 ? _b : {};\n        if (!chain_id) {\n            throw dist.ethErrors.provider.unsupportedMethod(`Get support chain failed: ${this.networkVersion} might not be supported yet.`);\n        }\n        const walletServer = this.injectedWalletServer ||\n            ETH_ENV_WALLET_SERVER_MAPPING[blocto_service_environment];\n        this._blocto = Object.assign(Object.assign({}, this._blocto), { sessionKeyEnv: ETH_SESSION_KEY_MAPPING[blocto_service_environment], walletServer, blockchainName: name, networkType: network_type, switchableNetwork: Object.assign(Object.assign({}, this._blocto.switchableNetwork), { [chain_id]: {\n                    name,\n                    display_name,\n                    network_type,\n                    wallet_web_url: walletServer,\n                    rpc_url: this.rpc,\n                } }) });\n        return this._blocto;\n    });\n}, _EthereumProvider_addToSwitchable = function _EthereumProvider_addToSwitchable({ chainId, rpcUrls, }) {\n    var _a;\n    return __awaiter(this, void 0, void 0, function* () {\n        yield __classPrivateFieldGet(this, _EthereumProvider_instances, \"m\", _EthereumProvider_getBloctoProperties).call(this);\n        const supportNetworkList = yield getEvmSupport().catch((e) => {\n            throw dist.ethErrors.provider.custom({\n                code: 1001,\n                message: `Get blocto server failed: ${e.message}`,\n            });\n        });\n        const { chain_id, name, display_name, network_type, blocto_service_environment, } = (_a = supportNetworkList[chainId]) !== null && _a !== void 0 ? _a : {};\n        if (!chain_id)\n            throw dist.ethErrors.provider.unsupportedMethod(`Get support chain failed: ${chainId} might not be supported yet.`);\n        const wallet_web_url = ETH_ENV_WALLET_SERVER_MAPPING[blocto_service_environment];\n        this._blocto.switchableNetwork[chain_id] = {\n            name,\n            display_name,\n            network_type,\n            wallet_web_url,\n            rpc_url: rpcUrls[0],\n        };\n    });\n}, _EthereumProvider_checkNetworkMatched = function _EthereumProvider_checkNetworkMatched() {\n    var _a;\n    if (((_a = this.existedSDK) === null || _a === void 0 ? void 0 : _a.isBlocto) &&\n        parseChainId(this.existedSDK.chainId) !== parseChainId(this.chainId)) {\n        throw dist.ethErrors.provider.chainDisconnected();\n    }\n}, _EthereumProvider_createAuthzFrame = function _EthereumProvider_createAuthzFrame(params, revert = true) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const { authorizationId } = yield this.bloctoApi(`/authz`, {\n            method: 'POST',\n            body: JSON.stringify([params, revert]),\n        });\n        const iframeParams = new URLSearchParams();\n        iframeParams.set('l6n', window.location.origin);\n        iframeParams.set('q', `${window.location.pathname}${window.location.search}`);\n        const authzFrame = yield this.setIframe(`/authz/${authorizationId}?${iframeParams.toString()}`);\n        return this.responseListener(authzFrame, 'txHash');\n    });\n};\n\nconst checkMessagePayloadFormat = (payload) => {\n    var _a, _b;\n    const formattedPayload = Object.assign({}, payload);\n    const { message, nonce, address, application, chainId } = payload;\n    if (typeof message !== 'string') {\n        formattedPayload.message = (_a = String(message)) !== null && _a !== void 0 ? _a : '';\n    }\n    if (typeof nonce !== 'string') {\n        formattedPayload.nonce = (_b = String(nonce)) !== null && _b !== void 0 ? _b : '';\n    }\n    if (address && typeof address !== 'boolean') {\n        formattedPayload.address = !!address;\n    }\n    if (application && typeof application !== 'boolean') {\n        formattedPayload.application = !!application;\n    }\n    if (chainId && typeof chainId !== 'boolean') {\n        formattedPayload.chainId = !!chainId;\n    }\n    return formattedPayload;\n};\nclass AptosProvider extends BloctoProvider {\n    get existedSDK() {\n        if (typeof window === 'undefined')\n            return undefined;\n        return window.bloctoAptos;\n    }\n    constructor({ chainId, server, appId }) {\n        super();\n        this.publicKey = [];\n        this.authKey = '';\n        this.off = this.removeListener;\n        invariant(chainId, \"'chainId' is required\");\n        invariant(appId, 'It is necessary to interact with Blocto wallet via your app id. Please visit https://developers.blocto.app for more details.');\n        this.chainId = chainId;\n        this.networkName = APT_CHAIN_ID_NAME_MAPPING[chainId];\n        this.api = APT_CHAIN_ID_RPC_MAPPING[chainId];\n        this.sessionKey = APT_SESSION_KEY_MAPPING[chainId];\n        const defaultServer = APT_CHAIN_ID_SERVER_MAPPING[chainId];\n        this.appId = appId || DEFAULT_APP_ID;\n        this.server = server || defaultServer || '';\n    }\n    get publicAccount() {\n        var _a;\n        return {\n            address: ((_a = getChainAddress(this.sessionKey, CHAIN.APTOS)) === null || _a === void 0 ? void 0 : _a[0]) || null,\n            publicKey: this.publicKey.length ? this.publicKey : null,\n            // @todo: provide authkey\n            authKey: null,\n            minKeysRequired: 2,\n        };\n    }\n    network() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return {\n                name: this.networkName,\n                api: this.api,\n                chainId: this.chainId.toString(),\n            };\n        });\n    }\n    isConnected() {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            return !!((_a = getChainAddress(this.sessionKey, CHAIN.APTOS)) === null || _a === void 0 ? void 0 : _a.length);\n        });\n    }\n    signTransaction(transaction) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.existedSDK) {\n                return this.existedSDK.signTransaction(transaction);\n            }\n            const hasConnected = yield this.isConnected();\n            if (!hasConnected) {\n                yield this.connect();\n            }\n            if (!((_a = getChainAddress(this.sessionKey, CHAIN.APTOS)) === null || _a === void 0 ? void 0 : _a.length)) {\n                throw new Error('Fail to get account');\n            }\n            throw new Error('signTransaction method not supported.');\n        });\n    }\n    disconnect() {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.existedSDK) {\n                yield this.existedSDK.disconnect();\n                return;\n            }\n            removeChainAddress(this.sessionKey, CHAIN.APTOS);\n            (_a = this.eventListeners) === null || _a === void 0 ? void 0 : _a.disconnect.forEach((listener) => listener({\n                code: 4900,\n                message: 'Wallet disconnected',\n            }));\n        });\n    }\n    signAndSubmitTransaction(transaction, txOptions = {}) {\n        var _a, _b;\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.existedSDK) {\n                return this.existedSDK.signAndSubmitTransaction(transaction, txOptions);\n            }\n            const hasConnected = yield this.isConnected();\n            if (!hasConnected) {\n                yield this.connect();\n            }\n            if (!((_a = getChainAddress(this.sessionKey, CHAIN.APTOS)) === null || _a === void 0 ? void 0 : _a.length)) {\n                throw new Error('Fail to get account');\n            }\n            const sessionId = ((_b = getAccountStorage(this.sessionKey)) === null || _b === void 0 ? void 0 : _b.code) || '';\n            const { authorizationId } = yield fetch(`${this.server}/api/aptos/authz`, {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                    // We already check the existence in the constructor\n                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                    'Blocto-Application-Identifier': this.appId,\n                    'Blocto-Session-Identifier': sessionId,\n                },\n                body: JSON.stringify(Object.assign(Object.assign({}, transaction), txOptions)),\n            }).then((response) => responseSessionGuard(response, this.sessionKey));\n            if (typeof window === 'undefined') {\n                throw new Error('Currently only supported in browser');\n            }\n            const authzFrame = createFrame(`${this.server}/${this.appId}/aptos/authz/${authorizationId}`);\n            attachFrame(authzFrame);\n            return new Promise((resolve, reject) => addSelfRemovableHandler('message', (event, removeEventListener) => {\n                const e = event;\n                if (e.origin === this.server &&\n                    e.data.type === 'APTOS:FRAME:RESPONSE') {\n                    if (e.data.status === 'APPROVED') {\n                        removeEventListener();\n                        detatchFrame(authzFrame);\n                        resolve({ hash: e.data.txHash });\n                    }\n                    if (e.data.status === 'DECLINED') {\n                        removeEventListener();\n                        detatchFrame(authzFrame);\n                        if (e.data.errorCode === 'incorrect_session_id') {\n                            this.disconnect();\n                        }\n                        reject(new Error(e.data.errorMessage));\n                    }\n                }\n            }));\n        });\n    }\n    signMessage(payload) {\n        var _a, _b;\n        return __awaiter(this, void 0, void 0, function* () {\n            const formattedPayload = checkMessagePayloadFormat(payload);\n            if (this.existedSDK) {\n                return this.existedSDK.signMessage(formattedPayload);\n            }\n            const hasConnected = yield this.isConnected();\n            if (!hasConnected) {\n                yield this.connect();\n            }\n            if (!((_a = getChainAddress(this.sessionKey, CHAIN.APTOS)) === null || _a === void 0 ? void 0 : _a.length)) {\n                throw new Error('Fail to get account');\n            }\n            if (typeof window === 'undefined') {\n                throw new Error('Currently only supported in browser');\n            }\n            const sessionId = ((_b = getAccountStorage(this.sessionKey)) === null || _b === void 0 ? void 0 : _b.code) || '';\n            const { signatureId } = yield fetch(`${this.server}/api/aptos/user-signature`, {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                    // We already check the existence in the constructor\n                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                    'Blocto-Application-Identifier': this.appId,\n                    'Blocto-Session-Identifier': sessionId,\n                },\n                body: JSON.stringify(formattedPayload),\n            }).then((response) => responseSessionGuard(response, this.sessionKey));\n            const url = `${this.server}/${this.appId}/aptos/user-signature/${signatureId}`;\n            const signFrame = createFrame(url);\n            attachFrame(signFrame);\n            return new Promise((resolve, reject) => addSelfRemovableHandler('message', (event, removeEventListener) => {\n                const e = event;\n                if (e.origin === this.server &&\n                    e.data.type === 'APTOS:FRAME:RESPONSE') {\n                    if (e.data.status === 'APPROVED') {\n                        removeEventListener();\n                        detatchFrame(signFrame);\n                        resolve(e.data);\n                    }\n                    if (e.data.status === 'DECLINED') {\n                        removeEventListener();\n                        detatchFrame(signFrame);\n                        if (e.data.errorCode === 'incorrect_session_id') {\n                            this.disconnect();\n                        }\n                        reject(new Error(e.data.errorMessage));\n                    }\n                }\n            }));\n        });\n    }\n    connect() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.existedSDK) {\n                return new Promise((resolve, reject) => \n                // add a small delay to make sure the network has been switched\n                setTimeout(() => this.existedSDK.connect().then(resolve).catch(reject), 10));\n            }\n            return new Promise((resolve, reject) => {\n                var _a, _b;\n                if (typeof window === 'undefined') {\n                    return reject('Currently only supported in browser');\n                }\n                if ((_a = getChainAddress(this.sessionKey, CHAIN.APTOS)) === null || _a === void 0 ? void 0 : _a.length) {\n                    return resolve({\n                        address: ((_b = getChainAddress(this.sessionKey, CHAIN.APTOS)) === null || _b === void 0 ? void 0 : _b[0]) || null,\n                        publicKey: this.publicKey,\n                        authKey: null,\n                        minKeysRequired: 2,\n                    });\n                }\n                const location = encodeURIComponent(window.location.origin);\n                const loginFrame = createFrame(`${this.server}/${this.appId}/aptos/authn?l6n=${location}&v=${SDK_VERSION}}`);\n                attachFrame(loginFrame);\n                addSelfRemovableHandler('message', (event, removeListener) => __awaiter(this, void 0, void 0, function* () {\n                    var _c, _d, _e, _f;\n                    const e = event;\n                    if (e.origin === this.server) {\n                        if (e.data.type === 'APTOS:FRAME:RESPONSE') {\n                            removeListener();\n                            detatchFrame(loginFrame);\n                            setAccountStorage(this.sessionKey, {\n                                code: e.data.code,\n                                accounts: {\n                                    [CHAIN.APTOS]: [e.data.addr],\n                                },\n                            }, e.data.exp);\n                            if ((_c = e.data) === null || _c === void 0 ? void 0 : _c.isAccountChanged) {\n                                postMessage({\n                                    originChain: CHAIN.APTOS,\n                                    type: 'BLOCTO_SDK:ACCOUNT_CHANGED',\n                                });\n                            }\n                            addSelfRemovableHandler('message', (event, removeListener) => {\n                                var _a, _b;\n                                const messageEvent = event;\n                                if (((_a = messageEvent.data) === null || _a === void 0 ? void 0 : _a.type) === 'BLOCTO_SDK:ACCOUNT_CHANGED' &&\n                                    ((_b = messageEvent.data) === null || _b === void 0 ? void 0 : _b.originChain) !== CHAIN.APTOS) {\n                                    this.disconnect();\n                                    removeListener();\n                                }\n                            });\n                            if ((_d = getChainAddress(this.sessionKey, CHAIN.APTOS)) === null || _d === void 0 ? void 0 : _d.length) {\n                                try {\n                                    const { public_keys: publicKeys } = yield fetch(`${this.server}/blocto/aptos/accounts/${(_e = getChainAddress(this.sessionKey, CHAIN.APTOS)) === null || _e === void 0 ? void 0 : _e[0]}`).then((response) => response.json());\n                                    this.publicKey = publicKeys || [];\n                                    resolve({\n                                        address: ((_f = getChainAddress(this.sessionKey, CHAIN.APTOS)) === null || _f === void 0 ? void 0 : _f[0]) || '',\n                                        publicKey: this.publicKey,\n                                        authKey: null,\n                                        minKeysRequired: 2,\n                                    });\n                                }\n                                catch (err) {\n                                    return reject(e);\n                                }\n                            }\n                            else {\n                                // @todo: better error\n                                return reject();\n                            }\n                        }\n                        if (e.data.type === 'APTOS:FRAME:CLOSE') {\n                            removeListener();\n                            detatchFrame(loginFrame);\n                            reject(new Error('User declined the login request'));\n                        }\n                    }\n                }));\n            });\n        });\n    }\n    fetchAddress() {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            const sessionId = ((_a = getAccountStorage(this.sessionKey)) === null || _a === void 0 ? void 0 : _a.code) || '';\n            const { accounts } = yield fetch(`${this.server}/api/aptos/accounts`, {\n                headers: {\n                    // We already check the existence in the constructor\n                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                    'Blocto-Application-Identifier': this.appId,\n                    'Blocto-Session-Identifier': sessionId,\n                },\n            }).then((response) => responseSessionGuard(response, this.sessionKey));\n            setChainAddress(this.sessionKey, CHAIN.APTOS, accounts);\n            return (accounts === null || accounts === void 0 ? void 0 : accounts[0]) || '';\n        });\n    }\n    on(event, listener) {\n        if (this.existedSDK)\n            this.existedSDK.on(event, listener);\n        super.on(event, listener);\n    }\n    removeListener(event, listener) {\n        if (this.existedSDK)\n            this.existedSDK.off(event, listener);\n        super.removeListener(event, listener);\n    }\n}\n\nclass BloctoSDK {\n    constructor({ appId, ethereum, aptos }) {\n        if (ethereum) {\n            this.ethereum = new EthereumProvider(Object.assign(Object.assign({}, ethereum), { appId }));\n        }\n        if (aptos) {\n            this.aptos = new AptosProvider(Object.assign(Object.assign({}, aptos), { appId }));\n        }\n    }\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGJsb2N0by9zZGsvZGlzdC9ibG9jdG8tc2RrLm1vZHVsZS5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsK0RBQStELGlCQUFpQjtBQUM1RztBQUNBLG9DQUFvQyxNQUFNLCtCQUErQixZQUFZO0FBQ3JGLG1DQUFtQyxNQUFNLG1DQUFtQyxZQUFZO0FBQ3hGLGdDQUFnQztBQUNoQztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGtDQUFrQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsc0JBQXNCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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Q0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdCQUF3Qjs7QUFFeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsVUFBVTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsWUFBWTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQjs7QUFFcEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLHdDQUF3QyxTQUFTO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixpQkFBaUI7QUFDakM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjLGlCQUFpQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsRUFBRTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGVBQWU7QUFDeEM7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EseUJBQXlCLFFBQVE7QUFDakM7QUFDQSxzQkFBc0IsZUFBZTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsWUFBWTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLFNBQVM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHNCQUFzQixTQUFTO0FBQy9CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHNCQUFzQixTQUFTO0FBQy9CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLG9CQUFvQixjQUFjO0FBQ2xDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3REFBd0QsT0FBTztBQUMvRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0RBQXdELE9BQU87QUFDL0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFGQUFxRjtBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxZQUFZLGtFQUFrRTtBQUN0RixNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlDQUF5QyxTQUFTO0FBQ2xEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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VDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFdBQVcsaUJBQWlCLFlBQVk7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0Isd0JBQXdCO0FBQzFDO0FBQ0EsK0VBQStFLGVBQWUsT0FBTztBQUNyRztBQUNBO0FBQ0EseUVBQXlFLFlBQVksT0FBTztBQUM1RjtBQUNBO0FBQ0E7O0FBRWdDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdGhlLWN1bHQvLi9ub2RlX21vZHVsZXMvQGJsb2N0by9zZGsvZGlzdC9ibG9jdG8tc2RrLm1vZHVsZS5qcz8wODRmIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIFZlcnNpb246IDAuMTAuMiAtIE1heSAzLCAyMDI0IDA0OjMyOjI5ICovXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxyXG5cclxuUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XHJcbnB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cclxuXHJcblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEhcclxuUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXHJcbkFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcclxuSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NXHJcbkxPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SXHJcbk9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcclxuUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuLyogZ2xvYmFsIFJlZmxlY3QsIFByb21pc2UsIFN1cHByZXNzZWRFcnJvciwgU3ltYm9sICovXHJcblxyXG5cclxuZnVuY3Rpb24gX19hd2FpdGVyKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xyXG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XHJcbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cclxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XHJcbiAgICB9KTtcclxufVxyXG5cclxuZnVuY3Rpb24gX19jbGFzc1ByaXZhdGVGaWVsZEdldChyZWNlaXZlciwgc3RhdGUsIGtpbmQsIGYpIHtcclxuICAgIGlmIChraW5kID09PSBcImFcIiAmJiAhZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIGdldHRlclwiKTtcclxuICAgIGlmICh0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyICE9PSBzdGF0ZSB8fCAhZiA6ICFzdGF0ZS5oYXMocmVjZWl2ZXIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHJlYWQgcHJpdmF0ZSBtZW1iZXIgZnJvbSBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xyXG4gICAgcmV0dXJuIGtpbmQgPT09IFwibVwiID8gZiA6IGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyKSA6IGYgPyBmLnZhbHVlIDogc3RhdGUuZ2V0KHJlY2VpdmVyKTtcclxufVxyXG5cclxudHlwZW9mIFN1cHByZXNzZWRFcnJvciA9PT0gXCJmdW5jdGlvblwiID8gU3VwcHJlc3NlZEVycm9yIDogZnVuY3Rpb24gKGVycm9yLCBzdXBwcmVzc2VkLCBtZXNzYWdlKSB7XHJcbiAgICB2YXIgZSA9IG5ldyBFcnJvcihtZXNzYWdlKTtcclxuICAgIHJldHVybiBlLm5hbWUgPSBcIlN1cHByZXNzZWRFcnJvclwiLCBlLmVycm9yID0gZXJyb3IsIGUuc3VwcHJlc3NlZCA9IHN1cHByZXNzZWQsIGU7XHJcbn07XG5cbi8vIGluc3RlYWQgaW52YXJpYW50IGZyb20gcGFja2FnZSwgc2luY2UgYWxsIGVycm9yIHdpbGwgdGhyb3cgb24gcHJvZHVjdGlvblxuZnVuY3Rpb24gaW52YXJpYW50KGNvbmRpdGlvbiwgZm9ybWF0KSB7XG4gICAgaWYgKCFjb25kaXRpb24pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGZvcm1hdCk7XG4gICAgfVxufVxuXG52YXIgS0VZX1NFU1NJT047XG4oZnVuY3Rpb24gKEtFWV9TRVNTSU9OKSB7XG4gICAgS0VZX1NFU1NJT05bXCJwcm9kXCJdID0gXCJCTE9DVE9fU0RLXCI7XG4gICAgS0VZX1NFU1NJT05bXCJkZXZcIl0gPSBcIkJMT0NUT19TREtfREVWXCI7XG4gICAgS0VZX1NFU1NJT05bXCJzdGFnaW5nXCJdID0gXCJCTE9DVE9fU0RLX1NUQUdJTkdcIjtcbn0pKEtFWV9TRVNTSU9OIHx8IChLRVlfU0VTU0lPTiA9IHt9KSk7XG52YXIgQ0hBSU47XG4oZnVuY3Rpb24gKENIQUlOKSB7XG4gICAgQ0hBSU5bXCJFVEhFUkVVTVwiXSA9IFwiZXRoZXJldW1cIjtcbiAgICBDSEFJTltcIkFQVE9TXCJdID0gXCJhcHRvc1wiO1xufSkoQ0hBSU4gfHwgKENIQUlOID0ge30pKTtcbi8qIGV0aCBzZXJpZXMgY29uc3RhbnRzIGJlZ2luICovXG5jb25zdCBFVEhfUlBDX0xJU1QgPSB7XG4gICAgLy8gVGhpcyBpcyB0aGUgbGlzdCBvZiBwdWJsaWMgUlBDIGVuZHBvaW50cyB0aGF0IHdlIGtub3duIHRvIGJlIHdvcmtpbmdcbiAgICAvLyBVc2VkIHRvIGhlbHAgZGV2ZWxvcGVycyBkaWQgbm90IHNldCB1cCB0aGVpciBvd24gUlBDIGVuZHBvaW50c1xuICAgIC8vIEJTQyBtYWlubmV0XG4gICAgNTY6ICdodHRwczovL2JzYy1kYXRhc2VlZDEuYmluYW5jZS5vcmcnLFxuICAgIC8vIEJTQyB0ZXN0bmV0XG4gICAgOTc6ICdodHRwczovL2RhdGEtc2VlZC1wcmVic2MtMS1zMS5iaW5hbmNlLm9yZzo4NTQ1JyxcbiAgICAvLyBQb2x5Z29uIE1haW5uZXRcbiAgICAxMzc6ICdodHRwczovL3JwYy1tYWlubmV0Lm1hdGljdmlnaWwuY29tLycsXG4gICAgLy8gUG9seWdvbiBBbW95IFRlc3RuZXRcbiAgICA4MDAwMjogJ2h0dHBzOi8vcnBjLWFtb3kucG9seWdvbi50ZWNobm9sb2d5LycsXG4gICAgLy8gQXZhbGFuY2hlIE1haW5uZXRcbiAgICA0MzExNDogJ2h0dHBzOi8vYXBpLmF2YXgubmV0d29yay9leHQvYmMvQy9ycGMnLFxuICAgIC8vIEF2YWxhbmNoZSBGdWppIFRlc3RuZXRcbiAgICA0MzExMzogJ2h0dHBzOi8vYXBpLmF2YXgtdGVzdC5uZXR3b3JrL2V4dC9iYy9DL3JwYycsXG4gICAgLy8gQXJiaXRydW0gTWFpbm5ldFxuICAgIDQyMTYxOiAnaHR0cHM6Ly9hcmIxLmFyYml0cnVtLmlvL3JwYycsXG4gICAgLy8gQXJiaXRydW0gU2Vwb2xpYSBUZXN0bmV0XG4gICAgNDIxNjE0OiAnaHR0cHM6Ly9hcmJpdHJ1bS1zZXBvbGlhLmJsb2NrcGkubmV0d29yay92MS9ycGMvcHVibGljJyxcbiAgICAvLyBPcHRpbWlzbSBNYWlubmV0XG4gICAgMTA6ICdodHRwczovL21haW5uZXQub3B0aW1pc20uaW8nLFxuICAgIC8vIE9wdGltaXNtIFNlcG9saWEgVGVzdG5ldFxuICAgIDExMTU1NDIwOiAnaHR0cHM6Ly9zZXBvbGlhLm9wdGltaXNtLmlvJyxcbiAgICAvLyBCYXNlIE1haW5uZXRcbiAgICA4NDUzOiAnaHR0cHM6Ly9tYWlubmV0LmJhc2Uub3JnJyxcbiAgICAvLyBCYXNlIFNlcG9saWEgVGVzdG5ldFxuICAgIDg0NTMyOiAnaHR0cHM6Ly9zZXBvbGlhLmJhc2Uub3JnJyxcbiAgICAvLyBab3JhXG4gICAgNzc3Nzc3NzogJ2h0dHBzOi8vcnBjLnpvcmEuZW5lcmd5JyxcbiAgICAvLyBab3JhIFNlcG9saWEgVGVzdG5ldFxuICAgIDk5OTk5OTk5OTogJ2h0dHBzOi8vc2Vwb2xpYS5ycGMuem9yYS5lbmVyZ3knLFxuICAgIC8vIFNjcm9sbFxuICAgIDUzNDM1MjogJ2h0dHBzOi8vcnBjLnNjcm9sbC5pbycsXG4gICAgLy8gU2Nyb2xsIFNlcG9saWEgVGVzdG5ldFxuICAgIDUzNDM1MTogJ2h0dHBzOi8vc2Vwb2xpYS1ycGMuc2Nyb2xsLmlvJyxcbiAgICAvLyBMaW5lYVxuICAgIDU5MTQ0OiAnaHR0cHM6Ly9ycGMubGluZWEuYnVpbGQnLFxuICAgIC8vIHpLYXRhbmEgU2Vwb2xpYSBUZXN0bmV0XG4gICAgMTI2MTEyMDogJ2h0dHBzOi8vcnBjLnN0YXJ0YWxlLmNvbS96a2F0YW5hJyxcbiAgICAvLyBCbGFzdFxuICAgIDgxNDU3OiAnaHR0cHM6Ly9ycGMuYmxhc3QuaW8nLFxuICAgIC8vIEJsYXN0IFNlcG9saWEgVGVzdG5ldFxuICAgIDE2ODU4Nzc3MzogJ2h0dHBzOi8vc2Vwb2xpYS5ibGFzdC5pbydcbn07XG5jb25zdCBFVEhfRU5WX1dBTExFVF9TRVJWRVJfTUFQUElORyA9IHtcbiAgICBwcm9kOiAnaHR0cHM6Ly93YWxsZXQtdjIuYmxvY3RvLmFwcCcsXG4gICAgc3RhZ2luZzogJ2h0dHBzOi8vd2FsbGV0LXYyLXN0YWdpbmcuYmxvY3RvLmFwcCcsXG4gICAgZGV2OiAnaHR0cHM6Ly93YWxsZXQtdjItZGV2LmJsb2N0by5hcHAnLFxufTtcbmNvbnN0IEVUSF9TRVNTSU9OX0tFWV9NQVBQSU5HID0ge1xuICAgIHByb2Q6IEtFWV9TRVNTSU9OLnByb2QsXG4gICAgc3RhZ2luZzogS0VZX1NFU1NJT04uc3RhZ2luZyxcbiAgICBkZXY6IEtFWV9TRVNTSU9OLmRldixcbn07XG4vKiBldGggc2VyaWVzIGNvbnN0YW50cyBlbmQgKi9cbi8qIGFwdG9zIGNvbnN0YW50cyBiZWdpbiAqL1xuY29uc3QgQVBUX1NFU1NJT05fS0VZX01BUFBJTkcgPSB7XG4gICAgMTogS0VZX1NFU1NJT04ucHJvZCxcbiAgICAyOiBLRVlfU0VTU0lPTi5kZXYsXG4gICAgMzogS0VZX1NFU1NJT04uZGV2LFxuICAgIDQ6IEtFWV9TRVNTSU9OLmRldixcbiAgICA1OiBLRVlfU0VTU0lPTi5zdGFnaW5nLFxufTtcbmNvbnN0IEFQVF9DSEFJTl9JRF9TRVJWRVJfTUFQUElORyA9IHtcbiAgICAvLyBNQUlOTkVUXG4gICAgMTogJ2h0dHBzOi8vd2FsbGV0LXYyLmJsb2N0by5hcHAnLFxuICAgIC8vIFRFU1RORVRcbiAgICAyOiAnaHR0cHM6Ly93YWxsZXQtdjItZGV2LmJsb2N0by5hcHAnLFxuICAgIC8vIERFVk5FVFxuICAgIDM6ICdodHRwczovL3dhbGxldC12Mi1kZXYuYmxvY3RvLmFwcCcsXG4gICAgLy8gVEVTVElOR1xuICAgIDQ6ICdodHRwczovL3dhbGxldC12Mi1kZXYuYmxvY3RvLmFwcCcsXG4gICAgLy8gUFJFTUFJTk5FVFxuICAgIDU6ICdodHRwczovL3dhbGxldC12Mi1zdGFnaW5nLmJsb2N0by5hcHAnLFxufTtcbnZhciBXYWxsZXRBZGFwdGVyTmV0d29yaztcbihmdW5jdGlvbiAoV2FsbGV0QWRhcHRlck5ldHdvcmspIHtcbiAgICBXYWxsZXRBZGFwdGVyTmV0d29ya1tcIk1haW5uZXRcIl0gPSBcIm1haW5uZXRcIjtcbiAgICBXYWxsZXRBZGFwdGVyTmV0d29ya1tcIlRlc3RuZXRcIl0gPSBcInRlc3RuZXRcIjtcbiAgICBXYWxsZXRBZGFwdGVyTmV0d29ya1tcIkRldm5ldFwiXSA9IFwiZGV2bmV0XCI7XG4gICAgV2FsbGV0QWRhcHRlck5ldHdvcmtbXCJUZXN0aW5nXCJdID0gXCJ0ZXN0aW5nXCI7XG4gICAgV2FsbGV0QWRhcHRlck5ldHdvcmtbXCJQcmVtYWlubmV0XCJdID0gXCJwcmVtYWlubmV0XCI7XG59KShXYWxsZXRBZGFwdGVyTmV0d29yayB8fCAoV2FsbGV0QWRhcHRlck5ldHdvcmsgPSB7fSkpO1xuY29uc3QgQVBUX0NIQUlOX0lEX05BTUVfTUFQUElORyA9IHtcbiAgICAxOiBXYWxsZXRBZGFwdGVyTmV0d29yay5NYWlubmV0LFxuICAgIDI6IFdhbGxldEFkYXB0ZXJOZXR3b3JrLlRlc3RuZXQsXG4gICAgMzogV2FsbGV0QWRhcHRlck5ldHdvcmsuRGV2bmV0LFxuICAgIDQ6IFdhbGxldEFkYXB0ZXJOZXR3b3JrLlRlc3RpbmcsXG4gICAgNTogV2FsbGV0QWRhcHRlck5ldHdvcmsuUHJlbWFpbm5ldCxcbn07XG5jb25zdCBBUFRfQ0hBSU5fSURfUlBDX01BUFBJTkcgPSB7XG4gICAgMTogJ2h0dHBzOi8vZnVsbG5vZGUubWFpbm5ldC5hcHRvc2xhYnMuY29tL3YxJyxcbiAgICAyOiAnaHR0cHM6Ly9mdWxsbm9kZS50ZXN0bmV0LmFwdG9zbGFicy5jb20vdjEnLFxuICAgIDM6ICdodHRwczovL2Z1bGxub2RlLmRldm5ldC5hcHRvc2xhYnMuY29tL3YxJyxcbiAgICA0OiAnJyxcbiAgICA1OiAnaHR0cHM6Ly9wcmVtYWlubmV0LmFwdG9zZGV2LmNvbS92MScsXG59O1xuLyogYXB0b3MgY29uc3RhbnRzIGVuZCAqL1xuY29uc3QgRUlQMTE5M19FVkVOVFMgPSBbXG4gICAgJ2Nvbm5lY3QnLFxuICAgICdkaXNjb25uZWN0JyxcbiAgICAnbWVzc2FnZScsXG4gICAgJ2NoYWluQ2hhbmdlZCcsXG4gICAgJ2FjY291bnRzQ2hhbmdlZCcsXG5dO1xuLy8gUHJlc2VydmUgbG9naW4gZm9yIDEgZGF5XG5jb25zdCBMT0dJTl9QRVJTSVNUSU5HX1RJTUUgPSA4NjQwMCAqIDEwMDA7XG5jb25zdCBERUZBVUxUX0FQUF9JRCA9ICcwMDAwMDAwMC0wMDAwLTAwMDAtMDAwMC0wMDAwMDAwMDAwMDAnO1xuLy8gV2lsbCBpbmplY3QgdGhlIHZlcnNpb24gb2YgdGhlIFNESyBieSByb2xsdXAgdmVyc2lvbkluamVjdG9yIGR1cmluZyBidWlsZCB0aW1lXG5jb25zdCBTREtfVkVSU0lPTiA9ICcwLjEwLjInO1xuXG4vLyBUaGUgcm9vdCBjbGFzcyBmb3IgYWxsIHByb3ZpZGVyc1xuY2xhc3MgQmxvY3RvUHJvdmlkZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmlzQmxvY3RvID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5pc0Nvbm5lY3RpbmcgPSBmYWxzZTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgICAgICB0aGlzLmV2ZW50TGlzdGVuZXJzID0ge307XG4gICAgICAgIC8vIGFsaWFzIHJlbW92ZUxpc3RlbmVyXG4gICAgICAgIHRoaXMub2ZmID0gdGhpcy5yZW1vdmVMaXN0ZW5lcjtcbiAgICAgICAgLy8gaW5pdCBldmVudCBsaXN0ZW5lcnNcbiAgICAgICAgRUlQMTE5M19FVkVOVFMuZm9yRWFjaCgoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRMaXN0ZW5lcnNbZXZlbnRdID0gW107XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmFwcElkID0gREVGQVVMVF9BUFBfSUQ7XG4gICAgfVxuICAgIC8vIGltcGxlbWVudCBieSBjaGlsZHJlblxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgIHJlcXVlc3QocGF5bG9hZCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkgeyB9KTtcbiAgICB9XG4gICAgb24oZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgICAgIGlmICghRUlQMTE5M19FVkVOVFMuaW5jbHVkZXMoZXZlbnQpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLmV2ZW50TGlzdGVuZXJzW2V2ZW50XS5wdXNoKGxpc3RlbmVyKTtcbiAgICB9XG4gICAgLy8gQHRvZG86IGltcGxlbWVudCBpdFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgIG9uY2UoKSB7IH1cbiAgICByZW1vdmVMaXN0ZW5lcihldmVudCwgbGlzdGVuZXIpIHtcbiAgICAgICAgY29uc3QgbGlzdGVuZXJzID0gdGhpcy5ldmVudExpc3RlbmVyc1tldmVudF07XG4gICAgICAgIGNvbnN0IGluZGV4ID0gbGlzdGVuZXJzLmZpbmRJbmRleCgoaXRlbSkgPT4gaXRlbSA9PT0gbGlzdGVuZXIpO1xuICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICB0aGlzLmV2ZW50TGlzdGVuZXJzW2V2ZW50XS5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5jb25zdCBJRlJBTUVfU1RZTEUgPSAnd2lkdGg6MTAwdnc7aGVpZ2h0OjEwMCU7cG9zaXRpb246Zml4ZWQ7dG9wOjA7bGVmdDowO3otaW5kZXg6MjE0NzQ4MzY0Njtib3JkZXI6bm9uZTtib3gtc2l6aW5nOmJvcmRlci1ib3g7Y29sb3Itc2NoZW1lOmxpZ2h0O2luc2V0OjBweDtkaXNwbGF5OmJsb2NrO3BvaW50ZXItZXZlbnRzOmF1dG87JztcbmZ1bmN0aW9uIGNyZWF0ZUZyYW1lKHVybCkge1xuICAgIGNvbnN0IGZyYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaWZyYW1lJyk7XG4gICAgZnJhbWUuc2V0QXR0cmlidXRlKCdzcmMnLCB1cmwpO1xuICAgIGZyYW1lLnNldEF0dHJpYnV0ZSgnc3R5bGUnLCBJRlJBTUVfU1RZTEUpO1xuICAgIHJldHVybiBmcmFtZTtcbn1cbmZ1bmN0aW9uIGF0dGFjaEZyYW1lKGZyYW1lKSB7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChmcmFtZSk7XG59XG5mdW5jdGlvbiBkZXRhdGNoRnJhbWUoZnJhbWUpIHtcbiAgICBjb25zdCBwYXJlbnROb2RlID0gZnJhbWUgJiYgZnJhbWUucGFyZW50Tm9kZTtcbiAgICBpZiAocGFyZW50Tm9kZSAmJiBwYXJlbnROb2RlLnJlbW92ZUNoaWxkIGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcbiAgICAgICAgcGFyZW50Tm9kZS5yZW1vdmVDaGlsZChmcmFtZSk7XG4gICAgfVxufVxuXG52YXIgYWRkU2VsZlJlbW92YWJsZUhhbmRsZXIgPSAoZXZlbnRUeXBlLCBoYW5kbGVyLCB0YXJnZXQgPSB3aW5kb3cpID0+IHtcbiAgICBmdW5jdGlvbiBsaXN0ZW5lcihlKSB7XG4gICAgICAgIGNvbnN0IHJlbW92ZUV2ZW50TGlzdGVuZXIgPSAoKSA9PiB0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIGxpc3RlbmVyKTtcbiAgICAgICAgaGFuZGxlcihlLCByZW1vdmVFdmVudExpc3RlbmVyKTtcbiAgICB9XG4gICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCBsaXN0ZW5lcik7XG59O1xuXG5jb25zdCBpc1N0b3JhZ2VTdXBwb3J0ZWQgPSAoKSA9PiB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgd2luZG93LnNlc3Npb25TdG9yYWdlLnNldEl0ZW0oJ2xvY2FsX3N0b3JhZ2Vfc3VwcG9ydGVkJywgJzEnKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gd2luZG93LnNlc3Npb25TdG9yYWdlLmdldEl0ZW0oJ2xvY2FsX3N0b3JhZ2Vfc3VwcG9ydGVkJyk7XG4gICAgICAgIHdpbmRvdy5zZXNzaW9uU3RvcmFnZS5yZW1vdmVJdGVtKCdsb2NhbF9zdG9yYWdlX3N1cHBvcnRlZCcpO1xuICAgICAgICByZXR1cm4gcmVzdWx0ID09PSAnMSc7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufTtcbmNsYXNzIE1lbW9yeVN0b3JhZ2Uge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnN0b3JhZ2UgPSB7fTtcbiAgICB9XG4gICAgZ2V0SXRlbShrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNba2V5XSB8fCBudWxsO1xuICAgIH1cbiAgICBzZXRJdGVtKGtleSwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5zdG9yYWdlW2tleV0gPSB2YWx1ZTtcbiAgICB9XG4gICAgcmVtb3ZlSXRlbShrZXkpIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuc3RvcmFnZVtrZXldO1xuICAgIH1cbn1cbmNvbnN0IG1lbW9yeVN0b3JhZ2UgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdy5tZW1vcnlTdG9yYWdlIDogbmV3IE1lbW9yeVN0b3JhZ2UoKTtcblxuY29uc3Qgc3RvcmFnZSA9IGlzU3RvcmFnZVN1cHBvcnRlZCgpID8gd2luZG93LnNlc3Npb25TdG9yYWdlIDogbWVtb3J5U3RvcmFnZTtcbmNvbnN0IGdldEl0ZW0gPSAoa2V5LCBkZWZhdWx0VmFsdWUgPSBudWxsKSA9PiB7XG4gICAgY29uc3QgdmFsdWUgPSBzdG9yYWdlLmdldEl0ZW0oa2V5KTtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gKHZhbHVlICYmIEpTT04ucGFyc2UodmFsdWUpKSB8fCBkZWZhdWx0VmFsdWU7XG4gICAgfVxuICAgIGNhdGNoIChTeW50YXhFcnJvcikge1xuICAgICAgICByZXR1cm4gdmFsdWUgfHwgZGVmYXVsdFZhbHVlO1xuICAgIH1cbn07XG5jb25zdCBzZXRJdGVtID0gKGtleSwgdmFsdWUpID0+IHN0b3JhZ2Uuc2V0SXRlbShrZXksIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgPyB2YWx1ZSA6IEpTT04uc3RyaW5naWZ5KHZhbHVlKSk7XG5jb25zdCByZW1vdmVJdGVtID0gKGtleSkgPT4ge1xuICAgIHNldEl0ZW0oa2V5LCAnJyk7IC8vIER1ZSB0byBzb21lIHZlcnNpb25zIG9mIGJyb3dzZXIgYnVnIGNhbid0IHJlbW92ZUl0ZW0gY29ycmVjdGx5LlxuICAgIHN0b3JhZ2UucmVtb3ZlSXRlbShrZXkpO1xufTtcbi8qKlxuICogQHBhcmFtIHtLRVlfU0VTU0lPTn0ga2V5IC0ga2V5IHRvIHJldHJpZXZlIHRoZSBkYXRhXG4gKiBAcmV0dXJucyB7UHJvdmlkZXJTZXNzaW9uIHwgbnVsbH0gUHJvdmlkZXJTZXNzaW9uIHwgbnVsbFxuICogQGRlc2NyaXB0aW9uXG4gKiBHZXQgUHJvdmlkZXJTZXNzaW9uIGZyb20gc3RvcmFnZS5cbiAqIElmIHRoZSBkYXRhIGlzIGV4cGlyZWQsIHdpbGwgcmVtb3ZlIHRoZSBkYXRhIGFuZCByZXR1cm4gbnVsbFxuICovXG5jb25zdCBnZXRBY2NvdW50U3RvcmFnZSA9IChrZXkpID0+IHtcbiAgICBjb25zdCByYXdBY2NvdW50U3RvcmFnZSA9IGdldEl0ZW0oa2V5LCBudWxsKTtcbiAgICBpZiAoIXJhd0FjY291bnRTdG9yYWdlKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAvLyBjb21wYXJlIHRoZSBleHBpcnkgdGltZSBvZiB0aGUgaXRlbSB3aXRoIHRoZSBjdXJyZW50IHRpbWVcbiAgICBpZiAobmV3IERhdGUoKS5nZXRUaW1lKCkgPiByYXdBY2NvdW50U3RvcmFnZS5leHBpcnkgfHxcbiAgICAgICAgcmF3QWNjb3VudFN0b3JhZ2UudiAhPT0gU0RLX1ZFUlNJT04pIHtcbiAgICAgICAgcmVtb3ZlSXRlbShrZXkpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHJhd0FjY291bnRTdG9yYWdlID09PSBudWxsIHx8IHJhd0FjY291bnRTdG9yYWdlID09PSB2b2lkIDAgPyB2b2lkIDAgOiByYXdBY2NvdW50U3RvcmFnZS5kYXRhO1xufTtcbi8qKlxuICBAcGFyYW0ge0tFWV9TRVNTSU9OfSBrZXkgLSBrZXkgdG8gc3RvcmUgdGhlIGRhdGFcbiAgQHBhcmFtIHtQcm92aWRlclNlc3Npb259IGRhdGEgLSBPbmx5IHRoZSBwYXJ0IG9mIFByb3ZpZGVyU2Vzc2lvbiB0aGF0IG5lZWRzIHRvIGJlIHVwZGF0ZWRcbiAgQHBhcmFtIHtudW1iZXJ9IGV4cGlyeSAtIGV4cGlyeSB0aW1lIG9mIHRoZSBkYXRhXG4qL1xuY29uc3Qgc2V0QWNjb3VudFN0b3JhZ2UgPSAoa2V5LCBkYXRhLCBleHBpcnkpID0+IHtcbiAgICB2YXIgX2EsIF9iLCBfYztcbiAgICBjb25zdCByYXdBY2NvdW50U3RvcmFnZSA9IGdldEl0ZW0oa2V5KTtcbiAgICBjb25zdCBuZXdBY2NvdW50U3RvcmFnZSA9IHtcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgY29kZTogKGRhdGEgPT09IG51bGwgfHwgZGF0YSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZGF0YS5jb2RlKSB8fCAoKF9hID0gcmF3QWNjb3VudFN0b3JhZ2UgPT09IG51bGwgfHwgcmF3QWNjb3VudFN0b3JhZ2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJhd0FjY291bnRTdG9yYWdlLmRhdGEpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jb2RlKSxcbiAgICAgICAgICAgIGFjY291bnRzOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIChfYiA9IHJhd0FjY291bnRTdG9yYWdlID09PSBudWxsIHx8IHJhd0FjY291bnRTdG9yYWdlID09PSB2b2lkIDAgPyB2b2lkIDAgOiByYXdBY2NvdW50U3RvcmFnZS5kYXRhKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWNjb3VudHMpLCBkYXRhID09PSBudWxsIHx8IGRhdGEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRhdGEuYWNjb3VudHMpLFxuICAgICAgICAgICAgZXZtOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIChfYyA9IHJhd0FjY291bnRTdG9yYWdlID09PSBudWxsIHx8IHJhd0FjY291bnRTdG9yYWdlID09PSB2b2lkIDAgPyB2b2lkIDAgOiByYXdBY2NvdW50U3RvcmFnZS5kYXRhKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuZXZtKSwgZGF0YSA9PT0gbnVsbCB8fCBkYXRhID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkYXRhLmV2bSksXG4gICAgICAgIH0sXG4gICAgICAgIGV4cGlyeTogZXhwaXJ5IHx8XG4gICAgICAgICAgICAocmF3QWNjb3VudFN0b3JhZ2UgPT09IG51bGwgfHwgcmF3QWNjb3VudFN0b3JhZ2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJhd0FjY291bnRTdG9yYWdlLmV4cGlyeSkgfHxcbiAgICAgICAgICAgIG5ldyBEYXRlKCkuZ2V0VGltZSgpICsgTE9HSU5fUEVSU0lTVElOR19USU1FLFxuICAgICAgICB2OiBTREtfVkVSU0lPTixcbiAgICB9O1xuICAgIHNldEl0ZW0oa2V5LCBuZXdBY2NvdW50U3RvcmFnZSk7XG4gICAgcmV0dXJuO1xufTtcbmNvbnN0IGdldENoYWluQWRkcmVzcyA9IChrZXksIGNoYWluKSA9PiB7XG4gICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgaWYgKCEoKF9hID0gZ2V0QWNjb3VudFN0b3JhZ2Uoa2V5KSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNvZGUpKSB7XG4gICAgICAgIHJlbW92ZUl0ZW0oa2V5KTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiAoKF9jID0gKF9iID0gZ2V0QWNjb3VudFN0b3JhZ2Uoa2V5KSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFjY291bnRzKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2NbY2hhaW5dKSB8fCBudWxsO1xufTtcbmNvbnN0IHNldENoYWluQWRkcmVzcyA9IChrZXksIGNoYWluLCBhY2NvdW50KSA9PiB7XG4gICAgc2V0QWNjb3VudFN0b3JhZ2Uoa2V5LCB7IGFjY291bnRzOiB7IFtjaGFpbl06IGFjY291bnQgfSB9KTtcbiAgICByZXR1cm47XG59O1xuY29uc3QgcmVtb3ZlQ2hhaW5BZGRyZXNzID0gKGtleSwgY2hhaW4pID0+IHtcbiAgICBzZXRBY2NvdW50U3RvcmFnZShrZXksIHsgYWNjb3VudHM6IHsgW2NoYWluXTogdW5kZWZpbmVkIH0gfSk7XG4gICAgcmV0dXJuO1xufTtcbmNvbnN0IGdldEV2bUFkZHJlc3MgPSAoa2V5LCBjaGFpbikgPT4ge1xuICAgIHZhciBfYSwgX2IsIF9jO1xuICAgIGlmICghKChfYSA9IGdldEFjY291bnRTdG9yYWdlKGtleSkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jb2RlKSkge1xuICAgICAgICByZW1vdmVJdGVtKGtleSk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gKChfYyA9IChfYiA9IGdldEFjY291bnRTdG9yYWdlKGtleSkpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5ldm0pID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfY1tjaGFpbl0pIHx8IG51bGw7XG59O1xuY29uc3Qgc2V0RXZtQWRkcmVzcyA9IChrZXksIGNoYWluLCBhY2NvdW50cykgPT4ge1xuICAgIHNldEFjY291bnRTdG9yYWdlKGtleSwgeyBldm06IHsgW2NoYWluXTogYWNjb3VudHMgfSB9KTtcbiAgICByZXR1cm47XG59O1xuY29uc3QgcmVtb3ZlQWxsRXZtQWRkcmVzcyA9IChrZXkpID0+IHtcbiAgICBjb25zdCBuZXdBY2NvdW50U3RvcmFnZSA9IGdldEl0ZW0oa2V5KTtcbiAgICBpZiAoIW5ld0FjY291bnRTdG9yYWdlKVxuICAgICAgICByZXR1cm47XG4gICAgbmV3QWNjb3VudFN0b3JhZ2UuZGF0YS5ldm0gPSB7fTtcbiAgICBzZXRJdGVtKGtleSwgbmV3QWNjb3VudFN0b3JhZ2UpO1xuICAgIHJldHVybjtcbn07XG5cbmZ1bmN0aW9uIHJlc3BvbnNlU2Vzc2lvbkd1YXJkKHJlc3BvbnNlLCBrZXksIGRpc2Nvbm5lY3RIYW5kbGVyKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gNDAzIHx8IHJlc3BvbnNlLnN0YXR1cyA9PT0gNDAxKSB7XG4gICAgICAgICAgICBpZiAoZGlzY29ubmVjdEhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICBkaXNjb25uZWN0SGFuZGxlcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVtb3ZlSXRlbShrZXkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSB5aWVsZCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICBjb25zdCBlID0gbmV3IEVycm9yKChkYXRhID09PSBudWxsIHx8IGRhdGEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRhdGEubWVzc2FnZSkgfHwgJ3Vua25vd24gZXJyb3InKTtcbiAgICAgICAgICAgIGUuZXJyb3JfY29kZSA9IGRhdGEgPT09IG51bGwgfHwgZGF0YSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZGF0YS5lcnJvcl9jb2RlO1xuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpO1xuICAgIH0pO1xufVxuXG5jb25zdCBpc0VtYWlsID0gKHZhbHVlKSA9PiAvXFxTK0BcXFMrXFwuXFxTKy8udGVzdCh2YWx1ZSk7XG5cbnZhciBFUlJPUl9NRVNTQUdFO1xuKGZ1bmN0aW9uIChFUlJPUl9NRVNTQUdFKSB7XG4gICAgRVJST1JfTUVTU0FHRVtcIklOVkFMSURfVFJBTlNBQ1RJT05cIl0gPSBcIkludmFsaWQgdHJhbnNhY3Rpb25cIjtcbiAgICBFUlJPUl9NRVNTQUdFW1wiSU5WQUxJRF9UUkFOU0FDVElPTlNcIl0gPSBcIkludmFsaWQgdHJhbnNhY3Rpb25zXCI7XG4gICAgRVJST1JfTUVTU0FHRVtcIklOVkFMSURfVFJBTlNBQ1RJT05fVkFMVUVcIl0gPSBcIlRyYW5zYWN0aW9uIHBhcmFtcyBcXFwidmFsdWVcXFwiIHNob3VsZCBiZSBoZXgtZW5jb2RlZCBzdHJpbmdcIjtcbn0pKEVSUk9SX01FU1NBR0UgfHwgKEVSUk9SX01FU1NBR0UgPSB7fSkpO1xuXG52YXIgZ2xvYmFsJDEgPSAodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6XG4gIHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6XG4gIHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSk7XG5cbnZhciBsb29rdXAgPSBbXTtcbnZhciByZXZMb29rdXAgPSBbXTtcbnZhciBBcnIgPSB0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcgPyBVaW50OEFycmF5IDogQXJyYXk7XG52YXIgaW5pdGVkID0gZmFsc2U7XG5mdW5jdGlvbiBpbml0ICgpIHtcbiAgaW5pdGVkID0gdHJ1ZTtcbiAgdmFyIGNvZGUgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLyc7XG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBjb2RlLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgbG9va3VwW2ldID0gY29kZVtpXTtcbiAgICByZXZMb29rdXBbY29kZS5jaGFyQ29kZUF0KGkpXSA9IGk7XG4gIH1cblxuICByZXZMb29rdXBbJy0nLmNoYXJDb2RlQXQoMCldID0gNjI7XG4gIHJldkxvb2t1cFsnXycuY2hhckNvZGVBdCgwKV0gPSA2Mztcbn1cblxuZnVuY3Rpb24gdG9CeXRlQXJyYXkgKGI2NCkge1xuICBpZiAoIWluaXRlZCkge1xuICAgIGluaXQoKTtcbiAgfVxuICB2YXIgaSwgaiwgbCwgdG1wLCBwbGFjZUhvbGRlcnMsIGFycjtcbiAgdmFyIGxlbiA9IGI2NC5sZW5ndGg7XG5cbiAgaWYgKGxlbiAlIDQgPiAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN0cmluZy4gTGVuZ3RoIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA0JylcbiAgfVxuXG4gIC8vIHRoZSBudW1iZXIgb2YgZXF1YWwgc2lnbnMgKHBsYWNlIGhvbGRlcnMpXG4gIC8vIGlmIHRoZXJlIGFyZSB0d28gcGxhY2Vob2xkZXJzLCB0aGFuIHRoZSB0d28gY2hhcmFjdGVycyBiZWZvcmUgaXRcbiAgLy8gcmVwcmVzZW50IG9uZSBieXRlXG4gIC8vIGlmIHRoZXJlIGlzIG9ubHkgb25lLCB0aGVuIHRoZSB0aHJlZSBjaGFyYWN0ZXJzIGJlZm9yZSBpdCByZXByZXNlbnQgMiBieXRlc1xuICAvLyB0aGlzIGlzIGp1c3QgYSBjaGVhcCBoYWNrIHRvIG5vdCBkbyBpbmRleE9mIHR3aWNlXG4gIHBsYWNlSG9sZGVycyA9IGI2NFtsZW4gLSAyXSA9PT0gJz0nID8gMiA6IGI2NFtsZW4gLSAxXSA9PT0gJz0nID8gMSA6IDA7XG5cbiAgLy8gYmFzZTY0IGlzIDQvMyArIHVwIHRvIHR3byBjaGFyYWN0ZXJzIG9mIHRoZSBvcmlnaW5hbCBkYXRhXG4gIGFyciA9IG5ldyBBcnIobGVuICogMyAvIDQgLSBwbGFjZUhvbGRlcnMpO1xuXG4gIC8vIGlmIHRoZXJlIGFyZSBwbGFjZWhvbGRlcnMsIG9ubHkgZ2V0IHVwIHRvIHRoZSBsYXN0IGNvbXBsZXRlIDQgY2hhcnNcbiAgbCA9IHBsYWNlSG9sZGVycyA+IDAgPyBsZW4gLSA0IDogbGVuO1xuXG4gIHZhciBMID0gMDtcblxuICBmb3IgKGkgPSAwLCBqID0gMDsgaSA8IGw7IGkgKz0gNCwgaiArPSAzKSB7XG4gICAgdG1wID0gKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTgpIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDEyKSB8IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA8PCA2KSB8IHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMyldO1xuICAgIGFycltMKytdID0gKHRtcCA+PiAxNikgJiAweEZGO1xuICAgIGFycltMKytdID0gKHRtcCA+PiA4KSAmIDB4RkY7XG4gICAgYXJyW0wrK10gPSB0bXAgJiAweEZGO1xuICB9XG5cbiAgaWYgKHBsYWNlSG9sZGVycyA9PT0gMikge1xuICAgIHRtcCA9IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDIpIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldID4+IDQpO1xuICAgIGFycltMKytdID0gdG1wICYgMHhGRjtcbiAgfSBlbHNlIGlmIChwbGFjZUhvbGRlcnMgPT09IDEpIHtcbiAgICB0bXAgPSAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxMCkgfCAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgNCkgfCAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPj4gMik7XG4gICAgYXJyW0wrK10gPSAodG1wID4+IDgpICYgMHhGRjtcbiAgICBhcnJbTCsrXSA9IHRtcCAmIDB4RkY7XG4gIH1cblxuICByZXR1cm4gYXJyXG59XG5cbmZ1bmN0aW9uIHRyaXBsZXRUb0Jhc2U2NCAobnVtKSB7XG4gIHJldHVybiBsb29rdXBbbnVtID4+IDE4ICYgMHgzRl0gKyBsb29rdXBbbnVtID4+IDEyICYgMHgzRl0gKyBsb29rdXBbbnVtID4+IDYgJiAweDNGXSArIGxvb2t1cFtudW0gJiAweDNGXVxufVxuXG5mdW5jdGlvbiBlbmNvZGVDaHVuayAodWludDgsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHRtcDtcbiAgdmFyIG91dHB1dCA9IFtdO1xuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkgKz0gMykge1xuICAgIHRtcCA9ICh1aW50OFtpXSA8PCAxNikgKyAodWludDhbaSArIDFdIDw8IDgpICsgKHVpbnQ4W2kgKyAyXSk7XG4gICAgb3V0cHV0LnB1c2godHJpcGxldFRvQmFzZTY0KHRtcCkpO1xuICB9XG4gIHJldHVybiBvdXRwdXQuam9pbignJylcbn1cblxuZnVuY3Rpb24gZnJvbUJ5dGVBcnJheSAodWludDgpIHtcbiAgaWYgKCFpbml0ZWQpIHtcbiAgICBpbml0KCk7XG4gIH1cbiAgdmFyIHRtcDtcbiAgdmFyIGxlbiA9IHVpbnQ4Lmxlbmd0aDtcbiAgdmFyIGV4dHJhQnl0ZXMgPSBsZW4gJSAzOyAvLyBpZiB3ZSBoYXZlIDEgYnl0ZSBsZWZ0LCBwYWQgMiBieXRlc1xuICB2YXIgb3V0cHV0ID0gJyc7XG4gIHZhciBwYXJ0cyA9IFtdO1xuICB2YXIgbWF4Q2h1bmtMZW5ndGggPSAxNjM4MzsgLy8gbXVzdCBiZSBtdWx0aXBsZSBvZiAzXG5cbiAgLy8gZ28gdGhyb3VnaCB0aGUgYXJyYXkgZXZlcnkgdGhyZWUgYnl0ZXMsIHdlJ2xsIGRlYWwgd2l0aCB0cmFpbGluZyBzdHVmZiBsYXRlclxuICBmb3IgKHZhciBpID0gMCwgbGVuMiA9IGxlbiAtIGV4dHJhQnl0ZXM7IGkgPCBsZW4yOyBpICs9IG1heENodW5rTGVuZ3RoKSB7XG4gICAgcGFydHMucHVzaChlbmNvZGVDaHVuayh1aW50OCwgaSwgKGkgKyBtYXhDaHVua0xlbmd0aCkgPiBsZW4yID8gbGVuMiA6IChpICsgbWF4Q2h1bmtMZW5ndGgpKSk7XG4gIH1cblxuICAvLyBwYWQgdGhlIGVuZCB3aXRoIHplcm9zLCBidXQgbWFrZSBzdXJlIHRvIG5vdCBmb3JnZXQgdGhlIGV4dHJhIGJ5dGVzXG4gIGlmIChleHRyYUJ5dGVzID09PSAxKSB7XG4gICAgdG1wID0gdWludDhbbGVuIC0gMV07XG4gICAgb3V0cHV0ICs9IGxvb2t1cFt0bXAgPj4gMl07XG4gICAgb3V0cHV0ICs9IGxvb2t1cFsodG1wIDw8IDQpICYgMHgzRl07XG4gICAgb3V0cHV0ICs9ICc9PSc7XG4gIH0gZWxzZSBpZiAoZXh0cmFCeXRlcyA9PT0gMikge1xuICAgIHRtcCA9ICh1aW50OFtsZW4gLSAyXSA8PCA4KSArICh1aW50OFtsZW4gLSAxXSk7XG4gICAgb3V0cHV0ICs9IGxvb2t1cFt0bXAgPj4gMTBdO1xuICAgIG91dHB1dCArPSBsb29rdXBbKHRtcCA+PiA0KSAmIDB4M0ZdO1xuICAgIG91dHB1dCArPSBsb29rdXBbKHRtcCA8PCAyKSAmIDB4M0ZdO1xuICAgIG91dHB1dCArPSAnPSc7XG4gIH1cblxuICBwYXJ0cy5wdXNoKG91dHB1dCk7XG5cbiAgcmV0dXJuIHBhcnRzLmpvaW4oJycpXG59XG5cbmZ1bmN0aW9uIHJlYWQgKGJ1ZmZlciwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG07XG4gIHZhciBlTGVuID0gbkJ5dGVzICogOCAtIG1MZW4gLSAxO1xuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMTtcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxO1xuICB2YXIgbkJpdHMgPSAtNztcbiAgdmFyIGkgPSBpc0xFID8gKG5CeXRlcyAtIDEpIDogMDtcbiAgdmFyIGQgPSBpc0xFID8gLTEgOiAxO1xuICB2YXIgcyA9IGJ1ZmZlcltvZmZzZXQgKyBpXTtcblxuICBpICs9IGQ7XG5cbiAgZSA9IHMgJiAoKDEgPDwgKC1uQml0cykpIC0gMSk7XG4gIHMgPj49ICgtbkJpdHMpO1xuICBuQml0cyArPSBlTGVuO1xuICBmb3IgKDsgbkJpdHMgPiAwOyBlID0gZSAqIDI1NiArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIG0gPSBlICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpO1xuICBlID4+PSAoLW5CaXRzKTtcbiAgbkJpdHMgKz0gbUxlbjtcbiAgZm9yICg7IG5CaXRzID4gMDsgbSA9IG0gKiAyNTYgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBpZiAoZSA9PT0gMCkge1xuICAgIGUgPSAxIC0gZUJpYXM7XG4gIH0gZWxzZSBpZiAoZSA9PT0gZU1heCkge1xuICAgIHJldHVybiBtID8gTmFOIDogKChzID8gLTEgOiAxKSAqIEluZmluaXR5KVxuICB9IGVsc2Uge1xuICAgIG0gPSBtICsgTWF0aC5wb3coMiwgbUxlbik7XG4gICAgZSA9IGUgLSBlQmlhcztcbiAgfVxuICByZXR1cm4gKHMgPyAtMSA6IDEpICogbSAqIE1hdGgucG93KDIsIGUgLSBtTGVuKVxufVxuXG5mdW5jdGlvbiB3cml0ZSAoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG0sIGM7XG4gIHZhciBlTGVuID0gbkJ5dGVzICogOCAtIG1MZW4gLSAxO1xuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMTtcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxO1xuICB2YXIgcnQgPSAobUxlbiA9PT0gMjMgPyBNYXRoLnBvdygyLCAtMjQpIC0gTWF0aC5wb3coMiwgLTc3KSA6IDApO1xuICB2YXIgaSA9IGlzTEUgPyAwIDogKG5CeXRlcyAtIDEpO1xuICB2YXIgZCA9IGlzTEUgPyAxIDogLTE7XG4gIHZhciBzID0gdmFsdWUgPCAwIHx8ICh2YWx1ZSA9PT0gMCAmJiAxIC8gdmFsdWUgPCAwKSA/IDEgOiAwO1xuXG4gIHZhbHVlID0gTWF0aC5hYnModmFsdWUpO1xuXG4gIGlmIChpc05hTih2YWx1ZSkgfHwgdmFsdWUgPT09IEluZmluaXR5KSB7XG4gICAgbSA9IGlzTmFOKHZhbHVlKSA/IDEgOiAwO1xuICAgIGUgPSBlTWF4O1xuICB9IGVsc2Uge1xuICAgIGUgPSBNYXRoLmZsb29yKE1hdGgubG9nKHZhbHVlKSAvIE1hdGguTE4yKTtcbiAgICBpZiAodmFsdWUgKiAoYyA9IE1hdGgucG93KDIsIC1lKSkgPCAxKSB7XG4gICAgICBlLS07XG4gICAgICBjICo9IDI7XG4gICAgfVxuICAgIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgdmFsdWUgKz0gcnQgLyBjO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSArPSBydCAqIE1hdGgucG93KDIsIDEgLSBlQmlhcyk7XG4gICAgfVxuICAgIGlmICh2YWx1ZSAqIGMgPj0gMikge1xuICAgICAgZSsrO1xuICAgICAgYyAvPSAyO1xuICAgIH1cblxuICAgIGlmIChlICsgZUJpYXMgPj0gZU1heCkge1xuICAgICAgbSA9IDA7XG4gICAgICBlID0gZU1heDtcbiAgICB9IGVsc2UgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICBtID0gKHZhbHVlICogYyAtIDEpICogTWF0aC5wb3coMiwgbUxlbik7XG4gICAgICBlID0gZSArIGVCaWFzO1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gdmFsdWUgKiBNYXRoLnBvdygyLCBlQmlhcyAtIDEpICogTWF0aC5wb3coMiwgbUxlbik7XG4gICAgICBlID0gMDtcbiAgICB9XG4gIH1cblxuICBmb3IgKDsgbUxlbiA+PSA4OyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBtICYgMHhmZiwgaSArPSBkLCBtIC89IDI1NiwgbUxlbiAtPSA4KSB7fVxuXG4gIGUgPSAoZSA8PCBtTGVuKSB8IG07XG4gIGVMZW4gKz0gbUxlbjtcbiAgZm9yICg7IGVMZW4gPiAwOyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBlICYgMHhmZiwgaSArPSBkLCBlIC89IDI1NiwgZUxlbiAtPSA4KSB7fVxuXG4gIGJ1ZmZlcltvZmZzZXQgKyBpIC0gZF0gfD0gcyAqIDEyODtcbn1cblxudmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7XG5cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoYXJyKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKGFycikgPT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG5cbi8qIVxuICogVGhlIGJ1ZmZlciBtb2R1bGUgZnJvbSBub2RlLmpzLCBmb3IgdGhlIGJyb3dzZXIuXG4gKlxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGZlcm9zc0BmZXJvc3Mub3JnPiA8aHR0cDovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cblxudmFyIElOU1BFQ1RfTUFYX0JZVEVTID0gNTA7XG5cbi8qKlxuICogSWYgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYDpcbiAqICAgPT09IHRydWUgICAgVXNlIFVpbnQ4QXJyYXkgaW1wbGVtZW50YXRpb24gKGZhc3Rlc3QpXG4gKiAgID09PSBmYWxzZSAgIFVzZSBPYmplY3QgaW1wbGVtZW50YXRpb24gKG1vc3QgY29tcGF0aWJsZSwgZXZlbiBJRTYpXG4gKlxuICogQnJvd3NlcnMgdGhhdCBzdXBwb3J0IHR5cGVkIGFycmF5cyBhcmUgSUUgMTArLCBGaXJlZm94IDQrLCBDaHJvbWUgNyssIFNhZmFyaSA1LjErLFxuICogT3BlcmEgMTEuNissIGlPUyA0LjIrLlxuICpcbiAqIER1ZSB0byB2YXJpb3VzIGJyb3dzZXIgYnVncywgc29tZXRpbWVzIHRoZSBPYmplY3QgaW1wbGVtZW50YXRpb24gd2lsbCBiZSB1c2VkIGV2ZW5cbiAqIHdoZW4gdGhlIGJyb3dzZXIgc3VwcG9ydHMgdHlwZWQgYXJyYXlzLlxuICpcbiAqIE5vdGU6XG4gKlxuICogICAtIEZpcmVmb3ggNC0yOSBsYWNrcyBzdXBwb3J0IGZvciBhZGRpbmcgbmV3IHByb3BlcnRpZXMgdG8gYFVpbnQ4QXJyYXlgIGluc3RhbmNlcyxcbiAqICAgICBTZWU6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY5NTQzOC5cbiAqXG4gKiAgIC0gQ2hyb21lIDktMTAgaXMgbWlzc2luZyB0aGUgYFR5cGVkQXJyYXkucHJvdG90eXBlLnN1YmFycmF5YCBmdW5jdGlvbi5cbiAqXG4gKiAgIC0gSUUxMCBoYXMgYSBicm9rZW4gYFR5cGVkQXJyYXkucHJvdG90eXBlLnN1YmFycmF5YCBmdW5jdGlvbiB3aGljaCByZXR1cm5zIGFycmF5cyBvZlxuICogICAgIGluY29ycmVjdCBsZW5ndGggaW4gc29tZSBzaXR1YXRpb25zLlxuXG4gKiBXZSBkZXRlY3QgdGhlc2UgYnVnZ3kgYnJvd3NlcnMgYW5kIHNldCBgQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRgIHRvIGBmYWxzZWAgc28gdGhleVxuICogZ2V0IHRoZSBPYmplY3QgaW1wbGVtZW50YXRpb24sIHdoaWNoIGlzIHNsb3dlciBidXQgYmVoYXZlcyBjb3JyZWN0bHkuXG4gKi9cbkJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUID0gZ2xvYmFsJDEuVFlQRURfQVJSQVlfU1VQUE9SVCAhPT0gdW5kZWZpbmVkXG4gID8gZ2xvYmFsJDEuVFlQRURfQVJSQVlfU1VQUE9SVFxuICA6IHRydWU7XG5cbi8qXG4gKiBFeHBvcnQga01heExlbmd0aCBhZnRlciB0eXBlZCBhcnJheSBzdXBwb3J0IGlzIGRldGVybWluZWQuXG4gKi9cbmtNYXhMZW5ndGgoKTtcblxuZnVuY3Rpb24ga01heExlbmd0aCAoKSB7XG4gIHJldHVybiBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVFxuICAgID8gMHg3ZmZmZmZmZlxuICAgIDogMHgzZmZmZmZmZlxufVxuXG5mdW5jdGlvbiBjcmVhdGVCdWZmZXIgKHRoYXQsIGxlbmd0aCkge1xuICBpZiAoa01heExlbmd0aCgpIDwgbGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0ludmFsaWQgdHlwZWQgYXJyYXkgbGVuZ3RoJylcbiAgfVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZSwgZm9yIGJlc3QgcGVyZm9ybWFuY2VcbiAgICB0aGF0ID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKTtcbiAgICB0aGF0Ll9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGU7XG4gIH0gZWxzZSB7XG4gICAgLy8gRmFsbGJhY2s6IFJldHVybiBhbiBvYmplY3QgaW5zdGFuY2Ugb2YgdGhlIEJ1ZmZlciBjbGFzc1xuICAgIGlmICh0aGF0ID09PSBudWxsKSB7XG4gICAgICB0aGF0ID0gbmV3IEJ1ZmZlcihsZW5ndGgpO1xuICAgIH1cbiAgICB0aGF0Lmxlbmd0aCA9IGxlbmd0aDtcbiAgfVxuXG4gIHJldHVybiB0aGF0XG59XG5cbi8qKlxuICogVGhlIEJ1ZmZlciBjb25zdHJ1Y3RvciByZXR1cm5zIGluc3RhbmNlcyBvZiBgVWludDhBcnJheWAgdGhhdCBoYXZlIHRoZWlyXG4gKiBwcm90b3R5cGUgY2hhbmdlZCB0byBgQnVmZmVyLnByb3RvdHlwZWAuIEZ1cnRoZXJtb3JlLCBgQnVmZmVyYCBpcyBhIHN1YmNsYXNzIG9mXG4gKiBgVWludDhBcnJheWAsIHNvIHRoZSByZXR1cm5lZCBpbnN0YW5jZXMgd2lsbCBoYXZlIGFsbCB0aGUgbm9kZSBgQnVmZmVyYCBtZXRob2RzXG4gKiBhbmQgdGhlIGBVaW50OEFycmF5YCBtZXRob2RzLiBTcXVhcmUgYnJhY2tldCBub3RhdGlvbiB3b3JrcyBhcyBleHBlY3RlZCAtLSBpdFxuICogcmV0dXJucyBhIHNpbmdsZSBvY3RldC5cbiAqXG4gKiBUaGUgYFVpbnQ4QXJyYXlgIHByb3RvdHlwZSByZW1haW5zIHVubW9kaWZpZWQuXG4gKi9cblxuZnVuY3Rpb24gQnVmZmVyIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmICEodGhpcyBpbnN0YW5jZW9mIEJ1ZmZlcikpIHtcbiAgICByZXR1cm4gbmV3IEJ1ZmZlcihhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIC8vIENvbW1vbiBjYXNlLlxuICBpZiAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicpIHtcbiAgICBpZiAodHlwZW9mIGVuY29kaW5nT3JPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdJZiBlbmNvZGluZyBpcyBzcGVjaWZpZWQgdGhlbiB0aGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZydcbiAgICAgIClcbiAgICB9XG4gICAgcmV0dXJuIGFsbG9jVW5zYWZlKHRoaXMsIGFyZylcbiAgfVxuICByZXR1cm4gZnJvbSh0aGlzLCBhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuQnVmZmVyLnBvb2xTaXplID0gODE5MjsgLy8gbm90IHVzZWQgYnkgdGhpcyBpbXBsZW1lbnRhdGlvblxuXG4vLyBUT0RPOiBMZWdhY3ksIG5vdCBuZWVkZWQgYW55bW9yZS4gUmVtb3ZlIGluIG5leHQgbWFqb3IgdmVyc2lvbi5cbkJ1ZmZlci5fYXVnbWVudCA9IGZ1bmN0aW9uIChhcnIpIHtcbiAgYXJyLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGU7XG4gIHJldHVybiBhcnJcbn07XG5cbmZ1bmN0aW9uIGZyb20gKHRoYXQsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInZhbHVlXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgYSBudW1iZXInKVxuICB9XG5cbiAgaWYgKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgdmFsdWUgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgIHJldHVybiBmcm9tQXJyYXlCdWZmZXIodGhhdCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGZyb21TdHJpbmcodGhhdCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQpXG4gIH1cblxuICByZXR1cm4gZnJvbU9iamVjdCh0aGF0LCB2YWx1ZSlcbn1cblxuLyoqXG4gKiBGdW5jdGlvbmFsbHkgZXF1aXZhbGVudCB0byBCdWZmZXIoYXJnLCBlbmNvZGluZykgYnV0IHRocm93cyBhIFR5cGVFcnJvclxuICogaWYgdmFsdWUgaXMgYSBudW1iZXIuXG4gKiBCdWZmZXIuZnJvbShzdHJbLCBlbmNvZGluZ10pXG4gKiBCdWZmZXIuZnJvbShhcnJheSlcbiAqIEJ1ZmZlci5mcm9tKGJ1ZmZlcilcbiAqIEJ1ZmZlci5mcm9tKGFycmF5QnVmZmVyWywgYnl0ZU9mZnNldFssIGxlbmd0aF1dKVxuICoqL1xuQnVmZmVyLmZyb20gPSBmdW5jdGlvbiAodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gZnJvbShudWxsLCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufTtcblxuaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gIEJ1ZmZlci5wcm90b3R5cGUuX19wcm90b19fID0gVWludDhBcnJheS5wcm90b3R5cGU7XG4gIEJ1ZmZlci5fX3Byb3RvX18gPSBVaW50OEFycmF5O1xuICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnNwZWNpZXMgJiZcbiAgICAgIEJ1ZmZlcltTeW1ib2wuc3BlY2llc10gPT09IEJ1ZmZlcikgO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRTaXplIChzaXplKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInNpemVcIiBhcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcbiAgfSBlbHNlIGlmIChzaXplIDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcInNpemVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBuZWdhdGl2ZScpXG4gIH1cbn1cblxuZnVuY3Rpb24gYWxsb2MgKHRoYXQsIHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIGFzc2VydFNpemUoc2l6ZSk7XG4gIGlmIChzaXplIDw9IDApIHtcbiAgICByZXR1cm4gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpXG4gIH1cbiAgaWYgKGZpbGwgIT09IHVuZGVmaW5lZCkge1xuICAgIC8vIE9ubHkgcGF5IGF0dGVudGlvbiB0byBlbmNvZGluZyBpZiBpdCdzIGEgc3RyaW5nLiBUaGlzXG4gICAgLy8gcHJldmVudHMgYWNjaWRlbnRhbGx5IHNlbmRpbmcgaW4gYSBudW1iZXIgdGhhdCB3b3VsZFxuICAgIC8vIGJlIGludGVycHJldHRlZCBhcyBhIHN0YXJ0IG9mZnNldC5cbiAgICByZXR1cm4gdHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJ1xuICAgICAgPyBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSkuZmlsbChmaWxsLCBlbmNvZGluZylcbiAgICAgIDogY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpLmZpbGwoZmlsbClcbiAgfVxuICByZXR1cm4gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpXG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBmaWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogYWxsb2Moc2l6ZVssIGZpbGxbLCBlbmNvZGluZ11dKVxuICoqL1xuQnVmZmVyLmFsbG9jID0gZnVuY3Rpb24gKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIHJldHVybiBhbGxvYyhudWxsLCBzaXplLCBmaWxsLCBlbmNvZGluZylcbn07XG5cbmZ1bmN0aW9uIGFsbG9jVW5zYWZlICh0aGF0LCBzaXplKSB7XG4gIGFzc2VydFNpemUoc2l6ZSk7XG4gIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSA8IDAgPyAwIDogY2hlY2tlZChzaXplKSB8IDApO1xuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaXplOyArK2kpIHtcbiAgICAgIHRoYXRbaV0gPSAwO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG4vKipcbiAqIEVxdWl2YWxlbnQgdG8gQnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgcmV0dXJuIGFsbG9jVW5zYWZlKG51bGwsIHNpemUpXG59O1xuLyoqXG4gKiBFcXVpdmFsZW50IHRvIFNsb3dCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlU2xvdyA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShudWxsLCBzaXplKVxufTtcblxuZnVuY3Rpb24gZnJvbVN0cmluZyAodGhhdCwgc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAodHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJyB8fCBlbmNvZGluZyA9PT0gJycpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4JztcbiAgfVxuXG4gIGlmICghQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJlbmNvZGluZ1wiIG11c3QgYmUgYSB2YWxpZCBzdHJpbmcgZW5jb2RpbmcnKVxuICB9XG5cbiAgdmFyIGxlbmd0aCA9IGJ5dGVMZW5ndGgoc3RyaW5nLCBlbmNvZGluZykgfCAwO1xuICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIGxlbmd0aCk7XG5cbiAgdmFyIGFjdHVhbCA9IHRoYXQud3JpdGUoc3RyaW5nLCBlbmNvZGluZyk7XG5cbiAgaWYgKGFjdHVhbCAhPT0gbGVuZ3RoKSB7XG4gICAgLy8gV3JpdGluZyBhIGhleCBzdHJpbmcsIGZvciBleGFtcGxlLCB0aGF0IGNvbnRhaW5zIGludmFsaWQgY2hhcmFjdGVycyB3aWxsXG4gICAgLy8gY2F1c2UgZXZlcnl0aGluZyBhZnRlciB0aGUgZmlyc3QgaW52YWxpZCBjaGFyYWN0ZXIgdG8gYmUgaWdub3JlZC4gKGUuZy5cbiAgICAvLyAnYWJ4eGNkJyB3aWxsIGJlIHRyZWF0ZWQgYXMgJ2FiJylcbiAgICB0aGF0ID0gdGhhdC5zbGljZSgwLCBhY3R1YWwpO1xuICB9XG5cbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5TGlrZSAodGhhdCwgYXJyYXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCA8IDAgPyAwIDogY2hlY2tlZChhcnJheS5sZW5ndGgpIHwgMDtcbiAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBsZW5ndGgpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgdGhhdFtpXSA9IGFycmF5W2ldICYgMjU1O1xuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUJ1ZmZlciAodGhhdCwgYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuICBhcnJheS5ieXRlTGVuZ3RoOyAvLyB0aGlzIHRocm93cyBpZiBgYXJyYXlgIGlzIG5vdCBhIHZhbGlkIEFycmF5QnVmZmVyXG5cbiAgaWYgKGJ5dGVPZmZzZXQgPCAwIHx8IGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0KSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1xcJ29mZnNldFxcJyBpcyBvdXQgb2YgYm91bmRzJylcbiAgfVxuXG4gIGlmIChhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCArIChsZW5ndGggfHwgMCkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXFwnbGVuZ3RoXFwnIGlzIG91dCBvZiBib3VuZHMnKVxuICB9XG5cbiAgaWYgKGJ5dGVPZmZzZXQgPT09IHVuZGVmaW5lZCAmJiBsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXkpO1xuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYXJyYXkgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldCk7XG4gIH0gZWxzZSB7XG4gICAgYXJyYXkgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKTtcbiAgfVxuXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlLCBmb3IgYmVzdCBwZXJmb3JtYW5jZVxuICAgIHRoYXQgPSBhcnJheTtcbiAgICB0aGF0Ll9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGU7XG4gIH0gZWxzZSB7XG4gICAgLy8gRmFsbGJhY2s6IFJldHVybiBhbiBvYmplY3QgaW5zdGFuY2Ugb2YgdGhlIEJ1ZmZlciBjbGFzc1xuICAgIHRoYXQgPSBmcm9tQXJyYXlMaWtlKHRoYXQsIGFycmF5KTtcbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tT2JqZWN0ICh0aGF0LCBvYmopIHtcbiAgaWYgKGludGVybmFsSXNCdWZmZXIob2JqKSkge1xuICAgIHZhciBsZW4gPSBjaGVja2VkKG9iai5sZW5ndGgpIHwgMDtcbiAgICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIGxlbik7XG5cbiAgICBpZiAodGhhdC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB0aGF0XG4gICAgfVxuXG4gICAgb2JqLmNvcHkodGhhdCwgMCwgMCwgbGVuKTtcbiAgICByZXR1cm4gdGhhdFxuICB9XG5cbiAgaWYgKG9iaikge1xuICAgIGlmICgodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICBvYmouYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHx8ICdsZW5ndGgnIGluIG9iaikge1xuICAgICAgaWYgKHR5cGVvZiBvYmoubGVuZ3RoICE9PSAnbnVtYmVyJyB8fCBpc25hbihvYmoubGVuZ3RoKSkge1xuICAgICAgICByZXR1cm4gY3JlYXRlQnVmZmVyKHRoYXQsIDApXG4gICAgICB9XG4gICAgICByZXR1cm4gZnJvbUFycmF5TGlrZSh0aGF0LCBvYmopXG4gICAgfVxuXG4gICAgaWYgKG9iai50eXBlID09PSAnQnVmZmVyJyAmJiBpc0FycmF5KG9iai5kYXRhKSkge1xuICAgICAgcmV0dXJuIGZyb21BcnJheUxpa2UodGhhdCwgb2JqLmRhdGEpXG4gICAgfVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcignRmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZywgQnVmZmVyLCBBcnJheUJ1ZmZlciwgQXJyYXksIG9yIGFycmF5LWxpa2Ugb2JqZWN0LicpXG59XG5cbmZ1bmN0aW9uIGNoZWNrZWQgKGxlbmd0aCkge1xuICAvLyBOb3RlOiBjYW5ub3QgdXNlIGBsZW5ndGggPCBrTWF4TGVuZ3RoKClgIGhlcmUgYmVjYXVzZSB0aGF0IGZhaWxzIHdoZW5cbiAgLy8gbGVuZ3RoIGlzIE5hTiAod2hpY2ggaXMgb3RoZXJ3aXNlIGNvZXJjZWQgdG8gemVyby4pXG4gIGlmIChsZW5ndGggPj0ga01heExlbmd0aCgpKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gYWxsb2NhdGUgQnVmZmVyIGxhcmdlciB0aGFuIG1heGltdW0gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgJ3NpemU6IDB4JyArIGtNYXhMZW5ndGgoKS50b1N0cmluZygxNikgKyAnIGJ5dGVzJylcbiAgfVxuICByZXR1cm4gbGVuZ3RoIHwgMFxufVxuQnVmZmVyLmlzQnVmZmVyID0gaXNCdWZmZXI7XG5mdW5jdGlvbiBpbnRlcm5hbElzQnVmZmVyIChiKSB7XG4gIHJldHVybiAhIShiICE9IG51bGwgJiYgYi5faXNCdWZmZXIpXG59XG5cbkJ1ZmZlci5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAoYSwgYikge1xuICBpZiAoIWludGVybmFsSXNCdWZmZXIoYSkgfHwgIWludGVybmFsSXNCdWZmZXIoYikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudHMgbXVzdCBiZSBCdWZmZXJzJylcbiAgfVxuXG4gIGlmIChhID09PSBiKSByZXR1cm4gMFxuXG4gIHZhciB4ID0gYS5sZW5ndGg7XG4gIHZhciB5ID0gYi5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IE1hdGgubWluKHgsIHkpOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAoYVtpXSAhPT0gYltpXSkge1xuICAgICAgeCA9IGFbaV07XG4gICAgICB5ID0gYltpXTtcbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufTtcblxuQnVmZmVyLmlzRW5jb2RpbmcgPSBmdW5jdGlvbiBpc0VuY29kaW5nIChlbmNvZGluZykge1xuICBzd2l0Y2ggKFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICBjYXNlICdsYXRpbjEnOlxuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgcmV0dXJuIHRydWVcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlXG4gIH1cbn07XG5cbkJ1ZmZlci5jb25jYXQgPSBmdW5jdGlvbiBjb25jYXQgKGxpc3QsIGxlbmd0aCkge1xuICBpZiAoIWlzQXJyYXkobGlzdCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICB9XG5cbiAgaWYgKGxpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5hbGxvYygwKVxuICB9XG5cbiAgdmFyIGk7XG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGxlbmd0aCA9IDA7XG4gICAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICAgIGxlbmd0aCArPSBsaXN0W2ldLmxlbmd0aDtcbiAgICB9XG4gIH1cblxuICB2YXIgYnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKGxlbmd0aCk7XG4gIHZhciBwb3MgPSAwO1xuICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgIHZhciBidWYgPSBsaXN0W2ldO1xuICAgIGlmICghaW50ZXJuYWxJc0J1ZmZlcihidWYpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICAgIH1cbiAgICBidWYuY29weShidWZmZXIsIHBvcyk7XG4gICAgcG9zICs9IGJ1Zi5sZW5ndGg7XG4gIH1cbiAgcmV0dXJuIGJ1ZmZlclxufTtcblxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAoaW50ZXJuYWxJc0J1ZmZlcihzdHJpbmcpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5sZW5ndGhcbiAgfVxuICBpZiAodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgQXJyYXlCdWZmZXIuaXNWaWV3ID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAoQXJyYXlCdWZmZXIuaXNWaWV3KHN0cmluZykgfHwgc3RyaW5nIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5ieXRlTGVuZ3RoXG4gIH1cbiAgaWYgKHR5cGVvZiBzdHJpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgc3RyaW5nID0gJycgKyBzdHJpbmc7XG4gIH1cblxuICB2YXIgbGVuID0gc3RyaW5nLmxlbmd0aDtcbiAgaWYgKGxlbiA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBVc2UgYSBmb3IgbG9vcCB0byBhdm9pZCByZWN1cnNpb25cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2U7XG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxlblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICBjYXNlIHVuZGVmaW5lZDpcbiAgICAgICAgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gbGVuICogMlxuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGxlbiA+Pj4gMVxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoIC8vIGFzc3VtZSB1dGY4XG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZTtcbiAgICB9XG4gIH1cbn1cbkJ1ZmZlci5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aDtcblxuZnVuY3Rpb24gc2xvd1RvU3RyaW5nIChlbmNvZGluZywgc3RhcnQsIGVuZCkge1xuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZTtcblxuICAvLyBObyBuZWVkIHRvIHZlcmlmeSB0aGF0IFwidGhpcy5sZW5ndGggPD0gTUFYX1VJTlQzMlwiIHNpbmNlIGl0J3MgYSByZWFkLW9ubHlcbiAgLy8gcHJvcGVydHkgb2YgYSB0eXBlZCBhcnJheS5cblxuICAvLyBUaGlzIGJlaGF2ZXMgbmVpdGhlciBsaWtlIFN0cmluZyBub3IgVWludDhBcnJheSBpbiB0aGF0IHdlIHNldCBzdGFydC9lbmRcbiAgLy8gdG8gdGhlaXIgdXBwZXIvbG93ZXIgYm91bmRzIGlmIHRoZSB2YWx1ZSBwYXNzZWQgaXMgb3V0IG9mIHJhbmdlLlxuICAvLyB1bmRlZmluZWQgaXMgaGFuZGxlZCBzcGVjaWFsbHkgYXMgcGVyIEVDTUEtMjYyIDZ0aCBFZGl0aW9uLFxuICAvLyBTZWN0aW9uIDEzLjMuMy43IFJ1bnRpbWUgU2VtYW50aWNzOiBLZXllZEJpbmRpbmdJbml0aWFsaXphdGlvbi5cbiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQgfHwgc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgPSAwO1xuICB9XG4gIC8vIFJldHVybiBlYXJseSBpZiBzdGFydCA+IHRoaXMubGVuZ3RoLiBEb25lIGhlcmUgdG8gcHJldmVudCBwb3RlbnRpYWwgdWludDMyXG4gIC8vIGNvZXJjaW9uIGZhaWwgYmVsb3cuXG4gIGlmIChzdGFydCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoZW5kID09PSB1bmRlZmluZWQgfHwgZW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICBlbmQgPSB0aGlzLmxlbmd0aDtcbiAgfVxuXG4gIGlmIChlbmQgPD0gMCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgLy8gRm9yY2UgY29lcnNpb24gdG8gdWludDMyLiBUaGlzIHdpbGwgYWxzbyBjb2VyY2UgZmFsc2V5L05hTiB2YWx1ZXMgdG8gMC5cbiAgZW5kID4+Pj0gMDtcbiAgc3RhcnQgPj4+PSAwO1xuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnO1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsYXRpbjFTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHV0ZjE2bGVTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoZW5jb2RpbmcgKyAnJykudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlO1xuICAgIH1cbiAgfVxufVxuXG4vLyBUaGUgcHJvcGVydHkgaXMgdXNlZCBieSBgQnVmZmVyLmlzQnVmZmVyYCBhbmQgYGlzLWJ1ZmZlcmAgKGluIFNhZmFyaSA1LTcpIHRvIGRldGVjdFxuLy8gQnVmZmVyIGluc3RhbmNlcy5cbkJ1ZmZlci5wcm90b3R5cGUuX2lzQnVmZmVyID0gdHJ1ZTtcblxuZnVuY3Rpb24gc3dhcCAoYiwgbiwgbSkge1xuICB2YXIgaSA9IGJbbl07XG4gIGJbbl0gPSBiW21dO1xuICBiW21dID0gaTtcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMTYgPSBmdW5jdGlvbiBzd2FwMTYgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGg7XG4gIGlmIChsZW4gJSAyICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAxNi1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSAyKSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMSk7XG4gIH1cbiAgcmV0dXJuIHRoaXNcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDMyID0gZnVuY3Rpb24gc3dhcDMyICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoO1xuICBpZiAobGVuICUgNCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMzItYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDMpO1xuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyAyKTtcbiAgfVxuICByZXR1cm4gdGhpc1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwNjQgPSBmdW5jdGlvbiBzd2FwNjQgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGg7XG4gIGlmIChsZW4gJSA4ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA2NC1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSA4KSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgNyk7XG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDYpO1xuICAgIHN3YXAodGhpcywgaSArIDIsIGkgKyA1KTtcbiAgICBzd2FwKHRoaXMsIGkgKyAzLCBpICsgNCk7XG4gIH1cbiAgcmV0dXJuIHRoaXNcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gIHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aCB8IDA7XG4gIGlmIChsZW5ndGggPT09IDApIHJldHVybiAnJ1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCAwLCBsZW5ndGgpXG4gIHJldHVybiBzbG93VG9TdHJpbmcuYXBwbHkodGhpcywgYXJndW1lbnRzKVxufTtcblxuQnVmZmVyLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMgKGIpIHtcbiAgaWYgKCFpbnRlcm5hbElzQnVmZmVyKGIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgaWYgKHRoaXMgPT09IGIpIHJldHVybiB0cnVlXG4gIHJldHVybiBCdWZmZXIuY29tcGFyZSh0aGlzLCBiKSA9PT0gMFxufTtcblxuQnVmZmVyLnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gaW5zcGVjdCAoKSB7XG4gIHZhciBzdHIgPSAnJztcbiAgdmFyIG1heCA9IElOU1BFQ1RfTUFYX0JZVEVTO1xuICBpZiAodGhpcy5sZW5ndGggPiAwKSB7XG4gICAgc3RyID0gdGhpcy50b1N0cmluZygnaGV4JywgMCwgbWF4KS5tYXRjaCgvLnsyfS9nKS5qb2luKCcgJyk7XG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbWF4KSBzdHIgKz0gJyAuLi4gJztcbiAgfVxuICByZXR1cm4gJzxCdWZmZXIgJyArIHN0ciArICc+J1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAodGFyZ2V0LCBzdGFydCwgZW5kLCB0aGlzU3RhcnQsIHRoaXNFbmQpIHtcbiAgaWYgKCFpbnRlcm5hbElzQnVmZmVyKHRhcmdldCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgfVxuXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc3RhcnQgPSAwO1xuICB9XG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuZCA9IHRhcmdldCA/IHRhcmdldC5sZW5ndGggOiAwO1xuICB9XG4gIGlmICh0aGlzU3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNTdGFydCA9IDA7XG4gIH1cbiAgaWYgKHRoaXNFbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNFbmQgPSB0aGlzLmxlbmd0aDtcbiAgfVxuXG4gIGlmIChzdGFydCA8IDAgfHwgZW5kID4gdGFyZ2V0Lmxlbmd0aCB8fCB0aGlzU3RhcnQgPCAwIHx8IHRoaXNFbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdvdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kICYmIHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kKSB7XG4gICAgcmV0dXJuIC0xXG4gIH1cbiAgaWYgKHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAxXG4gIH1cblxuICBzdGFydCA+Pj49IDA7XG4gIGVuZCA+Pj49IDA7XG4gIHRoaXNTdGFydCA+Pj49IDA7XG4gIHRoaXNFbmQgPj4+PSAwO1xuXG4gIGlmICh0aGlzID09PSB0YXJnZXQpIHJldHVybiAwXG5cbiAgdmFyIHggPSB0aGlzRW5kIC0gdGhpc1N0YXJ0O1xuICB2YXIgeSA9IGVuZCAtIHN0YXJ0O1xuICB2YXIgbGVuID0gTWF0aC5taW4oeCwgeSk7XG5cbiAgdmFyIHRoaXNDb3B5ID0gdGhpcy5zbGljZSh0aGlzU3RhcnQsIHRoaXNFbmQpO1xuICB2YXIgdGFyZ2V0Q29weSA9IHRhcmdldC5zbGljZShzdGFydCwgZW5kKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKHRoaXNDb3B5W2ldICE9PSB0YXJnZXRDb3B5W2ldKSB7XG4gICAgICB4ID0gdGhpc0NvcHlbaV07XG4gICAgICB5ID0gdGFyZ2V0Q29weVtpXTtcbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufTtcblxuLy8gRmluZHMgZWl0aGVyIHRoZSBmaXJzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPj0gYGJ5dGVPZmZzZXRgLFxuLy8gT1IgdGhlIGxhc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0IDw9IGBieXRlT2Zmc2V0YC5cbi8vXG4vLyBBcmd1bWVudHM6XG4vLyAtIGJ1ZmZlciAtIGEgQnVmZmVyIHRvIHNlYXJjaFxuLy8gLSB2YWwgLSBhIHN0cmluZywgQnVmZmVyLCBvciBudW1iZXJcbi8vIC0gYnl0ZU9mZnNldCAtIGFuIGluZGV4IGludG8gYGJ1ZmZlcmA7IHdpbGwgYmUgY2xhbXBlZCB0byBhbiBpbnQzMlxuLy8gLSBlbmNvZGluZyAtIGFuIG9wdGlvbmFsIGVuY29kaW5nLCByZWxldmFudCBpcyB2YWwgaXMgYSBzdHJpbmdcbi8vIC0gZGlyIC0gdHJ1ZSBmb3IgaW5kZXhPZiwgZmFsc2UgZm9yIGxhc3RJbmRleE9mXG5mdW5jdGlvbiBiaWRpcmVjdGlvbmFsSW5kZXhPZiAoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcbiAgLy8gRW1wdHkgYnVmZmVyIG1lYW5zIG5vIG1hdGNoXG4gIGlmIChidWZmZXIubGVuZ3RoID09PSAwKSByZXR1cm4gLTFcblxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldFxuICBpZiAodHlwZW9mIGJ5dGVPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBieXRlT2Zmc2V0O1xuICAgIGJ5dGVPZmZzZXQgPSAwO1xuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPiAweDdmZmZmZmZmKSB7XG4gICAgYnl0ZU9mZnNldCA9IDB4N2ZmZmZmZmY7XG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IC0weDgwMDAwMDAwKSB7XG4gICAgYnl0ZU9mZnNldCA9IC0weDgwMDAwMDAwO1xuICB9XG4gIGJ5dGVPZmZzZXQgPSArYnl0ZU9mZnNldDsgIC8vIENvZXJjZSB0byBOdW1iZXIuXG4gIGlmIChpc05hTihieXRlT2Zmc2V0KSkge1xuICAgIC8vIGJ5dGVPZmZzZXQ6IGl0IGl0J3MgdW5kZWZpbmVkLCBudWxsLCBOYU4sIFwiZm9vXCIsIGV0Yywgc2VhcmNoIHdob2xlIGJ1ZmZlclxuICAgIGJ5dGVPZmZzZXQgPSBkaXIgPyAwIDogKGJ1ZmZlci5sZW5ndGggLSAxKTtcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0OiBuZWdhdGl2ZSBvZmZzZXRzIHN0YXJ0IGZyb20gdGhlIGVuZCBvZiB0aGUgYnVmZmVyXG4gIGlmIChieXRlT2Zmc2V0IDwgMCkgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggKyBieXRlT2Zmc2V0O1xuICBpZiAoYnl0ZU9mZnNldCA+PSBidWZmZXIubGVuZ3RoKSB7XG4gICAgaWYgKGRpcikgcmV0dXJuIC0xXG4gICAgZWxzZSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCAtIDE7XG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IDApIHtcbiAgICBpZiAoZGlyKSBieXRlT2Zmc2V0ID0gMDtcbiAgICBlbHNlIHJldHVybiAtMVxuICB9XG5cbiAgLy8gTm9ybWFsaXplIHZhbFxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICB2YWwgPSBCdWZmZXIuZnJvbSh2YWwsIGVuY29kaW5nKTtcbiAgfVxuXG4gIC8vIEZpbmFsbHksIHNlYXJjaCBlaXRoZXIgaW5kZXhPZiAoaWYgZGlyIGlzIHRydWUpIG9yIGxhc3RJbmRleE9mXG4gIGlmIChpbnRlcm5hbElzQnVmZmVyKHZhbCkpIHtcbiAgICAvLyBTcGVjaWFsIGNhc2U6IGxvb2tpbmcgZm9yIGVtcHR5IHN0cmluZy9idWZmZXIgYWx3YXlzIGZhaWxzXG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiAtMVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMHhGRjsgLy8gU2VhcmNoIGZvciBhIGJ5dGUgdmFsdWUgWzAtMjU1XVxuICAgIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJlxuICAgICAgICB0eXBlb2YgVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaWYgKGRpcikge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmxhc3RJbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCBbIHZhbCBdLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcigndmFsIG11c3QgYmUgc3RyaW5nLCBudW1iZXIgb3IgQnVmZmVyJylcbn1cblxuZnVuY3Rpb24gYXJyYXlJbmRleE9mIChhcnIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICB2YXIgaW5kZXhTaXplID0gMTtcbiAgdmFyIGFyckxlbmd0aCA9IGFyci5sZW5ndGg7XG4gIHZhciB2YWxMZW5ndGggPSB2YWwubGVuZ3RoO1xuXG4gIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSBTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCk7XG4gICAgaWYgKGVuY29kaW5nID09PSAndWNzMicgfHwgZW5jb2RpbmcgPT09ICd1Y3MtMicgfHxcbiAgICAgICAgZW5jb2RpbmcgPT09ICd1dGYxNmxlJyB8fCBlbmNvZGluZyA9PT0gJ3V0Zi0xNmxlJykge1xuICAgICAgaWYgKGFyci5sZW5ndGggPCAyIHx8IHZhbC5sZW5ndGggPCAyKSB7XG4gICAgICAgIHJldHVybiAtMVxuICAgICAgfVxuICAgICAgaW5kZXhTaXplID0gMjtcbiAgICAgIGFyckxlbmd0aCAvPSAyO1xuICAgICAgdmFsTGVuZ3RoIC89IDI7XG4gICAgICBieXRlT2Zmc2V0IC89IDI7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZCAoYnVmLCBpKSB7XG4gICAgaWYgKGluZGV4U2l6ZSA9PT0gMSkge1xuICAgICAgcmV0dXJuIGJ1ZltpXVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYnVmLnJlYWRVSW50MTZCRShpICogaW5kZXhTaXplKVxuICAgIH1cbiAgfVxuXG4gIHZhciBpO1xuICBpZiAoZGlyKSB7XG4gICAgdmFyIGZvdW5kSW5kZXggPSAtMTtcbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpIDwgYXJyTGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChyZWFkKGFyciwgaSkgPT09IHJlYWQodmFsLCBmb3VuZEluZGV4ID09PSAtMSA/IDAgOiBpIC0gZm91bmRJbmRleCkpIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggPT09IC0xKSBmb3VuZEluZGV4ID0gaTtcbiAgICAgICAgaWYgKGkgLSBmb3VuZEluZGV4ICsgMSA9PT0gdmFsTGVuZ3RoKSByZXR1cm4gZm91bmRJbmRleCAqIGluZGV4U2l6ZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggIT09IC0xKSBpIC09IGkgLSBmb3VuZEluZGV4O1xuICAgICAgICBmb3VuZEluZGV4ID0gLTE7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChieXRlT2Zmc2V0ICsgdmFsTGVuZ3RoID4gYXJyTGVuZ3RoKSBieXRlT2Zmc2V0ID0gYXJyTGVuZ3RoIC0gdmFsTGVuZ3RoO1xuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgZm91bmQgPSB0cnVlO1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB2YWxMZW5ndGg7IGorKykge1xuICAgICAgICBpZiAocmVhZChhcnIsIGkgKyBqKSAhPT0gcmVhZCh2YWwsIGopKSB7XG4gICAgICAgICAgZm91bmQgPSBmYWxzZTtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZm91bmQpIHJldHVybiBpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIC0xXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5jbHVkZXMgPSBmdW5jdGlvbiBpbmNsdWRlcyAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gdGhpcy5pbmRleE9mKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpICE9PSAtMVxufTtcblxuQnVmZmVyLnByb3RvdHlwZS5pbmRleE9mID0gZnVuY3Rpb24gaW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgdHJ1ZSlcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUubGFzdEluZGV4T2YgPSBmdW5jdGlvbiBsYXN0SW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZmFsc2UpXG59O1xuXG5mdW5jdGlvbiBoZXhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIG9mZnNldCA9IE51bWJlcihvZmZzZXQpIHx8IDA7XG4gIHZhciByZW1haW5pbmcgPSBidWYubGVuZ3RoIC0gb2Zmc2V0O1xuICBpZiAoIWxlbmd0aCkge1xuICAgIGxlbmd0aCA9IHJlbWFpbmluZztcbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPSBOdW1iZXIobGVuZ3RoKTtcbiAgICBpZiAobGVuZ3RoID4gcmVtYWluaW5nKSB7XG4gICAgICBsZW5ndGggPSByZW1haW5pbmc7XG4gICAgfVxuICB9XG5cbiAgLy8gbXVzdCBiZSBhbiBldmVuIG51bWJlciBvZiBkaWdpdHNcbiAgdmFyIHN0ckxlbiA9IHN0cmluZy5sZW5ndGg7XG4gIGlmIChzdHJMZW4gJSAyICE9PSAwKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGhleCBzdHJpbmcnKVxuXG4gIGlmIChsZW5ndGggPiBzdHJMZW4gLyAyKSB7XG4gICAgbGVuZ3RoID0gc3RyTGVuIC8gMjtcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgdmFyIHBhcnNlZCA9IHBhcnNlSW50KHN0cmluZy5zdWJzdHIoaSAqIDIsIDIpLCAxNik7XG4gICAgaWYgKGlzTmFOKHBhcnNlZCkpIHJldHVybiBpXG4gICAgYnVmW29mZnNldCArIGldID0gcGFyc2VkO1xuICB9XG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIHV0ZjhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjhUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGFzY2lpV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihhc2NpaVRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gbGF0aW4xV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYXNjaWlXcml0ZShidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGJhc2U2NFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYmFzZTY0VG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiB1Y3MyV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGYxNmxlVG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gd3JpdGUgKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKSB7XG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcpXG4gIGlmIChvZmZzZXQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnO1xuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoO1xuICAgIG9mZnNldCA9IDA7XG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBvZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBvZmZzZXQ7XG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGg7XG4gICAgb2Zmc2V0ID0gMDtcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgb2Zmc2V0WywgbGVuZ3RoXVssIGVuY29kaW5nXSlcbiAgfSBlbHNlIGlmIChpc0Zpbml0ZShvZmZzZXQpKSB7XG4gICAgb2Zmc2V0ID0gb2Zmc2V0IHwgMDtcbiAgICBpZiAoaXNGaW5pdGUobGVuZ3RoKSkge1xuICAgICAgbGVuZ3RoID0gbGVuZ3RoIHwgMDtcbiAgICAgIGlmIChlbmNvZGluZyA9PT0gdW5kZWZpbmVkKSBlbmNvZGluZyA9ICd1dGY4JztcbiAgICB9IGVsc2Uge1xuICAgICAgZW5jb2RpbmcgPSBsZW5ndGg7XG4gICAgICBsZW5ndGggPSB1bmRlZmluZWQ7XG4gICAgfVxuICAvLyBsZWdhY3kgd3JpdGUoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0LCBsZW5ndGgpIC0gcmVtb3ZlIGluIHYwLjEzXG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ0J1ZmZlci53cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXRbLCBsZW5ndGhdKSBpcyBubyBsb25nZXIgc3VwcG9ydGVkJ1xuICAgIClcbiAgfVxuXG4gIHZhciByZW1haW5pbmcgPSB0aGlzLmxlbmd0aCAtIG9mZnNldDtcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkIHx8IGxlbmd0aCA+IHJlbWFpbmluZykgbGVuZ3RoID0gcmVtYWluaW5nO1xuXG4gIGlmICgoc3RyaW5nLmxlbmd0aCA+IDAgJiYgKGxlbmd0aCA8IDAgfHwgb2Zmc2V0IDwgMCkpIHx8IG9mZnNldCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gd3JpdGUgb3V0c2lkZSBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnO1xuXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlO1xuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsYXRpbjFXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICAvLyBXYXJuaW5nOiBtYXhMZW5ndGggbm90IHRha2VuIGludG8gYWNjb3VudCBpbiBiYXNlNjRXcml0ZVxuICAgICAgICByZXR1cm4gYmFzZTY0V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHVjczJXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlO1xuICAgIH1cbiAgfVxufTtcblxuQnVmZmVyLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04gKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdCdWZmZXInLFxuICAgIGRhdGE6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuX2FyciB8fCB0aGlzLCAwKVxuICB9XG59O1xuXG5mdW5jdGlvbiBiYXNlNjRTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGlmIChzdGFydCA9PT0gMCAmJiBlbmQgPT09IGJ1Zi5sZW5ndGgpIHtcbiAgICByZXR1cm4gZnJvbUJ5dGVBcnJheShidWYpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZyb21CeXRlQXJyYXkoYnVmLnNsaWNlKHN0YXJ0LCBlbmQpKVxuICB9XG59XG5cbmZ1bmN0aW9uIHV0ZjhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZCk7XG4gIHZhciByZXMgPSBbXTtcblxuICB2YXIgaSA9IHN0YXJ0O1xuICB3aGlsZSAoaSA8IGVuZCkge1xuICAgIHZhciBmaXJzdEJ5dGUgPSBidWZbaV07XG4gICAgdmFyIGNvZGVQb2ludCA9IG51bGw7XG4gICAgdmFyIGJ5dGVzUGVyU2VxdWVuY2UgPSAoZmlyc3RCeXRlID4gMHhFRikgPyA0XG4gICAgICA6IChmaXJzdEJ5dGUgPiAweERGKSA/IDNcbiAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4QkYpID8gMlxuICAgICAgOiAxO1xuXG4gICAgaWYgKGkgKyBieXRlc1BlclNlcXVlbmNlIDw9IGVuZCkge1xuICAgICAgdmFyIHNlY29uZEJ5dGUsIHRoaXJkQnl0ZSwgZm91cnRoQnl0ZSwgdGVtcENvZGVQb2ludDtcblxuICAgICAgc3dpdGNoIChieXRlc1BlclNlcXVlbmNlKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBpZiAoZmlyc3RCeXRlIDwgMHg4MCkge1xuICAgICAgICAgICAgY29kZVBvaW50ID0gZmlyc3RCeXRlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV07XG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHgxRikgPDwgMHg2IHwgKHNlY29uZEJ5dGUgJiAweDNGKTtcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3Rikge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV07XG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXTtcbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweEMgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4NiB8ICh0aGlyZEJ5dGUgJiAweDNGKTtcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3RkYgJiYgKHRlbXBDb2RlUG9pbnQgPCAweEQ4MDAgfHwgdGVtcENvZGVQb2ludCA+IDB4REZGRikpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdO1xuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl07XG4gICAgICAgICAgZm91cnRoQnl0ZSA9IGJ1ZltpICsgM107XG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwICYmIChmb3VydGhCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweDEyIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweEMgfCAodGhpcmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKGZvdXJ0aEJ5dGUgJiAweDNGKTtcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHhGRkZGICYmIHRlbXBDb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY29kZVBvaW50ID09PSBudWxsKSB7XG4gICAgICAvLyB3ZSBkaWQgbm90IGdlbmVyYXRlIGEgdmFsaWQgY29kZVBvaW50IHNvIGluc2VydCBhXG4gICAgICAvLyByZXBsYWNlbWVudCBjaGFyIChVK0ZGRkQpIGFuZCBhZHZhbmNlIG9ubHkgMSBieXRlXG4gICAgICBjb2RlUG9pbnQgPSAweEZGRkQ7XG4gICAgICBieXRlc1BlclNlcXVlbmNlID0gMTtcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA+IDB4RkZGRikge1xuICAgICAgLy8gZW5jb2RlIHRvIHV0ZjE2IChzdXJyb2dhdGUgcGFpciBkYW5jZSlcbiAgICAgIGNvZGVQb2ludCAtPSAweDEwMDAwO1xuICAgICAgcmVzLnB1c2goY29kZVBvaW50ID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKTtcbiAgICAgIGNvZGVQb2ludCA9IDB4REMwMCB8IGNvZGVQb2ludCAmIDB4M0ZGO1xuICAgIH1cblxuICAgIHJlcy5wdXNoKGNvZGVQb2ludCk7XG4gICAgaSArPSBieXRlc1BlclNlcXVlbmNlO1xuICB9XG5cbiAgcmV0dXJuIGRlY29kZUNvZGVQb2ludHNBcnJheShyZXMpXG59XG5cbi8vIEJhc2VkIG9uIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzIyNzQ3MjcyLzY4MDc0MiwgdGhlIGJyb3dzZXIgd2l0aFxuLy8gdGhlIGxvd2VzdCBsaW1pdCBpcyBDaHJvbWUsIHdpdGggMHgxMDAwMCBhcmdzLlxuLy8gV2UgZ28gMSBtYWduaXR1ZGUgbGVzcywgZm9yIHNhZmV0eVxudmFyIE1BWF9BUkdVTUVOVFNfTEVOR1RIID0gMHgxMDAwO1xuXG5mdW5jdGlvbiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkgKGNvZGVQb2ludHMpIHtcbiAgdmFyIGxlbiA9IGNvZGVQb2ludHMubGVuZ3RoO1xuICBpZiAobGVuIDw9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjb2RlUG9pbnRzKSAvLyBhdm9pZCBleHRyYSBzbGljZSgpXG4gIH1cblxuICAvLyBEZWNvZGUgaW4gY2h1bmtzIHRvIGF2b2lkIFwiY2FsbCBzdGFjayBzaXplIGV4Y2VlZGVkXCIuXG4gIHZhciByZXMgPSAnJztcbiAgdmFyIGkgPSAwO1xuICB3aGlsZSAoaSA8IGxlbikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFxuICAgICAgU3RyaW5nLFxuICAgICAgY29kZVBvaW50cy5zbGljZShpLCBpICs9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKVxuICAgICk7XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnO1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpO1xuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldICYgMHg3Rik7XG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBsYXRpbjFTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJztcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKTtcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSk7XG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBoZXhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSBidWYubGVuZ3RoO1xuXG4gIGlmICghc3RhcnQgfHwgc3RhcnQgPCAwKSBzdGFydCA9IDA7XG4gIGlmICghZW5kIHx8IGVuZCA8IDAgfHwgZW5kID4gbGVuKSBlbmQgPSBsZW47XG5cbiAgdmFyIG91dCA9ICcnO1xuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIG91dCArPSB0b0hleChidWZbaV0pO1xuICB9XG4gIHJldHVybiBvdXRcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGJ5dGVzID0gYnVmLnNsaWNlKHN0YXJ0LCBlbmQpO1xuICB2YXIgcmVzID0gJyc7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSArIGJ5dGVzW2kgKyAxXSAqIDI1Nik7XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gc2xpY2UgKHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoO1xuICBzdGFydCA9IH5+c3RhcnQ7XG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuIDogfn5lbmQ7XG5cbiAgaWYgKHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ICs9IGxlbjtcbiAgICBpZiAoc3RhcnQgPCAwKSBzdGFydCA9IDA7XG4gIH0gZWxzZSBpZiAoc3RhcnQgPiBsZW4pIHtcbiAgICBzdGFydCA9IGxlbjtcbiAgfVxuXG4gIGlmIChlbmQgPCAwKSB7XG4gICAgZW5kICs9IGxlbjtcbiAgICBpZiAoZW5kIDwgMCkgZW5kID0gMDtcbiAgfSBlbHNlIGlmIChlbmQgPiBsZW4pIHtcbiAgICBlbmQgPSBsZW47XG4gIH1cblxuICBpZiAoZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0O1xuXG4gIHZhciBuZXdCdWY7XG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIG5ld0J1ZiA9IHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZCk7XG4gICAgbmV3QnVmLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGU7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHNsaWNlTGVuID0gZW5kIC0gc3RhcnQ7XG4gICAgbmV3QnVmID0gbmV3IEJ1ZmZlcihzbGljZUxlbiwgdW5kZWZpbmVkKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNsaWNlTGVuOyArK2kpIHtcbiAgICAgIG5ld0J1ZltpXSA9IHRoaXNbaSArIHN0YXJ0XTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3QnVmXG59O1xuXG4vKlxuICogTmVlZCB0byBtYWtlIHN1cmUgdGhhdCBidWZmZXIgaXNuJ3QgdHJ5aW5nIHRvIHdyaXRlIG91dCBvZiBib3VuZHMuXG4gKi9cbmZ1bmN0aW9uIGNoZWNrT2Zmc2V0IChvZmZzZXQsIGV4dCwgbGVuZ3RoKSB7XG4gIGlmICgob2Zmc2V0ICUgMSkgIT09IDAgfHwgb2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ29mZnNldCBpcyBub3QgdWludCcpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBsZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdUcnlpbmcgdG8gYWNjZXNzIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludExFID0gZnVuY3Rpb24gcmVhZFVJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwO1xuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDA7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpO1xuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF07XG4gIHZhciBtdWwgPSAxO1xuICB2YXIgaSA9IDA7XG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWw7XG4gIH1cblxuICByZXR1cm4gdmFsXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50QkUgPSBmdW5jdGlvbiByZWFkVUludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDA7XG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMDtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpO1xuICB9XG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXTtcbiAgdmFyIG11bCA9IDE7XG4gIHdoaWxlIChieXRlTGVuZ3RoID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF0gKiBtdWw7XG4gIH1cblxuICByZXR1cm4gdmFsXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50OCA9IGZ1bmN0aW9uIHJlYWRVSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKTtcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XVxufTtcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2TEUgPSBmdW5jdGlvbiByZWFkVUludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aCk7XG4gIHJldHVybiB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxufTtcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2QkUgPSBmdW5jdGlvbiByZWFkVUludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aCk7XG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDgpIHwgdGhpc1tvZmZzZXQgKyAxXVxufTtcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyTEUgPSBmdW5jdGlvbiByZWFkVUludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aCk7XG5cbiAgcmV0dXJuICgodGhpc1tvZmZzZXRdKSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikpICtcbiAgICAgICh0aGlzW29mZnNldCArIDNdICogMHgxMDAwMDAwKVxufTtcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyQkUgPSBmdW5jdGlvbiByZWFkVUludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aCk7XG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gKiAweDEwMDAwMDApICtcbiAgICAoKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgdGhpc1tvZmZzZXQgKyAzXSlcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludExFID0gZnVuY3Rpb24gcmVhZEludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDA7XG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMDtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aCk7XG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XTtcbiAgdmFyIG11bCA9IDE7XG4gIHZhciBpID0gMDtcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bDtcbiAgfVxuICBtdWwgKj0gMHg4MDtcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKTtcblxuICByZXR1cm4gdmFsXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRCRSA9IGZ1bmN0aW9uIHJlYWRJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwO1xuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDA7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpO1xuXG4gIHZhciBpID0gYnl0ZUxlbmd0aDtcbiAgdmFyIG11bCA9IDE7XG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0taV07XG4gIHdoaWxlIChpID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0taV0gKiBtdWw7XG4gIH1cbiAgbXVsICo9IDB4ODA7XG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCk7XG5cbiAgcmV0dXJuIHZhbFxufTtcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50OCA9IGZ1bmN0aW9uIHJlYWRJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpO1xuICBpZiAoISh0aGlzW29mZnNldF0gJiAweDgwKSkgcmV0dXJuICh0aGlzW29mZnNldF0pXG4gIHJldHVybiAoKDB4ZmYgLSB0aGlzW29mZnNldF0gKyAxKSAqIC0xKVxufTtcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpO1xuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCk7XG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2QkUgPSBmdW5jdGlvbiByZWFkSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKTtcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgMV0gfCAodGhpc1tvZmZzZXRdIDw8IDgpO1xuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkxFID0gZnVuY3Rpb24gcmVhZEludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aCk7XG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0pIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSA8PCAyNClcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyQkUgPSBmdW5jdGlvbiByZWFkSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKTtcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCAyNCkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDNdKVxufTtcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRMRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdExFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpO1xuICByZXR1cm4gcmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDIzLCA0KVxufTtcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRCRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdEJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpO1xuICByZXR1cm4gcmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCAyMywgNClcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUxFID0gZnVuY3Rpb24gcmVhZERvdWJsZUxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpO1xuICByZXR1cm4gcmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDUyLCA4KVxufTtcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlQkUgPSBmdW5jdGlvbiByZWFkRG91YmxlQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aCk7XG4gIHJldHVybiByZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDUyLCA4KVxufTtcblxuZnVuY3Rpb24gY2hlY2tJbnQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAoIWludGVybmFsSXNCdWZmZXIoYnVmKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJidWZmZXJcIiBhcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyIGluc3RhbmNlJylcbiAgaWYgKHZhbHVlID4gbWF4IHx8IHZhbHVlIDwgbWluKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJ2YWx1ZVwiIGFyZ3VtZW50IGlzIG91dCBvZiBib3VuZHMnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWU7XG4gIG9mZnNldCA9IG9mZnNldCB8IDA7XG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMDtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDE7XG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApO1xuICB9XG5cbiAgdmFyIG11bCA9IDE7XG4gIHZhciBpID0gMDtcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGO1xuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRjtcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludEJFID0gZnVuY3Rpb24gd3JpdGVVSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlO1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwO1xuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDA7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxO1xuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKTtcbiAgfVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDE7XG4gIHZhciBtdWwgPSAxO1xuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGO1xuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkY7XG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufTtcblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVVSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWU7XG4gIG9mZnNldCA9IG9mZnNldCB8IDA7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4ZmYsIDApO1xuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB2YWx1ZSA9IE1hdGguZmxvb3IodmFsdWUpO1xuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKTtcbiAgcmV0dXJuIG9mZnNldCArIDFcbn07XG5cbmZ1bmN0aW9uIG9iamVjdFdyaXRlVUludDE2IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbikge1xuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZiArIHZhbHVlICsgMTtcbiAgZm9yICh2YXIgaSA9IDAsIGogPSBNYXRoLm1pbihidWYubGVuZ3RoIC0gb2Zmc2V0LCAyKTsgaSA8IGo7ICsraSkge1xuICAgIGJ1ZltvZmZzZXQgKyBpXSA9ICh2YWx1ZSAmICgweGZmIDw8ICg4ICogKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkpKSkgPj4+XG4gICAgICAobGl0dGxlRW5kaWFuID8gaSA6IDEgLSBpKSAqIDg7XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWU7XG4gIG9mZnNldCA9IG9mZnNldCB8IDA7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMCk7XG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpO1xuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpO1xuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpO1xuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZTtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMDtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKTtcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KTtcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZik7XG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpO1xuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59O1xuXG5mdW5jdGlvbiBvYmplY3RXcml0ZVVJbnQzMiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxO1xuICBmb3IgKHZhciBpID0gMCwgaiA9IE1hdGgubWluKGJ1Zi5sZW5ndGggLSBvZmZzZXQsIDQpOyBpIDwgajsgKytpKSB7XG4gICAgYnVmW29mZnNldCArIGldID0gKHZhbHVlID4+PiAobGl0dGxlRW5kaWFuID8gaSA6IDMgLSBpKSAqIDgpICYgMHhmZjtcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZTtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMDtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMCk7XG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KTtcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNik7XG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOCk7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZik7XG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSk7XG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlO1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwO1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKTtcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNCk7XG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpO1xuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpO1xuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKTtcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSk7XG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlO1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwO1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGggLSAxKTtcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KTtcbiAgfVxuXG4gIHZhciBpID0gMDtcbiAgdmFyIG11bCA9IDE7XG4gIHZhciBzdWIgPSAwO1xuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkY7XG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpIC0gMV0gIT09IDApIHtcbiAgICAgIHN1YiA9IDE7XG4gICAgfVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkY7XG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufTtcblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludEJFID0gZnVuY3Rpb24gd3JpdGVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWU7XG4gIG9mZnNldCA9IG9mZnNldCB8IDA7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCAtIDEpO1xuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpO1xuICB9XG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMTtcbiAgdmFyIG11bCA9IDE7XG4gIHZhciBzdWIgPSAwO1xuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGO1xuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgKyAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMTtcbiAgICB9XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRjtcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50OCA9IGZ1bmN0aW9uIHdyaXRlSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWU7XG4gIG9mZnNldCA9IG9mZnNldCB8IDA7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4N2YsIC0weDgwKTtcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkgdmFsdWUgPSBNYXRoLmZsb29yKHZhbHVlKTtcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmICsgdmFsdWUgKyAxO1xuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKTtcbiAgcmV0dXJuIG9mZnNldCArIDFcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZTtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMDtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKTtcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZik7XG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOCk7XG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSk7XG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZTtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMDtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKTtcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KTtcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZik7XG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpO1xuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWU7XG4gIG9mZnNldCA9IG9mZnNldCB8IDA7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKTtcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZik7XG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOCk7XG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpO1xuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KTtcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKTtcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufTtcblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlO1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwO1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMCk7XG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMTtcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNCk7XG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpO1xuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpO1xuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKTtcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSk7XG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn07XG5cbmZ1bmN0aW9uIGNoZWNrSUVFRTc1NCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbiAgaWYgKG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5mdW5jdGlvbiB3cml0ZUZsb2F0IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDQpO1xuICB9XG4gIHdyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCAyMywgNCk7XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdExFID0gZnVuY3Rpb24gd3JpdGVGbG9hdExFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdEJFID0gZnVuY3Rpb24gd3JpdGVGbG9hdEJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59O1xuXG5mdW5jdGlvbiB3cml0ZURvdWJsZSAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA4KTtcbiAgfVxuICB3cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgNTIsIDgpO1xuICByZXR1cm4gb2Zmc2V0ICsgOFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlTEUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlQkUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufTtcblxuLy8gY29weSh0YXJnZXRCdWZmZXIsIHRhcmdldFN0YXJ0PTAsIHNvdXJjZVN0YXJ0PTAsIHNvdXJjZUVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gY29weSAodGFyZ2V0LCB0YXJnZXRTdGFydCwgc3RhcnQsIGVuZCkge1xuICBpZiAoIXN0YXJ0KSBzdGFydCA9IDA7XG4gIGlmICghZW5kICYmIGVuZCAhPT0gMCkgZW5kID0gdGhpcy5sZW5ndGg7XG4gIGlmICh0YXJnZXRTdGFydCA+PSB0YXJnZXQubGVuZ3RoKSB0YXJnZXRTdGFydCA9IHRhcmdldC5sZW5ndGg7XG4gIGlmICghdGFyZ2V0U3RhcnQpIHRhcmdldFN0YXJ0ID0gMDtcbiAgaWYgKGVuZCA+IDAgJiYgZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0O1xuXG4gIC8vIENvcHkgMCBieXRlczsgd2UncmUgZG9uZVxuICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuIDBcbiAgaWYgKHRhcmdldC5sZW5ndGggPT09IDAgfHwgdGhpcy5sZW5ndGggPT09IDApIHJldHVybiAwXG5cbiAgLy8gRmF0YWwgZXJyb3IgY29uZGl0aW9uc1xuICBpZiAodGFyZ2V0U3RhcnQgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3RhcmdldFN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICB9XG4gIGlmIChzdGFydCA8IDAgfHwgc3RhcnQgPj0gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgaWYgKGVuZCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VFbmQgb3V0IG9mIGJvdW5kcycpXG5cbiAgLy8gQXJlIHdlIG9vYj9cbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKSBlbmQgPSB0aGlzLmxlbmd0aDtcbiAgaWYgKHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCA8IGVuZCAtIHN0YXJ0KSB7XG4gICAgZW5kID0gdGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0ICsgc3RhcnQ7XG4gIH1cblxuICB2YXIgbGVuID0gZW5kIC0gc3RhcnQ7XG4gIHZhciBpO1xuXG4gIGlmICh0aGlzID09PSB0YXJnZXQgJiYgc3RhcnQgPCB0YXJnZXRTdGFydCAmJiB0YXJnZXRTdGFydCA8IGVuZCkge1xuICAgIC8vIGRlc2NlbmRpbmcgY29weSBmcm9tIGVuZFxuICAgIGZvciAoaSA9IGxlbiAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICB0YXJnZXRbaSArIHRhcmdldFN0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XTtcbiAgICB9XG4gIH0gZWxzZSBpZiAobGVuIDwgMTAwMCB8fCAhQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAvLyBhc2NlbmRpbmcgY29weSBmcm9tIHN0YXJ0XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICB0YXJnZXRbaSArIHRhcmdldFN0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgVWludDhBcnJheS5wcm90b3R5cGUuc2V0LmNhbGwoXG4gICAgICB0YXJnZXQsXG4gICAgICB0aGlzLnN1YmFycmF5KHN0YXJ0LCBzdGFydCArIGxlbiksXG4gICAgICB0YXJnZXRTdGFydFxuICAgICk7XG4gIH1cblxuICByZXR1cm4gbGVuXG59O1xuXG4vLyBVc2FnZTpcbi8vICAgIGJ1ZmZlci5maWxsKG51bWJlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoYnVmZmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChzdHJpbmdbLCBvZmZzZXRbLCBlbmRdXVssIGVuY29kaW5nXSlcbkJ1ZmZlci5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uIGZpbGwgKHZhbCwgc3RhcnQsIGVuZCwgZW5jb2RpbmcpIHtcbiAgLy8gSGFuZGxlIHN0cmluZyBjYXNlczpcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKHR5cGVvZiBzdGFydCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gc3RhcnQ7XG4gICAgICBzdGFydCA9IDA7XG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aDtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBlbmQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IGVuZDtcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoO1xuICAgIH1cbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdmFyIGNvZGUgPSB2YWwuY2hhckNvZGVBdCgwKTtcbiAgICAgIGlmIChjb2RlIDwgMjU2KSB7XG4gICAgICAgIHZhbCA9IGNvZGU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2VuY29kaW5nIG11c3QgYmUgYSBzdHJpbmcnKVxuICAgIH1cbiAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJyAmJiAhQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMjU1O1xuICB9XG5cbiAgLy8gSW52YWxpZCByYW5nZXMgYXJlIG5vdCBzZXQgdG8gYSBkZWZhdWx0LCBzbyBjYW4gcmFuZ2UgY2hlY2sgZWFybHkuXG4gIGlmIChzdGFydCA8IDAgfHwgdGhpcy5sZW5ndGggPCBzdGFydCB8fCB0aGlzLmxlbmd0aCA8IGVuZCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdPdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBzdGFydCA9IHN0YXJ0ID4+PiAwO1xuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IHRoaXMubGVuZ3RoIDogZW5kID4+PiAwO1xuXG4gIGlmICghdmFsKSB2YWwgPSAwO1xuXG4gIHZhciBpO1xuICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgICB0aGlzW2ldID0gdmFsO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgYnl0ZXMgPSBpbnRlcm5hbElzQnVmZmVyKHZhbClcbiAgICAgID8gdmFsXG4gICAgICA6IHV0ZjhUb0J5dGVzKG5ldyBCdWZmZXIodmFsLCBlbmNvZGluZykudG9TdHJpbmcoKSk7XG4gICAgdmFyIGxlbiA9IGJ5dGVzLmxlbmd0aDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgZW5kIC0gc3RhcnQ7ICsraSkge1xuICAgICAgdGhpc1tpICsgc3RhcnRdID0gYnl0ZXNbaSAlIGxlbl07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXNcbn07XG5cbi8vIEhFTFBFUiBGVU5DVElPTlNcbi8vID09PT09PT09PT09PT09PT1cblxudmFyIElOVkFMSURfQkFTRTY0X1JFID0gL1teK1xcLzAtOUEtWmEtei1fXS9nO1xuXG5mdW5jdGlvbiBiYXNlNjRjbGVhbiAoc3RyKSB7XG4gIC8vIE5vZGUgc3RyaXBzIG91dCBpbnZhbGlkIGNoYXJhY3RlcnMgbGlrZSBcXG4gYW5kIFxcdCBmcm9tIHRoZSBzdHJpbmcsIGJhc2U2NC1qcyBkb2VzIG5vdFxuICBzdHIgPSBzdHJpbmd0cmltKHN0cikucmVwbGFjZShJTlZBTElEX0JBU0U2NF9SRSwgJycpO1xuICAvLyBOb2RlIGNvbnZlcnRzIHN0cmluZ3Mgd2l0aCBsZW5ndGggPCAyIHRvICcnXG4gIGlmIChzdHIubGVuZ3RoIDwgMikgcmV0dXJuICcnXG4gIC8vIE5vZGUgYWxsb3dzIGZvciBub24tcGFkZGVkIGJhc2U2NCBzdHJpbmdzIChtaXNzaW5nIHRyYWlsaW5nID09PSksIGJhc2U2NC1qcyBkb2VzIG5vdFxuICB3aGlsZSAoc3RyLmxlbmd0aCAlIDQgIT09IDApIHtcbiAgICBzdHIgPSBzdHIgKyAnPSc7XG4gIH1cbiAgcmV0dXJuIHN0clxufVxuXG5mdW5jdGlvbiBzdHJpbmd0cmltIChzdHIpIHtcbiAgaWYgKHN0ci50cmltKSByZXR1cm4gc3RyLnRyaW0oKVxuICByZXR1cm4gc3RyLnJlcGxhY2UoL15cXHMrfFxccyskL2csICcnKVxufVxuXG5mdW5jdGlvbiB0b0hleCAobikge1xuICBpZiAobiA8IDE2KSByZXR1cm4gJzAnICsgbi50b1N0cmluZygxNilcbiAgcmV0dXJuIG4udG9TdHJpbmcoMTYpXG59XG5cbmZ1bmN0aW9uIHV0ZjhUb0J5dGVzIChzdHJpbmcsIHVuaXRzKSB7XG4gIHVuaXRzID0gdW5pdHMgfHwgSW5maW5pdHk7XG4gIHZhciBjb2RlUG9pbnQ7XG4gIHZhciBsZW5ndGggPSBzdHJpbmcubGVuZ3RoO1xuICB2YXIgbGVhZFN1cnJvZ2F0ZSA9IG51bGw7XG4gIHZhciBieXRlcyA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBjb2RlUG9pbnQgPSBzdHJpbmcuY2hhckNvZGVBdChpKTtcblxuICAgIC8vIGlzIHN1cnJvZ2F0ZSBjb21wb25lbnRcbiAgICBpZiAoY29kZVBvaW50ID4gMHhEN0ZGICYmIGNvZGVQb2ludCA8IDB4RTAwMCkge1xuICAgICAgLy8gbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICghbGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgICAvLyBubyBsZWFkIHlldFxuICAgICAgICBpZiAoY29kZVBvaW50ID4gMHhEQkZGKSB7XG4gICAgICAgICAgLy8gdW5leHBlY3RlZCB0cmFpbFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKTtcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9IGVsc2UgaWYgKGkgKyAxID09PSBsZW5ndGgpIHtcbiAgICAgICAgICAvLyB1bnBhaXJlZCBsZWFkXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpO1xuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyB2YWxpZCBsZWFkXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnQ7XG5cbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gMiBsZWFkcyBpbiBhIHJvd1xuICAgICAgaWYgKGNvZGVQb2ludCA8IDB4REMwMCkge1xuICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRCk7XG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnQ7XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIHZhbGlkIHN1cnJvZ2F0ZSBwYWlyXG4gICAgICBjb2RlUG9pbnQgPSAobGVhZFN1cnJvZ2F0ZSAtIDB4RDgwMCA8PCAxMCB8IGNvZGVQb2ludCAtIDB4REMwMCkgKyAweDEwMDAwO1xuICAgIH0gZWxzZSBpZiAobGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgLy8gdmFsaWQgYm1wIGNoYXIsIGJ1dCBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpO1xuICAgIH1cblxuICAgIGxlYWRTdXJyb2dhdGUgPSBudWxsO1xuXG4gICAgLy8gZW5jb2RlIHV0ZjhcbiAgICBpZiAoY29kZVBvaW50IDwgMHg4MCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAxKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKGNvZGVQb2ludCk7XG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDgwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2IHwgMHhDMCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgICk7XG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDMpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgfCAweEUwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gNCkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4MTIgfCAweEYwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjb2RlIHBvaW50JylcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnl0ZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlUb0J5dGVzIChzdHIpIHtcbiAgdmFyIGJ5dGVBcnJheSA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIC8vIE5vZGUncyBjb2RlIHNlZW1zIHRvIGJlIGRvaW5nIHRoaXMgYW5kIG5vdCAmIDB4N0YuLlxuICAgIGJ5dGVBcnJheS5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpICYgMHhGRik7XG4gIH1cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiB1dGYxNmxlVG9CeXRlcyAoc3RyLCB1bml0cykge1xuICB2YXIgYywgaGksIGxvO1xuICB2YXIgYnl0ZUFycmF5ID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG5cbiAgICBjID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgaGkgPSBjID4+IDg7XG4gICAgbG8gPSBjICUgMjU2O1xuICAgIGJ5dGVBcnJheS5wdXNoKGxvKTtcbiAgICBieXRlQXJyYXkucHVzaChoaSk7XG4gIH1cblxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cblxuZnVuY3Rpb24gYmFzZTY0VG9CeXRlcyAoc3RyKSB7XG4gIHJldHVybiB0b0J5dGVBcnJheShiYXNlNjRjbGVhbihzdHIpKVxufVxuXG5mdW5jdGlvbiBibGl0QnVmZmVyIChzcmMsIGRzdCwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGlmICgoaSArIG9mZnNldCA+PSBkc3QubGVuZ3RoKSB8fCAoaSA+PSBzcmMubGVuZ3RoKSkgYnJlYWtcbiAgICBkc3RbaSArIG9mZnNldF0gPSBzcmNbaV07XG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gaXNuYW4gKHZhbCkge1xuICByZXR1cm4gdmFsICE9PSB2YWwgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zZWxmLWNvbXBhcmVcbn1cblxuXG4vLyB0aGUgZm9sbG93aW5nIGlzIGZyb20gaXMtYnVmZmVyLCBhbHNvIGJ5IEZlcm9zcyBBYm91a2hhZGlqZWggYW5kIHdpdGggc2FtZSBsaXNlbmNlXG4vLyBUaGUgX2lzQnVmZmVyIGNoZWNrIGlzIGZvciBTYWZhcmkgNS03IHN1cHBvcnQsIGJlY2F1c2UgaXQncyBtaXNzaW5nXG4vLyBPYmplY3QucHJvdG90eXBlLmNvbnN0cnVjdG9yLiBSZW1vdmUgdGhpcyBldmVudHVhbGx5XG5mdW5jdGlvbiBpc0J1ZmZlcihvYmopIHtcbiAgcmV0dXJuIG9iaiAhPSBudWxsICYmICghIW9iai5faXNCdWZmZXIgfHwgaXNGYXN0QnVmZmVyKG9iaikgfHwgaXNTbG93QnVmZmVyKG9iaikpXG59XG5cbmZ1bmN0aW9uIGlzRmFzdEJ1ZmZlciAob2JqKSB7XG4gIHJldHVybiAhIW9iai5jb25zdHJ1Y3RvciAmJiB0eXBlb2Ygb2JqLmNvbnN0cnVjdG9yLmlzQnVmZmVyID09PSAnZnVuY3Rpb24nICYmIG9iai5jb25zdHJ1Y3Rvci5pc0J1ZmZlcihvYmopXG59XG5cbi8vIEZvciBOb2RlIHYwLjEwIHN1cHBvcnQuIFJlbW92ZSB0aGlzIGV2ZW50dWFsbHkuXG5mdW5jdGlvbiBpc1Nsb3dCdWZmZXIgKG9iaikge1xuICByZXR1cm4gdHlwZW9mIG9iai5yZWFkRmxvYXRMRSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2Ygb2JqLnNsaWNlID09PSAnZnVuY3Rpb24nICYmIGlzRmFzdEJ1ZmZlcihvYmouc2xpY2UoMCwgMCkpXG59XG5cbmNvbnN0IGlzSGV4U3RyaW5nID0gKGhleCkgPT4gdHlwZW9mIGhleCA9PT0gJ3N0cmluZycgJiYgL14weFswLTlBLUZhLWZdKiQvLnRlc3QoaGV4KTtcbmNvbnN0IHV0ZjhUb0hleCA9IChzdHIpID0+IHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20oc3RyLCAndXRmOCcpLnRvU3RyaW5nKCdoZXgnKTtcbn07XG5cbmNvbnN0IGlzVmFsaWRUcmFuc2FjdGlvbiA9ICh0cmFuc2FjdGlvbikgPT4ge1xuICAgIGlmICghdHJhbnNhY3Rpb24gfHxcbiAgICAgICAgdHlwZW9mIHRyYW5zYWN0aW9uICE9PSAnb2JqZWN0JyB8fFxuICAgICAgICAhKCdmcm9tJyBpbiB0cmFuc2FjdGlvbikpIHtcbiAgICAgICAgcmV0dXJuIHsgaXNWYWxpZDogZmFsc2UsIGludmFsaWRNc2c6IEVSUk9SX01FU1NBR0UuSU5WQUxJRF9UUkFOU0FDVElPTiB9O1xuICAgIH1cbiAgICBpZiAodHJhbnNhY3Rpb24udmFsdWUgJiYgIWlzSGV4U3RyaW5nKHRyYW5zYWN0aW9uLnZhbHVlKSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaXNWYWxpZDogZmFsc2UsXG4gICAgICAgICAgICBpbnZhbGlkTXNnOiBFUlJPUl9NRVNTQUdFLklOVkFMSURfVFJBTlNBQ1RJT05fVkFMVUUsXG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB7IGlzVmFsaWQ6IHRydWUgfTtcbn07XG5jb25zdCBpc1ZhbGlkVHJhbnNhY3Rpb25zID0gKHRyYW5zYWN0aW9ucykgPT4ge1xuICAgIGlmICghQXJyYXkuaXNBcnJheSh0cmFuc2FjdGlvbnMpKSB7XG4gICAgICAgIHJldHVybiB7IGlzVmFsaWQ6IGZhbHNlLCBpbnZhbGlkTXNnOiBFUlJPUl9NRVNTQUdFLklOVkFMSURfVFJBTlNBQ1RJT05TIH07XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdHJhbnNhY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHsgaXNWYWxpZCwgaW52YWxpZE1zZyB9ID0gaXNWYWxpZFRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uc1tpXSk7XG4gICAgICAgIGlmICghaXNWYWxpZCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgaXNWYWxpZCwgaW52YWxpZE1zZyB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IGlzVmFsaWQ6IHRydWUgfTtcbn07XG5cbmZ1bmN0aW9uIGdldEV2bVN1cHBvcnQoKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgY29uc3QgeyBuZXR3b3JrcyB9ID0geWllbGQgZmV0Y2goJ2h0dHBzOi8vYXBpLmJsb2N0by5hcHAvbmV0d29ya3MvZXZtJykudGhlbigocmVzcG9uc2UpID0+IHJlc3BvbnNlLmpzb24oKSk7XG4gICAgICAgIGNvbnN0IGV2bVN1cHBvcnRNYXAgPSBuZXR3b3Jrcy5yZWR1Y2UoKGEsIHYpID0+IChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGEpLCB7IFt2LmNoYWluX2lkXTogdiB9KSksIHt9KTtcbiAgICAgICAgcmV0dXJuIGV2bVN1cHBvcnRNYXA7XG4gICAgfSk7XG59XG5cbnZhciBkaXN0ID0ge307XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF90eXBlb2Yobykge1xuICBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7XG5cbiAgcmV0dXJuIF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAobykge1xuICAgIHJldHVybiB0eXBlb2YgbztcbiAgfSA6IGZ1bmN0aW9uIChvKSB7XG4gICAgcmV0dXJuIG8gJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgby5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG8gIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG87XG4gIH0sIF90eXBlb2Yobyk7XG59XG5cbmZ1bmN0aW9uIF90b1ByaW1pdGl2ZShpbnB1dCwgaGludCkge1xuICBpZiAoX3R5cGVvZihpbnB1dCkgIT09IFwib2JqZWN0XCIgfHwgaW5wdXQgPT09IG51bGwpIHJldHVybiBpbnB1dDtcbiAgdmFyIHByaW0gPSBpbnB1dFtTeW1ib2wudG9QcmltaXRpdmVdO1xuICBpZiAocHJpbSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIHJlcyA9IHByaW0uY2FsbChpbnB1dCwgaGludCB8fCBcImRlZmF1bHRcIik7XG4gICAgaWYgKF90eXBlb2YocmVzKSAhPT0gXCJvYmplY3RcIikgcmV0dXJuIHJlcztcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7XG4gIH1cbiAgcmV0dXJuIChoaW50ID09PSBcInN0cmluZ1wiID8gU3RyaW5nIDogTnVtYmVyKShpbnB1dCk7XG59XG5cbmZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KGFyZykge1xuICB2YXIga2V5ID0gX3RvUHJpbWl0aXZlKGFyZywgXCJzdHJpbmdcIik7XG4gIHJldHVybiBfdHlwZW9mKGtleSkgPT09IFwic3ltYm9sXCIgPyBrZXkgOiBTdHJpbmcoa2V5KTtcbn1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgX3RvUHJvcGVydHlLZXkoZGVzY3JpcHRvci5rZXkpLCBkZXNjcmlwdG9yKTtcbiAgfVxufVxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29uc3RydWN0b3IsIFwicHJvdG90eXBlXCIsIHtcbiAgICB3cml0YWJsZTogZmFsc2VcbiAgfSk7XG4gIHJldHVybiBDb25zdHJ1Y3Rvcjtcbn1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgby5fX3Byb3RvX18gPSBwO1xuICAgIHJldHVybiBvO1xuICB9O1xuICByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApO1xufVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTtcbiAgfVxuICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHtcbiAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgdmFsdWU6IHN1YkNsYXNzLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9XG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc3ViQ2xhc3MsIFwicHJvdG90eXBlXCIsIHtcbiAgICB3cml0YWJsZTogZmFsc2VcbiAgfSk7XG4gIGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpO1xufVxuXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHtcbiAgaWYgKHNlbGYgPT09IHZvaWQgMCkge1xuICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgfVxuICByZXR1cm4gc2VsZjtcbn1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkge1xuICBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkge1xuICAgIHJldHVybiBjYWxsO1xuICB9IGVsc2UgaWYgKGNhbGwgIT09IHZvaWQgMCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJEZXJpdmVkIGNvbnN0cnVjdG9ycyBtYXkgb25seSByZXR1cm4gb2JqZWN0IG9yIHVuZGVmaW5lZFwiKTtcbiAgfVxuICByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTtcbn1cblxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gICAgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTtcbiAgfTtcbiAgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTtcbn1cblxuZnVuY3Rpb24gX2lzTmF0aXZlRnVuY3Rpb24oZm4pIHtcbiAgcmV0dXJuIEZ1bmN0aW9uLnRvU3RyaW5nLmNhbGwoZm4pLmluZGV4T2YoXCJbbmF0aXZlIGNvZGVdXCIpICE9PSAtMTtcbn1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCQxKCkge1xuICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7XG4gIGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7XG4gIGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7XG4gIHRyeSB7XG4gICAgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9jb25zdHJ1Y3QoUGFyZW50LCBhcmdzLCBDbGFzcykge1xuICBpZiAoX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCQxKCkpIHtcbiAgICBfY29uc3RydWN0ID0gUmVmbGVjdC5jb25zdHJ1Y3QuYmluZCgpO1xuICB9IGVsc2Uge1xuICAgIF9jb25zdHJ1Y3QgPSBmdW5jdGlvbiBfY29uc3RydWN0KFBhcmVudCwgYXJncywgQ2xhc3MpIHtcbiAgICAgIHZhciBhID0gW251bGxdO1xuICAgICAgYS5wdXNoLmFwcGx5KGEsIGFyZ3MpO1xuICAgICAgdmFyIENvbnN0cnVjdG9yID0gRnVuY3Rpb24uYmluZC5hcHBseShQYXJlbnQsIGEpO1xuICAgICAgdmFyIGluc3RhbmNlID0gbmV3IENvbnN0cnVjdG9yKCk7XG4gICAgICBpZiAoQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihpbnN0YW5jZSwgQ2xhc3MucHJvdG90eXBlKTtcbiAgICAgIHJldHVybiBpbnN0YW5jZTtcbiAgICB9O1xuICB9XG4gIHJldHVybiBfY29uc3RydWN0LmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF93cmFwTmF0aXZlU3VwZXIoQ2xhc3MpIHtcbiAgdmFyIF9jYWNoZSA9IHR5cGVvZiBNYXAgPT09IFwiZnVuY3Rpb25cIiA/IG5ldyBNYXAoKSA6IHVuZGVmaW5lZDtcbiAgX3dyYXBOYXRpdmVTdXBlciA9IGZ1bmN0aW9uIF93cmFwTmF0aXZlU3VwZXIoQ2xhc3MpIHtcbiAgICBpZiAoQ2xhc3MgPT09IG51bGwgfHwgIV9pc05hdGl2ZUZ1bmN0aW9uKENsYXNzKSkgcmV0dXJuIENsYXNzO1xuICAgIGlmICh0eXBlb2YgQ2xhc3MgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIF9jYWNoZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgaWYgKF9jYWNoZS5oYXMoQ2xhc3MpKSByZXR1cm4gX2NhY2hlLmdldChDbGFzcyk7XG4gICAgICBfY2FjaGUuc2V0KENsYXNzLCBXcmFwcGVyKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gV3JhcHBlcigpIHtcbiAgICAgIHJldHVybiBfY29uc3RydWN0KENsYXNzLCBhcmd1bWVudHMsIF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3Rvcik7XG4gICAgfVxuICAgIFdyYXBwZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShDbGFzcy5wcm90b3R5cGUsIHtcbiAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgIHZhbHVlOiBXcmFwcGVyLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBfc2V0UHJvdG90eXBlT2YoV3JhcHBlciwgQ2xhc3MpO1xuICB9O1xuICByZXR1cm4gX3dyYXBOYXRpdmVTdXBlcihDbGFzcyk7XG59XG5cbnZhciBjbGFzc2VzID0ge307XG5cbnZhciBmYXN0U2FmZVN0cmluZ2lmeSA9IHN0cmluZ2lmeTtcbnN0cmluZ2lmeVtcImRlZmF1bHRcIl0gPSBzdHJpbmdpZnk7XG5zdHJpbmdpZnkuc3RhYmxlID0gZGV0ZXJtaW5pc3RpY1N0cmluZ2lmeTtcbnN0cmluZ2lmeS5zdGFibGVTdHJpbmdpZnkgPSBkZXRlcm1pbmlzdGljU3RyaW5naWZ5O1xudmFyIExJTUlUX1JFUExBQ0VfTk9ERSA9ICdbLi4uXSc7XG52YXIgQ0lSQ1VMQVJfUkVQTEFDRV9OT0RFID0gJ1tDaXJjdWxhcl0nO1xudmFyIGFyciA9IFtdO1xudmFyIHJlcGxhY2VyU3RhY2sgPSBbXTtcbmZ1bmN0aW9uIGRlZmF1bHRPcHRpb25zKCkge1xuICByZXR1cm4ge1xuICAgIGRlcHRoTGltaXQ6IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSLFxuICAgIGVkZ2VzTGltaXQ6IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSXG4gIH07XG59XG5cbi8vIFJlZ3VsYXIgc3RyaW5naWZ5XG5mdW5jdGlvbiBzdHJpbmdpZnkob2JqLCByZXBsYWNlciwgc3BhY2VyLCBvcHRpb25zKSB7XG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBvcHRpb25zID0gZGVmYXVsdE9wdGlvbnMoKTtcbiAgfVxuICBkZWNpcmMob2JqLCAnJywgMCwgW10sIHVuZGVmaW5lZCwgMCwgb3B0aW9ucyk7XG4gIHZhciByZXM7XG4gIHRyeSB7XG4gICAgaWYgKHJlcGxhY2VyU3RhY2subGVuZ3RoID09PSAwKSB7XG4gICAgICByZXMgPSBKU09OLnN0cmluZ2lmeShvYmosIHJlcGxhY2VyLCBzcGFjZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXMgPSBKU09OLnN0cmluZ2lmeShvYmosIHJlcGxhY2VHZXR0ZXJWYWx1ZXMocmVwbGFjZXIpLCBzcGFjZXIpO1xuICAgIH1cbiAgfSBjYXRjaCAoXykge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSgnW3VuYWJsZSB0byBzZXJpYWxpemUsIGNpcmN1bGFyIHJlZmVyZW5jZSBpcyB0b28gY29tcGxleCB0byBhbmFseXplXScpO1xuICB9IGZpbmFsbHkge1xuICAgIHdoaWxlIChhcnIubGVuZ3RoICE9PSAwKSB7XG4gICAgICB2YXIgcGFydCA9IGFyci5wb3AoKTtcbiAgICAgIGlmIChwYXJ0Lmxlbmd0aCA9PT0gNCkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocGFydFswXSwgcGFydFsxXSwgcGFydFszXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJ0WzBdW3BhcnRbMV1dID0gcGFydFsyXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cbmZ1bmN0aW9uIHNldFJlcGxhY2UocmVwbGFjZSwgdmFsLCBrLCBwYXJlbnQpIHtcbiAgdmFyIHByb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IocGFyZW50LCBrKTtcbiAgaWYgKHByb3BlcnR5RGVzY3JpcHRvci5nZXQgIT09IHVuZGVmaW5lZCkge1xuICAgIGlmIChwcm9wZXJ0eURlc2NyaXB0b3IuY29uZmlndXJhYmxlKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocGFyZW50LCBrLCB7XG4gICAgICAgIHZhbHVlOiByZXBsYWNlXG4gICAgICB9KTtcbiAgICAgIGFyci5wdXNoKFtwYXJlbnQsIGssIHZhbCwgcHJvcGVydHlEZXNjcmlwdG9yXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlcGxhY2VyU3RhY2sucHVzaChbdmFsLCBrLCByZXBsYWNlXSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHBhcmVudFtrXSA9IHJlcGxhY2U7XG4gICAgYXJyLnB1c2goW3BhcmVudCwgaywgdmFsXSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGRlY2lyYyh2YWwsIGssIGVkZ2VJbmRleCwgc3RhY2ssIHBhcmVudCwgZGVwdGgsIG9wdGlvbnMpIHtcbiAgZGVwdGggKz0gMTtcbiAgdmFyIGk7XG4gIGlmIChfdHlwZW9mKHZhbCkgPT09ICdvYmplY3QnICYmIHZhbCAhPT0gbnVsbCkge1xuICAgIGZvciAoaSA9IDA7IGkgPCBzdGFjay5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHN0YWNrW2ldID09PSB2YWwpIHtcbiAgICAgICAgc2V0UmVwbGFjZShDSVJDVUxBUl9SRVBMQUNFX05PREUsIHZhbCwgaywgcGFyZW50KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZGVwdGhMaW1pdCAhPT0gJ3VuZGVmaW5lZCcgJiYgZGVwdGggPiBvcHRpb25zLmRlcHRoTGltaXQpIHtcbiAgICAgIHNldFJlcGxhY2UoTElNSVRfUkVQTEFDRV9OT0RFLCB2YWwsIGssIHBhcmVudCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5lZGdlc0xpbWl0ICE9PSAndW5kZWZpbmVkJyAmJiBlZGdlSW5kZXggKyAxID4gb3B0aW9ucy5lZGdlc0xpbWl0KSB7XG4gICAgICBzZXRSZXBsYWNlKExJTUlUX1JFUExBQ0VfTk9ERSwgdmFsLCBrLCBwYXJlbnQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzdGFjay5wdXNoKHZhbCk7XG4gICAgLy8gT3B0aW1pemUgZm9yIEFycmF5cy4gQmlnIGFycmF5cyBjb3VsZCBraWxsIHRoZSBwZXJmb3JtYW5jZSBvdGhlcndpc2UhXG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgICAgZm9yIChpID0gMDsgaSA8IHZhbC5sZW5ndGg7IGkrKykge1xuICAgICAgICBkZWNpcmModmFsW2ldLCBpLCBpLCBzdGFjaywgdmFsLCBkZXB0aCwgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXModmFsKTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgICBkZWNpcmModmFsW2tleV0sIGtleSwgaSwgc3RhY2ssIHZhbCwgZGVwdGgsIG9wdGlvbnMpO1xuICAgICAgfVxuICAgIH1cbiAgICBzdGFjay5wb3AoKTtcbiAgfVxufVxuXG4vLyBTdGFibGUtc3RyaW5naWZ5XG5mdW5jdGlvbiBjb21wYXJlRnVuY3Rpb24oYSwgYikge1xuICBpZiAoYSA8IGIpIHtcbiAgICByZXR1cm4gLTE7XG4gIH1cbiAgaWYgKGEgPiBiKSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5mdW5jdGlvbiBkZXRlcm1pbmlzdGljU3RyaW5naWZ5KG9iaiwgcmVwbGFjZXIsIHNwYWNlciwgb3B0aW9ucykge1xuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgb3B0aW9ucyA9IGRlZmF1bHRPcHRpb25zKCk7XG4gIH1cbiAgdmFyIHRtcCA9IGRldGVybWluaXN0aWNEZWNpcmMob2JqLCAnJywgMCwgW10sIHVuZGVmaW5lZCwgMCwgb3B0aW9ucykgfHwgb2JqO1xuICB2YXIgcmVzO1xuICB0cnkge1xuICAgIGlmIChyZXBsYWNlclN0YWNrLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmVzID0gSlNPTi5zdHJpbmdpZnkodG1wLCByZXBsYWNlciwgc3BhY2VyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzID0gSlNPTi5zdHJpbmdpZnkodG1wLCByZXBsYWNlR2V0dGVyVmFsdWVzKHJlcGxhY2VyKSwgc3BhY2VyKTtcbiAgICB9XG4gIH0gY2F0Y2ggKF8pIHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoJ1t1bmFibGUgdG8gc2VyaWFsaXplLCBjaXJjdWxhciByZWZlcmVuY2UgaXMgdG9vIGNvbXBsZXggdG8gYW5hbHl6ZV0nKTtcbiAgfSBmaW5hbGx5IHtcbiAgICAvLyBFbnN1cmUgdGhhdCB3ZSByZXN0b3JlIHRoZSBvYmplY3QgYXMgaXQgd2FzLlxuICAgIHdoaWxlIChhcnIubGVuZ3RoICE9PSAwKSB7XG4gICAgICB2YXIgcGFydCA9IGFyci5wb3AoKTtcbiAgICAgIGlmIChwYXJ0Lmxlbmd0aCA9PT0gNCkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocGFydFswXSwgcGFydFsxXSwgcGFydFszXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJ0WzBdW3BhcnRbMV1dID0gcGFydFsyXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cbmZ1bmN0aW9uIGRldGVybWluaXN0aWNEZWNpcmModmFsLCBrLCBlZGdlSW5kZXgsIHN0YWNrLCBwYXJlbnQsIGRlcHRoLCBvcHRpb25zKSB7XG4gIGRlcHRoICs9IDE7XG4gIHZhciBpO1xuICBpZiAoX3R5cGVvZih2YWwpID09PSAnb2JqZWN0JyAmJiB2YWwgIT09IG51bGwpIHtcbiAgICBmb3IgKGkgPSAwOyBpIDwgc3RhY2subGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChzdGFja1tpXSA9PT0gdmFsKSB7XG4gICAgICAgIHNldFJlcGxhY2UoQ0lSQ1VMQVJfUkVQTEFDRV9OT0RFLCB2YWwsIGssIHBhcmVudCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGlmICh0eXBlb2YgdmFsLnRvSlNPTiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfSBjYXRjaCAoXykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZGVwdGhMaW1pdCAhPT0gJ3VuZGVmaW5lZCcgJiYgZGVwdGggPiBvcHRpb25zLmRlcHRoTGltaXQpIHtcbiAgICAgIHNldFJlcGxhY2UoTElNSVRfUkVQTEFDRV9OT0RFLCB2YWwsIGssIHBhcmVudCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5lZGdlc0xpbWl0ICE9PSAndW5kZWZpbmVkJyAmJiBlZGdlSW5kZXggKyAxID4gb3B0aW9ucy5lZGdlc0xpbWl0KSB7XG4gICAgICBzZXRSZXBsYWNlKExJTUlUX1JFUExBQ0VfTk9ERSwgdmFsLCBrLCBwYXJlbnQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzdGFjay5wdXNoKHZhbCk7XG4gICAgLy8gT3B0aW1pemUgZm9yIEFycmF5cy4gQmlnIGFycmF5cyBjb3VsZCBraWxsIHRoZSBwZXJmb3JtYW5jZSBvdGhlcndpc2UhXG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgICAgZm9yIChpID0gMDsgaSA8IHZhbC5sZW5ndGg7IGkrKykge1xuICAgICAgICBkZXRlcm1pbmlzdGljRGVjaXJjKHZhbFtpXSwgaSwgaSwgc3RhY2ssIHZhbCwgZGVwdGgsIG9wdGlvbnMpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBDcmVhdGUgYSB0ZW1wb3Jhcnkgb2JqZWN0IGluIHRoZSByZXF1aXJlZCB3YXlcbiAgICAgIHZhciB0bXAgPSB7fTtcbiAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXModmFsKS5zb3J0KGNvbXBhcmVGdW5jdGlvbik7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgZGV0ZXJtaW5pc3RpY0RlY2lyYyh2YWxba2V5XSwga2V5LCBpLCBzdGFjaywgdmFsLCBkZXB0aCwgb3B0aW9ucyk7XG4gICAgICAgIHRtcFtrZXldID0gdmFsW2tleV07XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHBhcmVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgYXJyLnB1c2goW3BhcmVudCwgaywgdmFsXSk7XG4gICAgICAgIHBhcmVudFtrXSA9IHRtcDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0bXA7XG4gICAgICB9XG4gICAgfVxuICAgIHN0YWNrLnBvcCgpO1xuICB9XG59XG5cbi8vIHdyYXBzIHJlcGxhY2VyIGZ1bmN0aW9uIHRvIGhhbmRsZSB2YWx1ZXMgd2UgY291bGRuJ3QgcmVwbGFjZVxuLy8gYW5kIG1hcmsgdGhlbSBhcyByZXBsYWNlZCB2YWx1ZVxuZnVuY3Rpb24gcmVwbGFjZUdldHRlclZhbHVlcyhyZXBsYWNlcikge1xuICByZXBsYWNlciA9IHR5cGVvZiByZXBsYWNlciAhPT0gJ3VuZGVmaW5lZCcgPyByZXBsYWNlciA6IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgcmV0dXJuIHY7XG4gIH07XG4gIHJldHVybiBmdW5jdGlvbiAoa2V5LCB2YWwpIHtcbiAgICBpZiAocmVwbGFjZXJTdGFjay5sZW5ndGggPiAwKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlcGxhY2VyU3RhY2subGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHBhcnQgPSByZXBsYWNlclN0YWNrW2ldO1xuICAgICAgICBpZiAocGFydFsxXSA9PT0ga2V5ICYmIHBhcnRbMF0gPT09IHZhbCkge1xuICAgICAgICAgIHZhbCA9IHBhcnRbMl07XG4gICAgICAgICAgcmVwbGFjZXJTdGFjay5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlcGxhY2VyLmNhbGwodGhpcywga2V5LCB2YWwpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTsgfTsgfVxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoY2xhc3NlcywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuY2xhc3Nlcy5FdGhlcmV1bVByb3ZpZGVyRXJyb3IgPSBjbGFzc2VzLkV0aGVyZXVtUnBjRXJyb3IgPSB2b2lkIDA7XG52YXIgZmFzdF9zYWZlX3N0cmluZ2lmeV8xID0gZmFzdFNhZmVTdHJpbmdpZnk7XG4vKipcbiAqIEVycm9yIHN1YmNsYXNzIGltcGxlbWVudGluZyBKU09OIFJQQyAyLjAgZXJyb3JzIGFuZCBFdGhlcmV1bSBSUEMgZXJyb3JzXG4gKiBwZXIgRUlQLTE0NzQuXG4gKiBQZXJtaXRzIGFueSBpbnRlZ2VyIGVycm9yIGNvZGUuXG4gKi9cbnZhciBFdGhlcmV1bVJwY0Vycm9yID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfRXJyb3IpIHtcbiAgX2luaGVyaXRzKEV0aGVyZXVtUnBjRXJyb3IsIF9FcnJvcik7XG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoRXRoZXJldW1ScGNFcnJvcik7XG4gIGZ1bmN0aW9uIEV0aGVyZXVtUnBjRXJyb3IoY29kZSwgbWVzc2FnZSwgZGF0YSkge1xuICAgIHZhciBfdGhpcztcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRXRoZXJldW1ScGNFcnJvcik7XG4gICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKGNvZGUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiY29kZVwiIG11c3QgYmUgYW4gaW50ZWdlci4nKTtcbiAgICB9XG4gICAgaWYgKCFtZXNzYWdlIHx8IHR5cGVvZiBtZXNzYWdlICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdcIm1lc3NhZ2VcIiBtdXN0IGJlIGEgbm9uZW1wdHkgc3RyaW5nLicpO1xuICAgIH1cbiAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG1lc3NhZ2UpO1xuICAgIF90aGlzLmNvZGUgPSBjb2RlO1xuICAgIGlmIChkYXRhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIF90aGlzLmRhdGEgPSBkYXRhO1xuICAgIH1cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYSBwbGFpbiBvYmplY3Qgd2l0aCBhbGwgcHVibGljIGNsYXNzIHByb3BlcnRpZXMuXG4gICAqL1xuICBfY3JlYXRlQ2xhc3MoRXRoZXJldW1ScGNFcnJvciwgW3tcbiAgICBrZXk6IFwic2VyaWFsaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNlcmlhbGl6ZSgpIHtcbiAgICAgIHZhciBzZXJpYWxpemVkID0ge1xuICAgICAgICBjb2RlOiB0aGlzLmNvZGUsXG4gICAgICAgIG1lc3NhZ2U6IHRoaXMubWVzc2FnZVxuICAgICAgfTtcbiAgICAgIGlmICh0aGlzLmRhdGEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBzZXJpYWxpemVkLmRhdGEgPSB0aGlzLmRhdGE7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5zdGFjaykge1xuICAgICAgICBzZXJpYWxpemVkLnN0YWNrID0gdGhpcy5zdGFjaztcbiAgICAgIH1cbiAgICAgIHJldHVybiBzZXJpYWxpemVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHNlcmlhbGl6ZWQgZXJyb3IsIG9taXR0aW5nXG4gICAgICogYW55IGNpcmN1bGFyIHJlZmVyZW5jZXMuXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwidG9TdHJpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICByZXR1cm4gZmFzdF9zYWZlX3N0cmluZ2lmeV8xW1wiZGVmYXVsdFwiXSh0aGlzLnNlcmlhbGl6ZSgpLCBzdHJpbmdpZnlSZXBsYWNlciwgMik7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBFdGhlcmV1bVJwY0Vycm9yO1xufSggLyojX19QVVJFX18qL193cmFwTmF0aXZlU3VwZXIoRXJyb3IpKTtcbmNsYXNzZXMuRXRoZXJldW1ScGNFcnJvciA9IEV0aGVyZXVtUnBjRXJyb3I7XG4vKipcbiAqIEVycm9yIHN1YmNsYXNzIGltcGxlbWVudGluZyBFdGhlcmV1bSBQcm92aWRlciBlcnJvcnMgcGVyIEVJUC0xMTkzLlxuICogUGVybWl0cyBpbnRlZ2VyIGVycm9yIGNvZGVzIGluIHRoZSBbIDEwMDAgPD0gNDk5OSBdIHJhbmdlLlxuICovXG52YXIgRXRoZXJldW1Qcm92aWRlckVycm9yID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfRXRoZXJldW1ScGNFcnJvcikge1xuICBfaW5oZXJpdHMoRXRoZXJldW1Qcm92aWRlckVycm9yLCBfRXRoZXJldW1ScGNFcnJvcik7XG4gIHZhciBfc3VwZXIyID0gX2NyZWF0ZVN1cGVyKEV0aGVyZXVtUHJvdmlkZXJFcnJvcik7XG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gRXRoZXJldW0gUHJvdmlkZXIgSlNPTi1SUEMgZXJyb3IuXG4gICAqIGBjb2RlYCBtdXN0IGJlIGFuIGludGVnZXIgaW4gdGhlIDEwMDAgPD0gNDk5OSByYW5nZS5cbiAgICovXG4gIGZ1bmN0aW9uIEV0aGVyZXVtUHJvdmlkZXJFcnJvcihjb2RlLCBtZXNzYWdlLCBkYXRhKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEV0aGVyZXVtUHJvdmlkZXJFcnJvcik7XG4gICAgaWYgKCFpc1ZhbGlkRXRoUHJvdmlkZXJDb2RlKGNvZGUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiY29kZVwiIG11c3QgYmUgYW4gaW50ZWdlciBzdWNoIHRoYXQ6IDEwMDAgPD0gY29kZSA8PSA0OTk5Jyk7XG4gICAgfVxuICAgIHJldHVybiBfc3VwZXIyLmNhbGwodGhpcywgY29kZSwgbWVzc2FnZSwgZGF0YSk7XG4gIH1cbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhFdGhlcmV1bVByb3ZpZGVyRXJyb3IpO1xufShFdGhlcmV1bVJwY0Vycm9yKTtcbmNsYXNzZXMuRXRoZXJldW1Qcm92aWRlckVycm9yID0gRXRoZXJldW1Qcm92aWRlckVycm9yO1xuLy8gSW50ZXJuYWxcbmZ1bmN0aW9uIGlzVmFsaWRFdGhQcm92aWRlckNvZGUoY29kZSkge1xuICByZXR1cm4gTnVtYmVyLmlzSW50ZWdlcihjb2RlKSAmJiBjb2RlID49IDEwMDAgJiYgY29kZSA8PSA0OTk5O1xufVxuZnVuY3Rpb24gc3RyaW5naWZ5UmVwbGFjZXIoXywgdmFsdWUpIHtcbiAgaWYgKHZhbHVlID09PSAnW0NpcmN1bGFyXScpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cblxudmFyIHV0aWxzID0ge307XG5cbnZhciBlcnJvckNvbnN0YW50cyA9IHt9O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXJyb3JDb25zdGFudHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmVycm9yQ29uc3RhbnRzLmVycm9yVmFsdWVzID0gZXJyb3JDb25zdGFudHMuZXJyb3JDb2RlcyA9IHZvaWQgMDtcbmVycm9yQ29uc3RhbnRzLmVycm9yQ29kZXMgPSB7XG4gIHJwYzoge1xuICAgIGludmFsaWRJbnB1dDogLTMyMDAwLFxuICAgIHJlc291cmNlTm90Rm91bmQ6IC0zMjAwMSxcbiAgICByZXNvdXJjZVVuYXZhaWxhYmxlOiAtMzIwMDIsXG4gICAgdHJhbnNhY3Rpb25SZWplY3RlZDogLTMyMDAzLFxuICAgIG1ldGhvZE5vdFN1cHBvcnRlZDogLTMyMDA0LFxuICAgIGxpbWl0RXhjZWVkZWQ6IC0zMjAwNSxcbiAgICBwYXJzZTogLTMyNzAwLFxuICAgIGludmFsaWRSZXF1ZXN0OiAtMzI2MDAsXG4gICAgbWV0aG9kTm90Rm91bmQ6IC0zMjYwMSxcbiAgICBpbnZhbGlkUGFyYW1zOiAtMzI2MDIsXG4gICAgaW50ZXJuYWw6IC0zMjYwM1xuICB9LFxuICBwcm92aWRlcjoge1xuICAgIHVzZXJSZWplY3RlZFJlcXVlc3Q6IDQwMDEsXG4gICAgdW5hdXRob3JpemVkOiA0MTAwLFxuICAgIHVuc3VwcG9ydGVkTWV0aG9kOiA0MjAwLFxuICAgIGRpc2Nvbm5lY3RlZDogNDkwMCxcbiAgICBjaGFpbkRpc2Nvbm5lY3RlZDogNDkwMVxuICB9XG59O1xuZXJyb3JDb25zdGFudHMuZXJyb3JWYWx1ZXMgPSB7XG4gICctMzI3MDAnOiB7XG4gICAgc3RhbmRhcmQ6ICdKU09OIFJQQyAyLjAnLFxuICAgIG1lc3NhZ2U6ICdJbnZhbGlkIEpTT04gd2FzIHJlY2VpdmVkIGJ5IHRoZSBzZXJ2ZXIuIEFuIGVycm9yIG9jY3VycmVkIG9uIHRoZSBzZXJ2ZXIgd2hpbGUgcGFyc2luZyB0aGUgSlNPTiB0ZXh0LidcbiAgfSxcbiAgJy0zMjYwMCc6IHtcbiAgICBzdGFuZGFyZDogJ0pTT04gUlBDIDIuMCcsXG4gICAgbWVzc2FnZTogJ1RoZSBKU09OIHNlbnQgaXMgbm90IGEgdmFsaWQgUmVxdWVzdCBvYmplY3QuJ1xuICB9LFxuICAnLTMyNjAxJzoge1xuICAgIHN0YW5kYXJkOiAnSlNPTiBSUEMgMi4wJyxcbiAgICBtZXNzYWdlOiAnVGhlIG1ldGhvZCBkb2VzIG5vdCBleGlzdCAvIGlzIG5vdCBhdmFpbGFibGUuJ1xuICB9LFxuICAnLTMyNjAyJzoge1xuICAgIHN0YW5kYXJkOiAnSlNPTiBSUEMgMi4wJyxcbiAgICBtZXNzYWdlOiAnSW52YWxpZCBtZXRob2QgcGFyYW1ldGVyKHMpLidcbiAgfSxcbiAgJy0zMjYwMyc6IHtcbiAgICBzdGFuZGFyZDogJ0pTT04gUlBDIDIuMCcsXG4gICAgbWVzc2FnZTogJ0ludGVybmFsIEpTT04tUlBDIGVycm9yLidcbiAgfSxcbiAgJy0zMjAwMCc6IHtcbiAgICBzdGFuZGFyZDogJ0VJUC0xNDc0JyxcbiAgICBtZXNzYWdlOiAnSW52YWxpZCBpbnB1dC4nXG4gIH0sXG4gICctMzIwMDEnOiB7XG4gICAgc3RhbmRhcmQ6ICdFSVAtMTQ3NCcsXG4gICAgbWVzc2FnZTogJ1Jlc291cmNlIG5vdCBmb3VuZC4nXG4gIH0sXG4gICctMzIwMDInOiB7XG4gICAgc3RhbmRhcmQ6ICdFSVAtMTQ3NCcsXG4gICAgbWVzc2FnZTogJ1Jlc291cmNlIHVuYXZhaWxhYmxlLidcbiAgfSxcbiAgJy0zMjAwMyc6IHtcbiAgICBzdGFuZGFyZDogJ0VJUC0xNDc0JyxcbiAgICBtZXNzYWdlOiAnVHJhbnNhY3Rpb24gcmVqZWN0ZWQuJ1xuICB9LFxuICAnLTMyMDA0Jzoge1xuICAgIHN0YW5kYXJkOiAnRUlQLTE0NzQnLFxuICAgIG1lc3NhZ2U6ICdNZXRob2Qgbm90IHN1cHBvcnRlZC4nXG4gIH0sXG4gICctMzIwMDUnOiB7XG4gICAgc3RhbmRhcmQ6ICdFSVAtMTQ3NCcsXG4gICAgbWVzc2FnZTogJ1JlcXVlc3QgbGltaXQgZXhjZWVkZWQuJ1xuICB9LFxuICAnNDAwMSc6IHtcbiAgICBzdGFuZGFyZDogJ0VJUC0xMTkzJyxcbiAgICBtZXNzYWdlOiAnVXNlciByZWplY3RlZCB0aGUgcmVxdWVzdC4nXG4gIH0sXG4gICc0MTAwJzoge1xuICAgIHN0YW5kYXJkOiAnRUlQLTExOTMnLFxuICAgIG1lc3NhZ2U6ICdUaGUgcmVxdWVzdGVkIGFjY291bnQgYW5kL29yIG1ldGhvZCBoYXMgbm90IGJlZW4gYXV0aG9yaXplZCBieSB0aGUgdXNlci4nXG4gIH0sXG4gICc0MjAwJzoge1xuICAgIHN0YW5kYXJkOiAnRUlQLTExOTMnLFxuICAgIG1lc3NhZ2U6ICdUaGUgcmVxdWVzdGVkIG1ldGhvZCBpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoaXMgRXRoZXJldW0gcHJvdmlkZXIuJ1xuICB9LFxuICAnNDkwMCc6IHtcbiAgICBzdGFuZGFyZDogJ0VJUC0xMTkzJyxcbiAgICBtZXNzYWdlOiAnVGhlIHByb3ZpZGVyIGlzIGRpc2Nvbm5lY3RlZCBmcm9tIGFsbCBjaGFpbnMuJ1xuICB9LFxuICAnNDkwMSc6IHtcbiAgICBzdGFuZGFyZDogJ0VJUC0xMTkzJyxcbiAgICBtZXNzYWdlOiAnVGhlIHByb3ZpZGVyIGlzIGRpc2Nvbm5lY3RlZCBmcm9tIHRoZSBzcGVjaWZpZWQgY2hhaW4uJ1xuICB9XG59O1xuXG4oZnVuY3Rpb24gKGV4cG9ydHMpIHtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxuICB9KTtcbiAgZXhwb3J0cy5zZXJpYWxpemVFcnJvciA9IGV4cG9ydHMuaXNWYWxpZENvZGUgPSBleHBvcnRzLmdldE1lc3NhZ2VGcm9tQ29kZSA9IGV4cG9ydHMuSlNPTl9SUENfU0VSVkVSX0VSUk9SX01FU1NBR0UgPSB2b2lkIDA7XG4gIHZhciBlcnJvcl9jb25zdGFudHNfMSA9IGVycm9yQ29uc3RhbnRzO1xuICB2YXIgY2xhc3Nlc18xID0gY2xhc3NlcztcbiAgdmFyIEZBTExCQUNLX0VSUk9SX0NPREUgPSBlcnJvcl9jb25zdGFudHNfMS5lcnJvckNvZGVzLnJwYy5pbnRlcm5hbDtcbiAgdmFyIEZBTExCQUNLX01FU1NBR0UgPSAnVW5zcGVjaWZpZWQgZXJyb3IgbWVzc2FnZS4gVGhpcyBpcyBhIGJ1ZywgcGxlYXNlIHJlcG9ydCBpdC4nO1xuICB2YXIgRkFMTEJBQ0tfRVJST1IgPSB7XG4gICAgY29kZTogRkFMTEJBQ0tfRVJST1JfQ09ERSxcbiAgICBtZXNzYWdlOiBnZXRNZXNzYWdlRnJvbUNvZGUoRkFMTEJBQ0tfRVJST1JfQ09ERSlcbiAgfTtcbiAgZXhwb3J0cy5KU09OX1JQQ19TRVJWRVJfRVJST1JfTUVTU0FHRSA9ICdVbnNwZWNpZmllZCBzZXJ2ZXIgZXJyb3IuJztcbiAgLyoqXG4gICAqIEdldHMgdGhlIG1lc3NhZ2UgZm9yIGEgZ2l2ZW4gY29kZSwgb3IgYSBmYWxsYmFjayBtZXNzYWdlIGlmIHRoZSBjb2RlIGhhc1xuICAgKiBubyBjb3JyZXNwb25kaW5nIG1lc3NhZ2UuXG4gICAqL1xuICBmdW5jdGlvbiBnZXRNZXNzYWdlRnJvbUNvZGUoY29kZSkge1xuICAgIHZhciBmYWxsYmFja01lc3NhZ2UgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IEZBTExCQUNLX01FU1NBR0U7XG4gICAgaWYgKE51bWJlci5pc0ludGVnZXIoY29kZSkpIHtcbiAgICAgIHZhciBjb2RlU3RyaW5nID0gY29kZS50b1N0cmluZygpO1xuICAgICAgaWYgKGhhc0tleShlcnJvcl9jb25zdGFudHNfMS5lcnJvclZhbHVlcywgY29kZVN0cmluZykpIHtcbiAgICAgICAgcmV0dXJuIGVycm9yX2NvbnN0YW50c18xLmVycm9yVmFsdWVzW2NvZGVTdHJpbmddLm1lc3NhZ2U7XG4gICAgICB9XG4gICAgICBpZiAoaXNKc29uUnBjU2VydmVyRXJyb3IoY29kZSkpIHtcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMuSlNPTl9SUENfU0VSVkVSX0VSUk9SX01FU1NBR0U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxsYmFja01lc3NhZ2U7XG4gIH1cbiAgZXhwb3J0cy5nZXRNZXNzYWdlRnJvbUNvZGUgPSBnZXRNZXNzYWdlRnJvbUNvZGU7XG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIGdpdmVuIGNvZGUgaXMgdmFsaWQuXG4gICAqIEEgY29kZSBpcyBvbmx5IHZhbGlkIGlmIGl0IGhhcyBhIG1lc3NhZ2UuXG4gICAqL1xuICBmdW5jdGlvbiBpc1ZhbGlkQ29kZShjb2RlKSB7XG4gICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKGNvZGUpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHZhciBjb2RlU3RyaW5nID0gY29kZS50b1N0cmluZygpO1xuICAgIGlmIChlcnJvcl9jb25zdGFudHNfMS5lcnJvclZhbHVlc1tjb2RlU3RyaW5nXSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChpc0pzb25ScGNTZXJ2ZXJFcnJvcihjb2RlKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBleHBvcnRzLmlzVmFsaWRDb2RlID0gaXNWYWxpZENvZGU7XG4gIC8qKlxuICAgKiBTZXJpYWxpemVzIHRoZSBnaXZlbiBlcnJvciB0byBhbiBFdGhlcmV1bSBKU09OIFJQQy1jb21wYXRpYmxlIGVycm9yIG9iamVjdC5cbiAgICogTWVyZWx5IGNvcGllcyB0aGUgZ2l2ZW4gZXJyb3IncyB2YWx1ZXMgaWYgaXQgaXMgYWxyZWFkeSBjb21wYXRpYmxlLlxuICAgKiBJZiB0aGUgZ2l2ZW4gZXJyb3IgaXMgbm90IGZ1bGx5IGNvbXBhdGlibGUsIGl0IHdpbGwgYmUgcHJlc2VydmVkIG9uIHRoZVxuICAgKiByZXR1cm5lZCBvYmplY3QncyBkYXRhLm9yaWdpbmFsRXJyb3IgcHJvcGVydHkuXG4gICAqL1xuICBmdW5jdGlvbiBzZXJpYWxpemVFcnJvcihlcnJvcikge1xuICAgIHZhciBfcmVmID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fSxcbiAgICAgIF9yZWYkZmFsbGJhY2tFcnJvciA9IF9yZWYuZmFsbGJhY2tFcnJvcixcbiAgICAgIGZhbGxiYWNrRXJyb3IgPSBfcmVmJGZhbGxiYWNrRXJyb3IgPT09IHZvaWQgMCA/IEZBTExCQUNLX0VSUk9SIDogX3JlZiRmYWxsYmFja0Vycm9yLFxuICAgICAgX3JlZiRzaG91bGRJbmNsdWRlU3RhID0gX3JlZi5zaG91bGRJbmNsdWRlU3RhY2ssXG4gICAgICBzaG91bGRJbmNsdWRlU3RhY2sgPSBfcmVmJHNob3VsZEluY2x1ZGVTdGEgPT09IHZvaWQgMCA/IGZhbHNlIDogX3JlZiRzaG91bGRJbmNsdWRlU3RhO1xuICAgIHZhciBfYSwgX2I7XG4gICAgaWYgKCFmYWxsYmFja0Vycm9yIHx8ICFOdW1iZXIuaXNJbnRlZ2VyKGZhbGxiYWNrRXJyb3IuY29kZSkgfHwgdHlwZW9mIGZhbGxiYWNrRXJyb3IubWVzc2FnZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTXVzdCBwcm92aWRlIGZhbGxiYWNrIGVycm9yIHdpdGggaW50ZWdlciBudW1iZXIgY29kZSBhbmQgc3RyaW5nIG1lc3NhZ2UuJyk7XG4gICAgfVxuICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIGNsYXNzZXNfMS5FdGhlcmV1bVJwY0Vycm9yKSB7XG4gICAgICByZXR1cm4gZXJyb3Iuc2VyaWFsaXplKCk7XG4gICAgfVxuICAgIHZhciBzZXJpYWxpemVkID0ge307XG4gICAgaWYgKGVycm9yICYmIF90eXBlb2YoZXJyb3IpID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShlcnJvcikgJiYgaGFzS2V5KGVycm9yLCAnY29kZScpICYmIGlzVmFsaWRDb2RlKGVycm9yLmNvZGUpKSB7XG4gICAgICB2YXIgX2Vycm9yID0gZXJyb3I7XG4gICAgICBzZXJpYWxpemVkLmNvZGUgPSBfZXJyb3IuY29kZTtcbiAgICAgIGlmIChfZXJyb3IubWVzc2FnZSAmJiB0eXBlb2YgX2Vycm9yLm1lc3NhZ2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHNlcmlhbGl6ZWQubWVzc2FnZSA9IF9lcnJvci5tZXNzYWdlO1xuICAgICAgICBpZiAoaGFzS2V5KF9lcnJvciwgJ2RhdGEnKSkge1xuICAgICAgICAgIHNlcmlhbGl6ZWQuZGF0YSA9IF9lcnJvci5kYXRhO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZXJpYWxpemVkLm1lc3NhZ2UgPSBnZXRNZXNzYWdlRnJvbUNvZGUoc2VyaWFsaXplZC5jb2RlKTtcbiAgICAgICAgc2VyaWFsaXplZC5kYXRhID0ge1xuICAgICAgICAgIG9yaWdpbmFsRXJyb3I6IGFzc2lnbk9yaWdpbmFsRXJyb3IoZXJyb3IpXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHNlcmlhbGl6ZWQuY29kZSA9IGZhbGxiYWNrRXJyb3IuY29kZTtcbiAgICAgIHZhciBtZXNzYWdlID0gKF9hID0gZXJyb3IpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tZXNzYWdlO1xuICAgICAgc2VyaWFsaXplZC5tZXNzYWdlID0gbWVzc2FnZSAmJiB0eXBlb2YgbWVzc2FnZSA9PT0gJ3N0cmluZycgPyBtZXNzYWdlIDogZmFsbGJhY2tFcnJvci5tZXNzYWdlO1xuICAgICAgc2VyaWFsaXplZC5kYXRhID0ge1xuICAgICAgICBvcmlnaW5hbEVycm9yOiBhc3NpZ25PcmlnaW5hbEVycm9yKGVycm9yKVxuICAgICAgfTtcbiAgICB9XG4gICAgdmFyIHN0YWNrID0gKF9iID0gZXJyb3IpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5zdGFjaztcbiAgICBpZiAoc2hvdWxkSW5jbHVkZVN0YWNrICYmIGVycm9yICYmIHN0YWNrICYmIHR5cGVvZiBzdGFjayA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHNlcmlhbGl6ZWQuc3RhY2sgPSBzdGFjaztcbiAgICB9XG4gICAgcmV0dXJuIHNlcmlhbGl6ZWQ7XG4gIH1cbiAgZXhwb3J0cy5zZXJpYWxpemVFcnJvciA9IHNlcmlhbGl6ZUVycm9yO1xuICAvLyBJbnRlcm5hbFxuICBmdW5jdGlvbiBpc0pzb25ScGNTZXJ2ZXJFcnJvcihjb2RlKSB7XG4gICAgcmV0dXJuIGNvZGUgPj0gLTMyMDk5ICYmIGNvZGUgPD0gLTMyMDAwO1xuICB9XG4gIGZ1bmN0aW9uIGFzc2lnbk9yaWdpbmFsRXJyb3IoZXJyb3IpIHtcbiAgICBpZiAoZXJyb3IgJiYgX3R5cGVvZihlcnJvcikgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KGVycm9yKSkge1xuICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIGVycm9yKTtcbiAgICB9XG4gICAgcmV0dXJuIGVycm9yO1xuICB9XG4gIGZ1bmN0aW9uIGhhc0tleShvYmosIGtleSkge1xuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpO1xuICB9XG59KSh1dGlscyk7XG5cbmZ1bmN0aW9uIF9hcnJheVdpdGhIb2xlcyhhcnIpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIGFycjtcbn1cblxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheUxpbWl0KHIsIGwpIHtcbiAgdmFyIHQgPSBudWxsID09IHIgPyBudWxsIDogXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgU3ltYm9sICYmIHJbU3ltYm9sLml0ZXJhdG9yXSB8fCByW1wiQEBpdGVyYXRvclwiXTtcbiAgaWYgKG51bGwgIT0gdCkge1xuICAgIHZhciBlLFxuICAgICAgbixcbiAgICAgIGksXG4gICAgICB1LFxuICAgICAgYSA9IFtdLFxuICAgICAgZiA9ICEwLFxuICAgICAgbyA9ICExO1xuICAgIHRyeSB7XG4gICAgICBpZiAoaSA9ICh0ID0gdC5jYWxsKHIpKS5uZXh0LCAwID09PSBsKSB7XG4gICAgICAgIGlmIChPYmplY3QodCkgIT09IHQpIHJldHVybjtcbiAgICAgICAgZiA9ICExO1xuICAgICAgfSBlbHNlIGZvciAoOyAhKGYgPSAoZSA9IGkuY2FsbCh0KSkuZG9uZSkgJiYgKGEucHVzaChlLnZhbHVlKSwgYS5sZW5ndGggIT09IGwpOyBmID0gITApO1xuICAgIH0gY2F0Y2ggKHIpIHtcbiAgICAgIG8gPSAhMCwgbiA9IHI7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICghZiAmJiBudWxsICE9IHRbXCJyZXR1cm5cIl0gJiYgKHUgPSB0W1wicmV0dXJuXCJdKCksIE9iamVjdCh1KSAhPT0gdSkpIHJldHVybjtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmIChvKSB0aHJvdyBuO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikge1xuICBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDtcbiAgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSBhcnIyW2ldID0gYXJyW2ldO1xuICByZXR1cm4gYXJyMjtcbn1cblxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikge1xuICBpZiAoIW8pIHJldHVybjtcbiAgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbiAgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpO1xuICBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lO1xuICBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTtcbiAgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xufVxuXG5mdW5jdGlvbiBfbm9uSXRlcmFibGVSZXN0KCkge1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpO1xufVxuXG5mdW5jdGlvbiBfc2xpY2VkVG9BcnJheShhcnIsIGkpIHtcbiAgcmV0dXJuIF9hcnJheVdpdGhIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIsIGkpIHx8IF9ub25JdGVyYWJsZVJlc3QoKTtcbn1cblxudmFyIGVycm9ycyA9IHt9O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXJyb3JzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5lcnJvcnMuZXRoRXJyb3JzID0gdm9pZCAwO1xudmFyIGNsYXNzZXNfMSA9IGNsYXNzZXM7XG52YXIgdXRpbHNfMSA9IHV0aWxzO1xudmFyIGVycm9yX2NvbnN0YW50c18xID0gZXJyb3JDb25zdGFudHM7XG5lcnJvcnMuZXRoRXJyb3JzID0ge1xuICBycGM6IHtcbiAgICAvKipcbiAgICAgKiBHZXQgYSBKU09OIFJQQyAyLjAgUGFyc2UgKC0zMjcwMCkgZXJyb3IuXG4gICAgICovXG4gICAgcGFyc2U6IGZ1bmN0aW9uIHBhcnNlKGFyZykge1xuICAgICAgcmV0dXJuIGdldEV0aEpzb25ScGNFcnJvcihlcnJvcl9jb25zdGFudHNfMS5lcnJvckNvZGVzLnJwYy5wYXJzZSwgYXJnKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEdldCBhIEpTT04gUlBDIDIuMCBJbnZhbGlkIFJlcXVlc3QgKC0zMjYwMCkgZXJyb3IuXG4gICAgICovXG4gICAgaW52YWxpZFJlcXVlc3Q6IGZ1bmN0aW9uIGludmFsaWRSZXF1ZXN0KGFyZykge1xuICAgICAgcmV0dXJuIGdldEV0aEpzb25ScGNFcnJvcihlcnJvcl9jb25zdGFudHNfMS5lcnJvckNvZGVzLnJwYy5pbnZhbGlkUmVxdWVzdCwgYXJnKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEdldCBhIEpTT04gUlBDIDIuMCBJbnZhbGlkIFBhcmFtcyAoLTMyNjAyKSBlcnJvci5cbiAgICAgKi9cbiAgICBpbnZhbGlkUGFyYW1zOiBmdW5jdGlvbiBpbnZhbGlkUGFyYW1zKGFyZykge1xuICAgICAgcmV0dXJuIGdldEV0aEpzb25ScGNFcnJvcihlcnJvcl9jb25zdGFudHNfMS5lcnJvckNvZGVzLnJwYy5pbnZhbGlkUGFyYW1zLCBhcmcpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogR2V0IGEgSlNPTiBSUEMgMi4wIE1ldGhvZCBOb3QgRm91bmQgKC0zMjYwMSkgZXJyb3IuXG4gICAgICovXG4gICAgbWV0aG9kTm90Rm91bmQ6IGZ1bmN0aW9uIG1ldGhvZE5vdEZvdW5kKGFyZykge1xuICAgICAgcmV0dXJuIGdldEV0aEpzb25ScGNFcnJvcihlcnJvcl9jb25zdGFudHNfMS5lcnJvckNvZGVzLnJwYy5tZXRob2ROb3RGb3VuZCwgYXJnKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEdldCBhIEpTT04gUlBDIDIuMCBJbnRlcm5hbCAoLTMyNjAzKSBlcnJvci5cbiAgICAgKi9cbiAgICBpbnRlcm5hbDogZnVuY3Rpb24gaW50ZXJuYWwoYXJnKSB7XG4gICAgICByZXR1cm4gZ2V0RXRoSnNvblJwY0Vycm9yKGVycm9yX2NvbnN0YW50c18xLmVycm9yQ29kZXMucnBjLmludGVybmFsLCBhcmcpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogR2V0IGEgSlNPTiBSUEMgMi4wIFNlcnZlciBlcnJvci5cbiAgICAgKiBQZXJtaXRzIGludGVnZXIgZXJyb3IgY29kZXMgaW4gdGhlIFsgLTMyMDk5IDw9IC0zMjAwNSBdIHJhbmdlLlxuICAgICAqIENvZGVzIC0zMjAwMCB0aHJvdWdoIC0zMjAwNCBhcmUgcmVzZXJ2ZWQgYnkgRUlQLTE0NzQuXG4gICAgICovXG4gICAgc2VydmVyOiBmdW5jdGlvbiBzZXJ2ZXIob3B0cykge1xuICAgICAgaWYgKCFvcHRzIHx8IF90eXBlb2Yob3B0cykgIT09ICdvYmplY3QnIHx8IEFycmF5LmlzQXJyYXkob3B0cykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFdGhlcmV1bSBSUEMgU2VydmVyIGVycm9ycyBtdXN0IHByb3ZpZGUgc2luZ2xlIG9iamVjdCBhcmd1bWVudC4nKTtcbiAgICAgIH1cbiAgICAgIHZhciBjb2RlID0gb3B0cy5jb2RlO1xuICAgICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKGNvZGUpIHx8IGNvZGUgPiAtMzIwMDUgfHwgY29kZSA8IC0zMjA5OSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiY29kZVwiIG11c3QgYmUgYW4gaW50ZWdlciBzdWNoIHRoYXQ6IC0zMjA5OSA8PSBjb2RlIDw9IC0zMjAwNScpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGdldEV0aEpzb25ScGNFcnJvcihjb2RlLCBvcHRzKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEdldCBhbiBFdGhlcmV1bSBKU09OIFJQQyBJbnZhbGlkIElucHV0ICgtMzIwMDApIGVycm9yLlxuICAgICAqL1xuICAgIGludmFsaWRJbnB1dDogZnVuY3Rpb24gaW52YWxpZElucHV0KGFyZykge1xuICAgICAgcmV0dXJuIGdldEV0aEpzb25ScGNFcnJvcihlcnJvcl9jb25zdGFudHNfMS5lcnJvckNvZGVzLnJwYy5pbnZhbGlkSW5wdXQsIGFyZyk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBHZXQgYW4gRXRoZXJldW0gSlNPTiBSUEMgUmVzb3VyY2UgTm90IEZvdW5kICgtMzIwMDEpIGVycm9yLlxuICAgICAqL1xuICAgIHJlc291cmNlTm90Rm91bmQ6IGZ1bmN0aW9uIHJlc291cmNlTm90Rm91bmQoYXJnKSB7XG4gICAgICByZXR1cm4gZ2V0RXRoSnNvblJwY0Vycm9yKGVycm9yX2NvbnN0YW50c18xLmVycm9yQ29kZXMucnBjLnJlc291cmNlTm90Rm91bmQsIGFyZyk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBHZXQgYW4gRXRoZXJldW0gSlNPTiBSUEMgUmVzb3VyY2UgVW5hdmFpbGFibGUgKC0zMjAwMikgZXJyb3IuXG4gICAgICovXG4gICAgcmVzb3VyY2VVbmF2YWlsYWJsZTogZnVuY3Rpb24gcmVzb3VyY2VVbmF2YWlsYWJsZShhcmcpIHtcbiAgICAgIHJldHVybiBnZXRFdGhKc29uUnBjRXJyb3IoZXJyb3JfY29uc3RhbnRzXzEuZXJyb3JDb2Rlcy5ycGMucmVzb3VyY2VVbmF2YWlsYWJsZSwgYXJnKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEdldCBhbiBFdGhlcmV1bSBKU09OIFJQQyBUcmFuc2FjdGlvbiBSZWplY3RlZCAoLTMyMDAzKSBlcnJvci5cbiAgICAgKi9cbiAgICB0cmFuc2FjdGlvblJlamVjdGVkOiBmdW5jdGlvbiB0cmFuc2FjdGlvblJlamVjdGVkKGFyZykge1xuICAgICAgcmV0dXJuIGdldEV0aEpzb25ScGNFcnJvcihlcnJvcl9jb25zdGFudHNfMS5lcnJvckNvZGVzLnJwYy50cmFuc2FjdGlvblJlamVjdGVkLCBhcmcpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogR2V0IGFuIEV0aGVyZXVtIEpTT04gUlBDIE1ldGhvZCBOb3QgU3VwcG9ydGVkICgtMzIwMDQpIGVycm9yLlxuICAgICAqL1xuICAgIG1ldGhvZE5vdFN1cHBvcnRlZDogZnVuY3Rpb24gbWV0aG9kTm90U3VwcG9ydGVkKGFyZykge1xuICAgICAgcmV0dXJuIGdldEV0aEpzb25ScGNFcnJvcihlcnJvcl9jb25zdGFudHNfMS5lcnJvckNvZGVzLnJwYy5tZXRob2ROb3RTdXBwb3J0ZWQsIGFyZyk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBHZXQgYW4gRXRoZXJldW0gSlNPTiBSUEMgTGltaXQgRXhjZWVkZWQgKC0zMjAwNSkgZXJyb3IuXG4gICAgICovXG4gICAgbGltaXRFeGNlZWRlZDogZnVuY3Rpb24gbGltaXRFeGNlZWRlZChhcmcpIHtcbiAgICAgIHJldHVybiBnZXRFdGhKc29uUnBjRXJyb3IoZXJyb3JfY29uc3RhbnRzXzEuZXJyb3JDb2Rlcy5ycGMubGltaXRFeGNlZWRlZCwgYXJnKTtcbiAgICB9XG4gIH0sXG4gIHByb3ZpZGVyOiB7XG4gICAgLyoqXG4gICAgICogR2V0IGFuIEV0aGVyZXVtIFByb3ZpZGVyIFVzZXIgUmVqZWN0ZWQgUmVxdWVzdCAoNDAwMSkgZXJyb3IuXG4gICAgICovXG4gICAgdXNlclJlamVjdGVkUmVxdWVzdDogZnVuY3Rpb24gdXNlclJlamVjdGVkUmVxdWVzdChhcmcpIHtcbiAgICAgIHJldHVybiBnZXRFdGhQcm92aWRlckVycm9yKGVycm9yX2NvbnN0YW50c18xLmVycm9yQ29kZXMucHJvdmlkZXIudXNlclJlamVjdGVkUmVxdWVzdCwgYXJnKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEdldCBhbiBFdGhlcmV1bSBQcm92aWRlciBVbmF1dGhvcml6ZWQgKDQxMDApIGVycm9yLlxuICAgICAqL1xuICAgIHVuYXV0aG9yaXplZDogZnVuY3Rpb24gdW5hdXRob3JpemVkKGFyZykge1xuICAgICAgcmV0dXJuIGdldEV0aFByb3ZpZGVyRXJyb3IoZXJyb3JfY29uc3RhbnRzXzEuZXJyb3JDb2Rlcy5wcm92aWRlci51bmF1dGhvcml6ZWQsIGFyZyk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBHZXQgYW4gRXRoZXJldW0gUHJvdmlkZXIgVW5zdXBwb3J0ZWQgTWV0aG9kICg0MjAwKSBlcnJvci5cbiAgICAgKi9cbiAgICB1bnN1cHBvcnRlZE1ldGhvZDogZnVuY3Rpb24gdW5zdXBwb3J0ZWRNZXRob2QoYXJnKSB7XG4gICAgICByZXR1cm4gZ2V0RXRoUHJvdmlkZXJFcnJvcihlcnJvcl9jb25zdGFudHNfMS5lcnJvckNvZGVzLnByb3ZpZGVyLnVuc3VwcG9ydGVkTWV0aG9kLCBhcmcpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogR2V0IGFuIEV0aGVyZXVtIFByb3ZpZGVyIE5vdCBDb25uZWN0ZWQgKDQ5MDApIGVycm9yLlxuICAgICAqL1xuICAgIGRpc2Nvbm5lY3RlZDogZnVuY3Rpb24gZGlzY29ubmVjdGVkKGFyZykge1xuICAgICAgcmV0dXJuIGdldEV0aFByb3ZpZGVyRXJyb3IoZXJyb3JfY29uc3RhbnRzXzEuZXJyb3JDb2Rlcy5wcm92aWRlci5kaXNjb25uZWN0ZWQsIGFyZyk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBHZXQgYW4gRXRoZXJldW0gUHJvdmlkZXIgQ2hhaW4gTm90IENvbm5lY3RlZCAoNDkwMSkgZXJyb3IuXG4gICAgICovXG4gICAgY2hhaW5EaXNjb25uZWN0ZWQ6IGZ1bmN0aW9uIGNoYWluRGlzY29ubmVjdGVkKGFyZykge1xuICAgICAgcmV0dXJuIGdldEV0aFByb3ZpZGVyRXJyb3IoZXJyb3JfY29uc3RhbnRzXzEuZXJyb3JDb2Rlcy5wcm92aWRlci5jaGFpbkRpc2Nvbm5lY3RlZCwgYXJnKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEdldCBhIGN1c3RvbSBFdGhlcmV1bSBQcm92aWRlciBlcnJvci5cbiAgICAgKi9cbiAgICBjdXN0b206IGZ1bmN0aW9uIGN1c3RvbShvcHRzKSB7XG4gICAgICBpZiAoIW9wdHMgfHwgX3R5cGVvZihvcHRzKSAhPT0gJ29iamVjdCcgfHwgQXJyYXkuaXNBcnJheShvcHRzKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V0aGVyZXVtIFByb3ZpZGVyIGN1c3RvbSBlcnJvcnMgbXVzdCBwcm92aWRlIHNpbmdsZSBvYmplY3QgYXJndW1lbnQuJyk7XG4gICAgICB9XG4gICAgICB2YXIgY29kZSA9IG9wdHMuY29kZSxcbiAgICAgICAgbWVzc2FnZSA9IG9wdHMubWVzc2FnZSxcbiAgICAgICAgZGF0YSA9IG9wdHMuZGF0YTtcbiAgICAgIGlmICghbWVzc2FnZSB8fCB0eXBlb2YgbWVzc2FnZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdcIm1lc3NhZ2VcIiBtdXN0IGJlIGEgbm9uZW1wdHkgc3RyaW5nJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IGNsYXNzZXNfMS5FdGhlcmV1bVByb3ZpZGVyRXJyb3IoY29kZSwgbWVzc2FnZSwgZGF0YSk7XG4gICAgfVxuICB9XG59O1xuLy8gSW50ZXJuYWxcbmZ1bmN0aW9uIGdldEV0aEpzb25ScGNFcnJvcihjb2RlLCBhcmcpIHtcbiAgdmFyIF9wYXJzZU9wdHMgPSBwYXJzZU9wdHMoYXJnKSxcbiAgICBfcGFyc2VPcHRzMiA9IF9zbGljZWRUb0FycmF5KF9wYXJzZU9wdHMsIDIpLFxuICAgIG1lc3NhZ2UgPSBfcGFyc2VPcHRzMlswXSxcbiAgICBkYXRhID0gX3BhcnNlT3B0czJbMV07XG4gIHJldHVybiBuZXcgY2xhc3Nlc18xLkV0aGVyZXVtUnBjRXJyb3IoY29kZSwgbWVzc2FnZSB8fCB1dGlsc18xLmdldE1lc3NhZ2VGcm9tQ29kZShjb2RlKSwgZGF0YSk7XG59XG5mdW5jdGlvbiBnZXRFdGhQcm92aWRlckVycm9yKGNvZGUsIGFyZykge1xuICB2YXIgX3BhcnNlT3B0czMgPSBwYXJzZU9wdHMoYXJnKSxcbiAgICBfcGFyc2VPcHRzNCA9IF9zbGljZWRUb0FycmF5KF9wYXJzZU9wdHMzLCAyKSxcbiAgICBtZXNzYWdlID0gX3BhcnNlT3B0czRbMF0sXG4gICAgZGF0YSA9IF9wYXJzZU9wdHM0WzFdO1xuICByZXR1cm4gbmV3IGNsYXNzZXNfMS5FdGhlcmV1bVByb3ZpZGVyRXJyb3IoY29kZSwgbWVzc2FnZSB8fCB1dGlsc18xLmdldE1lc3NhZ2VGcm9tQ29kZShjb2RlKSwgZGF0YSk7XG59XG5mdW5jdGlvbiBwYXJzZU9wdHMoYXJnKSB7XG4gIGlmIChhcmcpIHtcbiAgICBpZiAodHlwZW9mIGFyZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBbYXJnXTtcbiAgICB9IGVsc2UgaWYgKF90eXBlb2YoYXJnKSA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkoYXJnKSkge1xuICAgICAgdmFyIG1lc3NhZ2UgPSBhcmcubWVzc2FnZSxcbiAgICAgICAgZGF0YSA9IGFyZy5kYXRhO1xuICAgICAgaWYgKG1lc3NhZ2UgJiYgdHlwZW9mIG1lc3NhZ2UgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTXVzdCBzcGVjaWZ5IHN0cmluZyBtZXNzYWdlLicpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFttZXNzYWdlIHx8IHVuZGVmaW5lZCwgZGF0YV07XG4gICAgfVxuICB9XG4gIHJldHVybiBbXTtcbn1cblxuKGZ1bmN0aW9uIChleHBvcnRzKSB7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbiAgfSk7XG4gIGV4cG9ydHMuZ2V0TWVzc2FnZUZyb21Db2RlID0gZXhwb3J0cy5zZXJpYWxpemVFcnJvciA9IGV4cG9ydHMuRXRoZXJldW1Qcm92aWRlckVycm9yID0gZXhwb3J0cy5FdGhlcmV1bVJwY0Vycm9yID0gZXhwb3J0cy5ldGhFcnJvcnMgPSBleHBvcnRzLmVycm9yQ29kZXMgPSB2b2lkIDA7XG4gIHZhciBjbGFzc2VzXzEgPSBjbGFzc2VzO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJFdGhlcmV1bVJwY0Vycm9yXCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIGNsYXNzZXNfMS5FdGhlcmV1bVJwY0Vycm9yO1xuICAgIH1cbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkV0aGVyZXVtUHJvdmlkZXJFcnJvclwiLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBjbGFzc2VzXzEuRXRoZXJldW1Qcm92aWRlckVycm9yO1xuICAgIH1cbiAgfSk7XG4gIHZhciB1dGlsc18xID0gdXRpbHM7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInNlcmlhbGl6ZUVycm9yXCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHV0aWxzXzEuc2VyaWFsaXplRXJyb3I7XG4gICAgfVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZ2V0TWVzc2FnZUZyb21Db2RlXCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHV0aWxzXzEuZ2V0TWVzc2FnZUZyb21Db2RlO1xuICAgIH1cbiAgfSk7XG4gIHZhciBlcnJvcnNfMSA9IGVycm9ycztcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZXRoRXJyb3JzXCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIGVycm9yc18xLmV0aEVycm9ycztcbiAgICB9XG4gIH0pO1xuICB2YXIgZXJyb3JfY29uc3RhbnRzXzEgPSBlcnJvckNvbnN0YW50cztcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZXJyb3JDb2Rlc1wiLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBlcnJvcl9jb25zdGFudHNfMS5lcnJvckNvZGVzO1xuICAgIH1cbiAgfSk7XG59KShkaXN0KTtcblxudmFyIF9FdGhlcmV1bVByb3ZpZGVyX2luc3RhbmNlcywgX0V0aGVyZXVtUHJvdmlkZXJfZ2V0QmxvY3RvUHJvcGVydGllcywgX0V0aGVyZXVtUHJvdmlkZXJfYWRkVG9Td2l0Y2hhYmxlLCBfRXRoZXJldW1Qcm92aWRlcl9jaGVja05ldHdvcmtNYXRjaGVkLCBfRXRoZXJldW1Qcm92aWRlcl9jcmVhdGVBdXRoekZyYW1lO1xuZnVuY3Rpb24gcGFyc2VDaGFpbklkKGNoYWluSWQpIHtcbiAgICBpZiAoIWNoYWluSWQpIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgY2hhaW5JZCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0dXJuIGNoYWluSWQ7XG4gICAgfVxuICAgIGVsc2UgaWYgKGNoYWluSWQuc3RhcnRzV2l0aCgnMHgnKSkge1xuICAgICAgICByZXR1cm4gcGFyc2VJbnQoY2hhaW5JZCwgMTYpO1xuICAgIH1cbiAgICByZXR1cm4gcGFyc2VJbnQoY2hhaW5JZCwgMTApO1xufVxuY2xhc3MgRXRoZXJldW1Qcm92aWRlciBleHRlbmRzIEJsb2N0b1Byb3ZpZGVyIHtcbiAgICBnZXQgZXhpc3RlZFNESygpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKVxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIHdpbmRvdy5ldGhlcmV1bTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgX0V0aGVyZXVtUHJvdmlkZXJfaW5zdGFuY2VzLmFkZCh0aGlzKTtcbiAgICAgICAgdGhpcy5uZXR3b3JrVmVyc2lvbiA9ICcxJzsgLy8gc2FtZSBhcyBjaGFpbklkIGJ1dCBpbiBkZWNpbWFsXG4gICAgICAgIHRoaXMub2ZmID0gdGhpcy5yZW1vdmVMaXN0ZW5lcjtcbiAgICAgICAgdGhpcy5pbmplY3RlZFdhbGxldFNlcnZlciA9IGNvbmZpZy53YWxsZXRTZXJ2ZXI7XG4gICAgICAgIHRoaXMuX2Jsb2N0byA9IHtcbiAgICAgICAgICAgIHNlc3Npb25LZXlFbnY6IEtFWV9TRVNTSU9OLnByb2QsXG4gICAgICAgICAgICB3YWxsZXRTZXJ2ZXI6IHRoaXMuaW5qZWN0ZWRXYWxsZXRTZXJ2ZXIgfHwgJycsXG4gICAgICAgICAgICBibG9ja2NoYWluTmFtZTogJycsXG4gICAgICAgICAgICBuZXR3b3JrVHlwZTogJycsXG4gICAgICAgICAgICBzd2l0Y2hhYmxlTmV0d29yazoge30sXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuYXBwSWQgPSBjb25maWcuYXBwSWQgfHwgREVGQVVMVF9BUFBfSUQ7XG4gICAgICAgIGlmICgnY2hhaW5JZCcgaW4gY29uZmlnKSB7XG4gICAgICAgICAgICBjb25zdCB7IGNoYWluSWQsIHJwYyB9ID0gY29uZmlnO1xuICAgICAgICAgICAgaW52YXJpYW50KGNoYWluSWQsIFwiJ2NoYWluSWQnIGlzIHJlcXVpcmVkXCIpO1xuICAgICAgICAgICAgdGhpcy5uZXR3b3JrVmVyc2lvbiA9IGAke3BhcnNlQ2hhaW5JZChjaGFpbklkKX1gO1xuICAgICAgICAgICAgdGhpcy5jaGFpbklkID0gYDB4JHtwYXJzZUNoYWluSWQoY2hhaW5JZCkudG9TdHJpbmcoMTYpfWA7XG4gICAgICAgICAgICAvLyBzZXR1cCBycGNcbiAgICAgICAgICAgIHRoaXMucnBjID0gcnBjIHx8IEVUSF9SUENfTElTVFt0aGlzLm5ldHdvcmtWZXJzaW9uXTtcbiAgICAgICAgICAgIGludmFyaWFudCh0aGlzLnJwYywgXCIncnBjJyBpcyByZXF1aXJlZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHsgZGVmYXVsdENoYWluSWQsIHN3aXRjaGFibGVDaGFpbnMgfSA9IGNvbmZpZztcbiAgICAgICAgICAgIGludmFyaWFudChkZWZhdWx0Q2hhaW5JZCwgXCInZGVmYXVsdENoYWluSWQnIGlzIHJlcXVpcmVkXCIpO1xuICAgICAgICAgICAgdGhpcy5uZXR3b3JrVmVyc2lvbiA9IGAke3BhcnNlQ2hhaW5JZChkZWZhdWx0Q2hhaW5JZCl9YDtcbiAgICAgICAgICAgIHRoaXMuY2hhaW5JZCA9IGAweCR7cGFyc2VDaGFpbklkKGRlZmF1bHRDaGFpbklkKS50b1N0cmluZygxNil9YDtcbiAgICAgICAgICAgIC8vIGdldCBjb25maWcgZnJvbSBzd2l0Y2hhYmxlQ2hhaW5zIGFycmF5XG4gICAgICAgICAgICBjb25zdCBjaGFpbkNvbmZpZyA9IHN3aXRjaGFibGVDaGFpbnMuZmluZCgoY2hhaW4pID0+IHBhcnNlQ2hhaW5JZChjaGFpbi5jaGFpbklkKSA9PT0gcGFyc2VDaGFpbklkKGRlZmF1bHRDaGFpbklkKSk7XG4gICAgICAgICAgICBpZiAoIWNoYWluQ29uZmlnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZGlzdC5ldGhFcnJvcnMucHJvdmlkZXIuY3VzdG9tKHtcbiAgICAgICAgICAgICAgICAgICAgY29kZTogMTAwMSxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogYENoYWluICR7ZGVmYXVsdENoYWluSWR9IGlzIG5vdCBpbiBzd2l0Y2hhYmxlQ2hhaW5zIGxpc3RgLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5ycGMgPSAoKF9hID0gY2hhaW5Db25maWcucnBjVXJscykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hWzBdKSB8fCBFVEhfUlBDX0xJU1RbdGhpcy5uZXR3b3JrVmVyc2lvbl07XG4gICAgICAgICAgICBpbnZhcmlhbnQodGhpcy5ycGMsIFwiJ3JwYycgaXMgcmVxdWlyZWRcIik7XG4gICAgICAgICAgICB0aGlzLl9ibG9jdG8udW5sb2FkZWROZXR3b3JrID0gc3dpdGNoYWJsZUNoYWlucztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBERVBSRUNBVEVEIEFQSTogc2VlIGh0dHBzOi8vZG9jcy5tZXRhbWFzay5pby9ndWlkZS9ldGhlcmV1bS1wcm92aWRlci5odG1sI2V0aGVyZXVtLXNlbmQtZGVwcmVjYXRlZFxuICAgIHNlbmQobWV0aG9kT3JQYXlsb2FkLCBwYXJhbXNPckNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHRydWUpIHtcbiAgICAgICAgICAgICAgICAvLyBzaWduYXR1cmUgdHlwZSAxOiBhcmcxIC0gSlNPTi1SUEMgcGF5bG9hZCwgYXJnMiAtIGNhbGxiYWNrO1xuICAgICAgICAgICAgICAgIC8vIGV0aGVyZXVtLnNlbmQocGF5bG9hZDogSnNvblJwY1JlcXVlc3QsIGNhbGxiYWNrOiBKc29uUnBjQ2FsbGJhY2spOiB2b2lkO1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgc2lnbmF0dXJlIGlzIGV4YWN0bHkgbGlrZSBldGhlcmV1bS5zZW5kQXN5bmMoKVxuICAgICAgICAgICAgICAgIGNhc2UgcGFyYW1zT3JDYWxsYmFjayBpbnN0YW5jZW9mIEZ1bmN0aW9uOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zZW5kQXN5bmMobWV0aG9kT3JQYXlsb2FkLCBwYXJhbXNPckNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICAvLyBzaWduYXR1cmUgdHlwZSAyOiBhcmcxIC0gSlNPTi1SUEMgbWV0aG9kIG5hbWUsIGFyZzIgLSBwYXJhbXMgYXJyYXk7XG4gICAgICAgICAgICAgICAgLy8gZXRoZXJldW0uc2VuZChtZXRob2Q6IHN0cmluZywgcGFyYW1zPzogQXJyYXk8dW5rbm93bj4pOiBQcm9taXNlPEpzb25ScGNSZXNwb25zZT47XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBzaWduYXR1cmUgaXMgbGlrZSBhbiBhc3luYyBldGhlcmV1bS5zZW5kQXN5bmMoKSB3aXRoIG1ldGhvZCBhbmQgcGFyYW1zIGFzIGFyZ3VtZW50cyxcbiAgICAgICAgICAgICAgICAvLyBpbnN0ZWFkIG9mIGEgSlNPTi1SUEMgcGF5bG9hZCBhbmQgY2FsbGJhY2tcbiAgICAgICAgICAgICAgICBjYXNlIHR5cGVvZiBtZXRob2RPclBheWxvYWQgPT09ICdzdHJpbmcnICYmXG4gICAgICAgICAgICAgICAgICAgIEFycmF5LmlzQXJyYXkocGFyYW1zT3JDYWxsYmFjayk6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNlbmRBc3luYyh7XG4gICAgICAgICAgICAgICAgICAgICAgICBqc29ucnBjOiAnMi4wJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZDogbWV0aG9kT3JQYXlsb2FkLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zOiBwYXJhbXNPckNhbGxiYWNrLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAvLyBzaWduYXR1cmUgdHlwZSAzOiBhcmcxIC0gSlNPTi1SUEMgcGF5bG9hZChzaG91bGQgYmUgc3luY2hyb25vdXMgbWV0aG9kcylcbiAgICAgICAgICAgICAgICAvLyBldGhlcmV1bS5zZW5kKHBheWxvYWQ6IEpzb25ScGNSZXF1ZXN0KTogdW5rbm93bjtcbiAgICAgICAgICAgICAgICAvLyBUaGlzIHNpZ25hdHVyZSBlbmFibGVzIHlvdSB0byBjYWxsIHNvbWUgdHlwZSBvZiBSUEMgbWV0aG9kcyBzeW5jaHJvbm91c2x5XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2VuZEFzeW5jKG1ldGhvZE9yUGF5bG9hZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBERVBSRUNBVEVEIEFQSTogc2VlIGh0dHBzOi8vZG9jcy5tZXRhbWFzay5pby9ndWlkZS9ldGhlcmV1bS1wcm92aWRlci5odG1sI2xlZ2FjeS1tZXRob2RzIGltcGxlbWVudGF0aW9uXG4gICAgLy8gd2ViMyB2MS54IEJhdGNoUmVxdWVzdCBzdGlsbCBkZXBlbmRzIG9uIGl0IHNvIHdlIG5lZWQgdG8gaW1wbGVtZW50IGFueXdheSDCr1xcXyjjg4QpXy/Cr1xuICAgIHNlbmRBc3luYyhwYXlsb2FkLCBjYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3Qgc2VwYXJhdGVSZXF1ZXN0cyA9IChwYXlsb2FkKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBheWxvYWQucmVkdWNlKChhY2MsIHJlcXVlc3QpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVxdWVzdC5tZXRob2QgPT09ICdldGhfc2VuZFRyYW5zYWN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWNjLnNlbmRSZXF1ZXN0cy5wdXNoKChfYSA9IHJlcXVlc3QucGFyYW1zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FbMF0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWNjLm90aGVyUmVxdWVzdHMucHVzaCh0aGlzLnJlcXVlc3QocmVxdWVzdCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgICAgICAgICAgfSwgeyBzZW5kUmVxdWVzdHM6IFtdLCBvdGhlclJlcXVlc3RzOiBbXSB9KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBmdW5jdGlvbiBjcmVhdGVCYXNlUmVzcG9uc2UoaXRlbSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGlkOiBTdHJpbmcoaXRlbS5pZCksXG4gICAgICAgICAgICAgICAgICAgIGpzb25ycGM6ICcyLjAnLFxuICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IGl0ZW0ubWV0aG9kLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBwcm9jZXNzUmVzcG9uc2VzKHBheWxvYWQsIHJlc3BvbnNlcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHByb2Nlc3NlZFJlc3BvbnNlcyA9IFtdO1xuICAgICAgICAgICAgICAgIGxldCByZXNwb25zZUluZGV4ID0gMTtcbiAgICAgICAgICAgICAgICBwYXlsb2FkLmZvckVhY2goKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYmFzZVJlc3BvbnNlID0gY3JlYXRlQmFzZVJlc3BvbnNlKGl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbS5tZXRob2QgPT09ICdldGhfc2VuZFRyYW5zYWN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgYmFzZVJlc3BvbnNlLnJlc3VsdCA9IHJlc3BvbnNlc1swXS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJhc2VSZXNwb25zZS5lcnJvciA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2VzWzBdLnN0YXR1cyAhPT0gJ2Z1bGZpbGxlZCdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyByZXNwb25zZXNbMF0ucmVhc29uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlSW5kZXggPCByZXNwb25zZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmFzZVJlc3BvbnNlLnJlc3VsdCA9IHJlc3BvbnNlc1tyZXNwb25zZUluZGV4XS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYXNlUmVzcG9uc2UuZXJyb3IgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZXNbcmVzcG9uc2VJbmRleF0uc3RhdHVzICE9PSAnZnVsZmlsbGVkJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyByZXNwb25zZXNbcmVzcG9uc2VJbmRleF0ucmVhc29uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZUluZGV4Kys7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcHJvY2Vzc2VkUmVzcG9uc2VzLnB1c2goYmFzZVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvY2Vzc2VkUmVzcG9uc2VzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaGFuZGxlUmVxdWVzdCA9IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gd2ViMyB2MS54IGNvbmNhdCBiYXRjaGVkIEpTT04tUlBDIHJlcXVlc3RzIHRvIGFuIGFycmF5LCBoYW5kbGUgaXQgaGVyZVxuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHBheWxvYWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgc2VuZFJlcXVlc3RzLCBvdGhlclJlcXVlc3RzIH0gPSBzZXBhcmF0ZVJlcXVlc3RzKHBheWxvYWQpO1xuICAgICAgICAgICAgICAgICAgICAvLyBjb2xsZWN0IHRyYW5zYWN0aW9ucyBhbmQgc2VuZCBiYXRjaCB3aXRoIGN1c3RvbSBtZXRob2RcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYmF0Y2hSZXFQYXlsb2FkID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiAnd2FsbGV0X3NlbmRNdWx0aUNhbGxUcmFuc2FjdGlvbicsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXM6IFtzZW5kUmVxdWVzdHMsIGZhbHNlXSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaXNTZW5kUmVxdWVzdHNFbXB0eSA9IHNlbmRSZXF1ZXN0cy5sZW5ndGggPT09IDA7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGlkQmFzZSA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDEwMDAwKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYWxsUHJvbWlzZSA9IGlzU2VuZFJlcXVlc3RzRW1wdHlcbiAgICAgICAgICAgICAgICAgICAgICAgID8gWy4uLm90aGVyUmVxdWVzdHNdXG4gICAgICAgICAgICAgICAgICAgICAgICA6IFt0aGlzLnJlcXVlc3QoYmF0Y2hSZXFQYXlsb2FkKSwgLi4ub3RoZXJSZXF1ZXN0c107XG4gICAgICAgICAgICAgICAgICAgIC8vIHJlc29sdmUgcmVzcG9uc2Ugd2hlbiBhbGwgcmVxdWVzdCBhcmUgZXhlY3V0ZWRcbiAgICAgICAgICAgICAgICAgICAgUHJvbWlzZS5hbGxTZXR0bGVkKGFsbFByb21pc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAudGhlbigocmVzcG9uc2VzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNTZW5kUmVxdWVzdHNFbXB0eSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKHJlc3BvbnNlcy5tYXAoKHJlc3BvbnNlLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogU3RyaW5nKCgoX2EgPSBwYXlsb2FkW2luZGV4XSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmlkKSB8fCBpZEJhc2UgKyBpbmRleCArIDEpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAganNvbnJwYzogJzIuMCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IHBheWxvYWRbaW5kZXhdLm1ldGhvZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDogcmVzcG9uc2Uuc3RhdHVzID09PSAnZnVsZmlsbGVkJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gcmVzcG9uc2UudmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiByZXNwb25zZS5zdGF0dXMgIT09ICdmdWxmaWxsZWQnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyByZXNwb25zZS5yZWFzb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBvcmlnaW5hbExlbmd0aFJlc3BvbnNlID0gcHJvY2Vzc1Jlc3BvbnNlcyhwYXlsb2FkLCByZXNwb25zZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUob3JpZ2luYWxMZW5ndGhSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBkaXN0LmV0aEVycm9ycy5ycGMuaW50ZXJuYWwoZXJyb3IgPT09IG51bGwgfHwgZXJyb3IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVycm9yLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVxdWVzdChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHBheWxvYWQpLCB7IGlkOiBOdW1iZXIocGF5bG9hZC5pZCkgfSkpLnRoZW4ocmVzb2x2ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBleGVjdXRlIGNhbGxiYWNrIG9yIHJldHVybiBwcm9taXNlLCBkZXBkZW5kcyBvbiBjYWxsYmFjayBhcmcgZ2l2ZW4gb3Igbm90XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlUmVxdWVzdFxuICAgICAgICAgICAgICAgICAgICAudGhlbigoZGF0YSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgZGF0YSk7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLmNhdGNoKChlcnJvcikgPT4gY2FsbGJhY2soZXJyb3IpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBoYW5kbGVSZXF1ZXN0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZGluZyB1c2VyT3BlcmF0aW9uIHVzaW5nIEJsb2N0byBTREsuXG4gICAgICogQHBhcmFtIHtJVXNlck9wZXJhdGlvbn0gdXNlck9wIC0gdXNlck9wZXJhdGlvbiBvYmplY3RcbiAgICAgKiBAcmVtYXJrcyBObyBuZWVkIHRvIGluY2x1ZGUgbm9uY2UsIGluaXRDb2RlLCBhbmQgc2lnbmF0dXJlIGFzIHBhcmFtZXRlcnMgd2hlbiB1c2luZyBCbG9jdG9TREsgdG8gc2VuZCB1c2VyT3BlcmF0aW9uLlxuICAgICAqIFRoZXNlIHBhcmFtZXRlcnMgd2lsbCBiZSBpZ25vcmVkLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPHN0cmluZz59IC0gdXNlck9wZXJhdGlvbiBoYXNoXG4gICAgICovXG4gICAgc2VuZFVzZXJPcGVyYXRpb24odXNlck9wKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdldGhfc2VuZFVzZXJPcGVyYXRpb24nLFxuICAgICAgICAgICAgICAgIHBhcmFtczogW3VzZXJPcF0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJlcXVlc3QocGF5bG9hZCkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2csIF9oO1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgLy8gd2ViMy5qcyB2NCBiYXRjaCBlbnRyeSBwb2ludFxuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocGF5bG9hZCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zZW5kQXN5bmMocGF5bG9hZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIShwYXlsb2FkID09PSBudWxsIHx8IHBheWxvYWQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBheWxvYWQubWV0aG9kKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBkaXN0LmV0aEVycm9ycy5ycGMuaW52YWxpZFJlcXVlc3QoKTtcbiAgICAgICAgICAgIGNvbnN0IHsgYmxvY2tjaGFpbk5hbWUsIHN3aXRjaGFibGVOZXR3b3JrLCBzZXNzaW9uS2V5RW52IH0gPSB5aWVsZCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9FdGhlcmV1bVByb3ZpZGVyX2luc3RhbmNlcywgXCJtXCIsIF9FdGhlcmV1bVByb3ZpZGVyX2dldEJsb2N0b1Byb3BlcnRpZXMpLmNhbGwodGhpcyk7XG4gICAgICAgICAgICBpZiAoKF9hID0gdGhpcy5leGlzdGVkU0RLKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaXNCbG9jdG8pIHtcbiAgICAgICAgICAgICAgICBpZiAocGF5bG9hZC5tZXRob2QgPT09ICd3YWxsZXRfc3dpdGNoRXRoZXJldW1DaGFpbicpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoKF9jID0gKF9iID0gcGF5bG9hZCA9PT0gbnVsbCB8fCBwYXlsb2FkID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXlsb2FkLnBhcmFtcykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iWzBdKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuY2hhaW5JZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGRpc3QuZXRoRXJyb3JzLnJwYy5pbnZhbGlkUGFyYW1zKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXhpc3RlZFNESy5yZXF1ZXN0KHBheWxvYWQpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5ldHdvcmtWZXJzaW9uID0gYCR7cGFyc2VDaGFpbklkKChfYSA9IHBheWxvYWQgPT09IG51bGwgfHwgcGF5bG9hZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGF5bG9hZC5wYXJhbXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVswXS5jaGFpbklkKX1gO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGFpbklkID0gYDB4JHtwYXJzZUNoYWluSWQoKF9iID0gcGF5bG9hZCA9PT0gbnVsbCB8fCBwYXlsb2FkID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXlsb2FkLnBhcmFtcykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iWzBdLmNoYWluSWQpLnRvU3RyaW5nKDE2KX1gO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5ycGMgPSAoX2MgPSBzd2l0Y2hhYmxlTmV0d29yayA9PT0gbnVsbCB8fCBzd2l0Y2hhYmxlTmV0d29yayA9PT0gdm9pZCAwID8gdm9pZCAwIDogc3dpdGNoYWJsZU5ldHdvcmtbdGhpcy5uZXR3b3JrVmVyc2lvbl0pID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5ycGNfdXJsO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5leGlzdGVkU0RLLnJlcXVlc3QocGF5bG9hZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBtZXRob2QgdGhhdCBkb2Vzbid0IHJlcXVpcmUgdXNlciB0byBiZSBjb25uZWN0ZWRcbiAgICAgICAgICAgIHN3aXRjaCAocGF5bG9hZC5tZXRob2QpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdldGhfY2hhaW5JZCc6IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hhaW5JZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAnbmV0X3ZlcnNpb24nOiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm5ldHdvcmtWZXJzaW9uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlICd3YWxsZXRfYWRkRXRoZXJldW1DaGFpbic6IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9hZFN3aXRjaGFibGVOZXR3b3JrKChwYXlsb2FkID09PSBudWxsIHx8IHBheWxvYWQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBheWxvYWQucGFyYW1zKSB8fCBbXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgJ2V0aF9ibG9ja051bWJlcic6XG4gICAgICAgICAgICAgICAgY2FzZSAnd2ViM19jbGllbnRWZXJzaW9uJzpcbiAgICAgICAgICAgICAgICBjYXNlICdldGhfY2FsbCc6IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLmhhbmRsZVJlYWRSZXF1ZXN0cyhwYXlsb2FkKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFyZXNwb25zZSB8fCAocmVzcG9uc2UgJiYgIXJlc3BvbnNlLnJlc3VsdCAmJiByZXNwb25zZS5lcnJvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9ICgoX2QgPSByZXNwb25zZSA9PT0gbnVsbCB8fCByZXNwb25zZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVzcG9uc2UuZXJyb3IpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5tZXNzYWdlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gcmVzcG9uc2UuZXJyb3IubWVzc2FnZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogJ1JlcXVlc3QgZmFpbGVkJztcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGRpc3QuZXRoRXJyb3JzLnJwYy5pbnRlcm5hbChlcnJvck1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgKHBheWxvYWQgPT09IG51bGwgfHwgcGF5bG9hZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGF5bG9hZC5jYWxsYmFjaykgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBheWxvYWQuY2FsbGJhY2sobnVsbCwgcmVzcG9uc2UucmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UucmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlICd3YWxsZXRfc3dpdGNoRXRoZXJldW1DaGFpbic6IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlU3dpdGNoQ2hhaW4oKF9mID0gKF9lID0gcGF5bG9hZCA9PT0gbnVsbCB8fCBwYXlsb2FkID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXlsb2FkLnBhcmFtcykgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lWzBdKSA9PT0gbnVsbCB8fCBfZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2YuY2hhaW5JZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgJ3dhbGxldF9kaXNjb25uZWN0Jzoge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGVEaXNjb25uZWN0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgJ2V0aF9hY2NvdW50cyc6IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdldEV2bUFkZHJlc3Moc2Vzc2lvbktleUVudiwgYmxvY2tjaGFpbk5hbWUpIHx8IFtdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE1ldGhvZCB0aGF0IHJlcXVpcmVzIHVzZXIgdG8gYmUgY29ubmVjdGVkXG4gICAgICAgICAgICBpZiAoIWdldEV2bUFkZHJlc3Moc2Vzc2lvbktleUVudiwgYmxvY2tjaGFpbk5hbWUpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZW1haWwgPSAoX2cgPSBwYXlsb2FkID09PSBudWxsIHx8IHBheWxvYWQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBheWxvYWQucGFyYW1zKSA9PT0gbnVsbCB8fCBfZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2dbMF07XG4gICAgICAgICAgICAgICAgaWYgKHBheWxvYWQubWV0aG9kID09PSAnZXRoX3JlcXVlc3RBY2NvdW50cycgJiYgaXNFbWFpbChlbWFpbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgeWllbGQgdGhpcy5lbmFibGUoZW1haWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgeWllbGQgdGhpcy5lbmFibGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGxldCByZXNwb25zZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgbGV0IHJlc3VsdCA9IG51bGw7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChwYXlsb2FkLm1ldGhvZCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdldGhfcmVxdWVzdEFjY291bnRzJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0geWllbGQgdGhpcy5mZXRjaEFjY291bnRzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnZXRoX2NvaW5iYXNlJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gKF9oID0gZ2V0RXZtQWRkcmVzcyhzZXNzaW9uS2V5RW52LCBibG9ja2NoYWluTmFtZSkpID09PSBudWxsIHx8IF9oID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfaFswXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2V0aF9zaWduVHlwZWREYXRhX3YzJzpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnZXRoX3NpZ25UeXBlZERhdGEnOlxuICAgICAgICAgICAgICAgICAgICBjYXNlICdldGhfc2lnblR5cGVkRGF0YV92NCc6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3BlcnNvbmFsX3NpZ24nOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB5aWVsZCB0aGlzLmhhbmRsZVNpZ24ocGF5bG9hZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXNlICdldGhfc2lnbic6XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBkaXN0LmV0aEVycm9ycy5ycGMubWV0aG9kTm90Rm91bmQoJ01ldGhvZCBOb3QgU3VwcG9ydGVkOiBldGhfc2lnbiBoYXMgYmVlbiBkaXNhYmxlZCcpO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdldGhfc2VuZFRyYW5zYWN0aW9uJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHlpZWxkIHRoaXMuaGFuZGxlU2VuZFRyYW5zYWN0aW9uKHBheWxvYWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3dhbGxldF9zZW5kTXVsdGlDYWxsVHJhbnNhY3Rpb24nOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0geWllbGQgdGhpcy5oYW5kbGVTZW5kQmF0Y2hUcmFuc2FjdGlvbihwYXlsb2FkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdldGhfc2lnblRyYW5zYWN0aW9uJzpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnZXRoX3NlbmRSYXdUcmFuc2FjdGlvbic6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGRpc3QuZXRoRXJyb3JzLnJwYy5tZXRob2ROb3RTdXBwb3J0ZWQoJ01ldGhvZCBOb3QgU3VwcG9ydGVkOiAnICsgcGF5bG9hZC5tZXRob2QpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2V0aF9zZW5kVXNlck9wZXJhdGlvbic6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB5aWVsZCB0aGlzLmhhbmRsZVNlbmRVc2VyT3BlcmF0aW9uKHBheWxvYWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2V0aF9lc3RpbWF0ZVVzZXJPcGVyYXRpb25HYXMnOlxuICAgICAgICAgICAgICAgICAgICBjYXNlICdldGhfZ2V0VXNlck9wZXJhdGlvbkJ5SGFzaCc6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2V0aF9nZXRVc2VyT3BlcmF0aW9uUmVjZWlwdCc6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2V0aF9zdXBwb3J0ZWRFbnRyeVBvaW50cyc6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB5aWVsZCB0aGlzLmhhbmRsZUJ1bmRsZXIocGF5bG9hZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlID0geWllbGQgdGhpcy5oYW5kbGVSZWFkUmVxdWVzdHMocGF5bG9hZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZSAmJiAhcmVzcG9uc2UucmVzdWx0ICYmIHJlc3BvbnNlLmVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IHJlc3BvbnNlLmVycm9yLm1lc3NhZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgID8gcmVzcG9uc2UuZXJyb3IubWVzc2FnZVxuICAgICAgICAgICAgICAgICAgICAgICAgOiAnUmVxdWVzdCBmYWlsZWQnO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBkaXN0LmV0aEVycm9ycy5ycGMuaW50ZXJuYWwoZXJyb3JNZXNzYWdlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UucmVzdWx0O1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBkaXN0LmV0aEVycm9ycy5ycGMuaW50ZXJuYWwoZXJyb3IgPT09IG51bGwgfHwgZXJyb3IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVycm9yLm1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgYmxvY3RvQXBpKHVybCwgb3B0aW9ucykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCB7IHdhbGxldFNlcnZlciwgYmxvY2tjaGFpbk5hbWUsIHNlc3Npb25LZXlFbnYgfSA9IHlpZWxkIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0V0aGVyZXVtUHJvdmlkZXJfaW5zdGFuY2VzLCBcIm1cIiwgX0V0aGVyZXVtUHJvdmlkZXJfZ2V0QmxvY3RvUHJvcGVydGllcykuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIGNvbnN0IHNlc3Npb25JZCA9ICgoX2EgPSBnZXRBY2NvdW50U3RvcmFnZShzZXNzaW9uS2V5RW52KSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNvZGUpIHx8ICcnO1xuICAgICAgICAgICAgaWYgKCFzZXNzaW9uSWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBkaXN0LmV0aEVycm9ycy5wcm92aWRlci51bmF1dGhvcml6ZWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmZXRjaChgJHt3YWxsZXRTZXJ2ZXJ9L2FwaS8ke2Jsb2NrY2hhaW5OYW1lfSR7dXJsfWAsIE9iamVjdC5hc3NpZ24oeyBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICAgICAgICAgICAgICAgICdCbG9jdG8tQXBwbGljYXRpb24tSWRlbnRpZmllcic6IHRoaXMuYXBwSWQsXG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICAgICAgICAgICAgICAgICdCbG9jdG8tU2Vzc2lvbi1JZGVudGlmaWVyJzogc2Vzc2lvbklkLFxuICAgICAgICAgICAgICAgIH0gfSwgb3B0aW9ucykpXG4gICAgICAgICAgICAgICAgLnRoZW4oKHJlc3BvbnNlKSA9PiByZXNwb25zZVNlc3Npb25HdWFyZChyZXNwb25zZSwgc2Vzc2lvbktleUVudiwgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICAoX2EgPSB0aGlzLmV2ZW50TGlzdGVuZXJzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZGlzY29ubmVjdC5mb3JFYWNoKChsaXN0ZW5lcikgPT4gbGlzdGVuZXIoZGlzdC5ldGhFcnJvcnMucHJvdmlkZXIuZGlzY29ubmVjdGVkKCkpKTtcbiAgICAgICAgICAgIH0pKVxuICAgICAgICAgICAgICAgIC5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICgoZSA9PT0gbnVsbCB8fCBlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlLmVycm9yX2NvZGUpID09PSAndW5zdXBwb3J0ZWRfbWV0aG9kJykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBkaXN0LmV0aEVycm9ycy5ycGMubWV0aG9kTm90U3VwcG9ydGVkKCdNZXRob2QgTm90IFN1cHBvcnRlZDogJyArIGUubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBkaXN0LmV0aEVycm9ycy5ycGMuc2VydmVyKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IC0zMjAwNSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGBCbG9jdG8gc2VydmVyIGVycm9yOiAke2UubWVzc2FnZX1gLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJlc3BvbnNlTGlzdGVuZXIoZnJhbWUsIG9iamVjdEtleSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgeyB3YWxsZXRTZXJ2ZXIgfSA9IHlpZWxkIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0V0aGVyZXVtUHJvdmlkZXJfaW5zdGFuY2VzLCBcIm1cIiwgX0V0aGVyZXVtUHJvdmlkZXJfZ2V0QmxvY3RvUHJvcGVydGllcykuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiBhZGRTZWxmUmVtb3ZhYmxlSGFuZGxlcignbWVzc2FnZScsIChldmVudCwgcmVtb3ZlRXZlbnRMaXN0ZW5lcikgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGUgPSBldmVudDtcbiAgICAgICAgICAgICAgICBpZiAoZS5vcmlnaW4gPT09IHdhbGxldFNlcnZlciAmJlxuICAgICAgICAgICAgICAgICAgICBlLmRhdGEudHlwZSA9PT0gJ0VUSDpGUkFNRTpSRVNQT05TRScpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUuZGF0YS5zdGF0dXMgPT09ICdBUFBST1ZFRCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZUV2ZW50TGlzdGVuZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRldGF0Y2hGcmFtZShmcmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGUuZGF0YVtvYmplY3RLZXldKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoZS5kYXRhLnN0YXR1cyA9PT0gJ0RFQ0xJTkVEJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGV0YXRjaEZyYW1lKGZyYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlLmRhdGEuZXJyb3JDb2RlID09PSAnaW5jb3JyZWN0X3Nlc3Npb25faWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVEaXNjb25uZWN0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZGlzdC5ldGhFcnJvcnMucHJvdmlkZXIudXNlclJlamVjdGVkUmVxdWVzdChlLmRhdGEuZXJyb3JNZXNzYWdlKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGUuZGF0YS50eXBlID09PSAnRVRIOkZSQU1FOkNMT1NFJykge1xuICAgICAgICAgICAgICAgICAgICByZW1vdmVFdmVudExpc3RlbmVyKCk7XG4gICAgICAgICAgICAgICAgICAgIGRldGF0Y2hGcmFtZShmcmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChkaXN0LmV0aEVycm9ycy5wcm92aWRlci51c2VyUmVqZWN0ZWRSZXF1ZXN0KCdVc2VyIGRlY2xpbmVkIHRoZSByZXF1ZXN0JykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNldElmcmFtZSh1cmwsIGJsb2NrY2hhaW4pIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHRocm93IGRpc3QuZXRoRXJyb3JzLnByb3ZpZGVyLmN1c3RvbSh7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IDEwMDEsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdCbG9jdG8gU0RLIG9ubHkgd29ya3MgaW4gYnJvd3NlciBlbnZpcm9ubWVudCcsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB7IHdhbGxldFNlcnZlciwgYmxvY2tjaGFpbk5hbWUgfSA9IHlpZWxkIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0V0aGVyZXVtUHJvdmlkZXJfaW5zdGFuY2VzLCBcIm1cIiwgX0V0aGVyZXVtUHJvdmlkZXJfZ2V0QmxvY3RvUHJvcGVydGllcykuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIGNvbnN0IGZyYW1lID0gY3JlYXRlRnJhbWUoYCR7d2FsbGV0U2VydmVyfS8ke3RoaXMuYXBwSWR9LyR7YmxvY2tjaGFpbiB8fCBibG9ja2NoYWluTmFtZX0ke3VybH1gKTtcbiAgICAgICAgICAgIGF0dGFjaEZyYW1lKGZyYW1lKTtcbiAgICAgICAgICAgIHJldHVybiBmcmFtZTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIGVpcC0xMTAyIGFsaWFzXG4gICAgLy8gREVQUkVDQVRFRCBBUEk6IGh0dHBzOi8vZ2l0aHViLmNvbS9ldGhlcmV1bS9FSVBzL2Jsb2IvbWFzdGVyL0VJUFMvZWlwLTExMDIubWRcbiAgICBlbmFibGUoZW1haWwpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZGlzdC5ldGhFcnJvcnMucHJvdmlkZXIuY3VzdG9tKHtcbiAgICAgICAgICAgICAgICAgICAgY29kZTogMTAwMSxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogJ0Jsb2N0byBTREsgb25seSB3b3JrcyBpbiBicm93c2VyIGVudmlyb25tZW50JyxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHsgd2FsbGV0U2VydmVyLCBibG9ja2NoYWluTmFtZSwgc2Vzc2lvbktleUVudiB9ID0geWllbGQgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfRXRoZXJldW1Qcm92aWRlcl9pbnN0YW5jZXMsIFwibVwiLCBfRXRoZXJldW1Qcm92aWRlcl9nZXRCbG9jdG9Qcm9wZXJ0aWVzKS5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgaWYgKChfYSA9IHRoaXMuZXhpc3RlZFNESykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmlzQmxvY3RvKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZXhpc3RlZFNESy5jaGFpbklkICE9PSB0aGlzLmNoYWluSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgeWllbGQgdGhpcy5leGlzdGVkU0RLLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiAnd2FsbGV0X2FkZEV0aGVyZXVtQ2hhaW4nLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zOiBbeyBjaGFpbklkOiB0aGlzLmNoYWluSWQgfV0sXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCB0aGlzLmV4aXN0ZWRTREsucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXRob2Q6ICd3YWxsZXRfc3dpdGNoRXRoZXJldW1DaGFpbicsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXM6IFt7IGNoYWluSWQ6IHRoaXMuY2hhaW5JZCB9XSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHNldEV2bUFkZHJlc3Moc2Vzc2lvbktleUVudiwgYmxvY2tjaGFpbk5hbWUsIFt0aGlzLmV4aXN0ZWRTREsuYWRkcmVzc10pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4gXG4gICAgICAgICAgICAgICAgLy8gYWRkIGEgc21hbGwgZGVsYXkgdG8gbWFrZSBzdXJlIHRoZSBuZXR3b3JrIGhhcyBiZWVuIHN3aXRjaGVkXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLmV4aXN0ZWRTREsuZW5hYmxlKCkudGhlbihyZXNvbHZlKS5jYXRjaChyZWplY3QpLCAxMCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYWRkcmVzcyA9IGdldEV2bUFkZHJlc3Moc2Vzc2lvbktleUVudiwgYmxvY2tjaGFpbk5hbWUpO1xuICAgICAgICAgICAgaWYgKGFkZHJlc3MpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShhZGRyZXNzKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoKTtcbiAgICAgICAgICAgIHBhcmFtcy5zZXQoJ2w2bicsIHdpbmRvdy5sb2NhdGlvbi5vcmlnaW4pO1xuICAgICAgICAgICAgcGFyYW1zLnNldCgndicsIFNES19WRVJTSU9OKTtcbiAgICAgICAgICAgIHBhcmFtcy5zZXQoJ3EnLCBgJHt3aW5kb3cubG9jYXRpb24ucGF0aG5hbWV9JHt3aW5kb3cubG9jYXRpb24uc2VhcmNofWApO1xuICAgICAgICAgICAgY29uc3QgZW1haWxQYXJhbSA9IGVtYWlsICYmIGlzRW1haWwoZW1haWwpID8gYC8ke2VtYWlsfWAgOiAnJztcbiAgICAgICAgICAgIGNvbnN0IGxvZ2luRnJhbWUgPSB5aWVsZCB0aGlzLnNldElmcmFtZShgL2F1dGhuJHtlbWFpbFBhcmFtfT8ke3BhcmFtcy50b1N0cmluZygpfWApO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICBhZGRTZWxmUmVtb3ZhYmxlSGFuZGxlcignbWVzc2FnZScsIChldmVudCwgcmVtb3ZlTGlzdGVuZXIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZSA9IGV2ZW50O1xuICAgICAgICAgICAgICAgICAgICBpZiAoZS5vcmlnaW4gPT09IHdhbGxldFNlcnZlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGUuZGF0YS50eXBlID09PSAnRVRIOkZSQU1FOlJFU1BPTlNFJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZUxpc3RlbmVyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGV0YXRjaEZyYW1lKGxvZ2luRnJhbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChfYSA9IHRoaXMuZXZlbnRMaXN0ZW5lcnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jb25uZWN0LmZvckVhY2goKGxpc3RlbmVyKSA9PiBsaXN0ZW5lcih7IGNoYWluSWQ6IHRoaXMuY2hhaW5JZCB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0QWNjb3VudFN0b3JhZ2Uoc2Vzc2lvbktleUVudiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBlLmRhdGEuY29kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZtOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbYmxvY2tjaGFpbk5hbWVdOiBbZS5kYXRhLmFkZHJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIGUuZGF0YS5leHApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoX2IgPSBlLmRhdGEpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5pc0FjY291bnRDaGFuZ2VkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbkNoYWluOiBDSEFJTi5FVEhFUkVVTSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdCTE9DVE9fU0RLOkFDQ09VTlRfQ0hBTkdFRCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRTZWxmUmVtb3ZhYmxlSGFuZGxlcignbWVzc2FnZScsIChldmVudCwgcmVtb3ZlTGlzdGVuZXIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2VFdmVudCA9IGV2ZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpc0FjY291bnRDaGFuZ2VkID0gKChfYSA9IG1lc3NhZ2VFdmVudC5kYXRhKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudHlwZSkgPT09ICdCTE9DVE9fU0RLOkFDQ09VTlRfQ0hBTkdFRCc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGlzQW5vdGhlckNoYWluID0gKChfYiA9IG1lc3NhZ2VFdmVudC5kYXRhKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iub3JpZ2luQ2hhaW4pICE9PSBDSEFJTi5FVEhFUkVVTTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzQWNjb3VudENoYW5nZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChfYyA9IHRoaXMuZXZlbnRMaXN0ZW5lcnMpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5hY2NvdW50c0NoYW5nZWQuZm9yRWFjaCgobGlzdGVuZXIpID0+IGxpc3RlbmVyKFtlLmRhdGEuYWRkcl0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNBY2NvdW50Q2hhbmdlZCAmJiBpc0Fub3RoZXJDaGFpbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVEaXNjb25uZWN0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVMaXN0ZW5lcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShbZS5kYXRhLmFkZHJdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlLmRhdGEudHlwZSA9PT0gJ0VUSDpGUkFNRTpDTE9TRScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVMaXN0ZW5lcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRldGF0Y2hGcmFtZShsb2dpbkZyYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZGlzdC5ldGhFcnJvcnMucHJvdmlkZXIudXNlclJlamVjdGVkUmVxdWVzdCgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBmZXRjaEFjY291bnRzKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfRXRoZXJldW1Qcm92aWRlcl9pbnN0YW5jZXMsIFwibVwiLCBfRXRoZXJldW1Qcm92aWRlcl9jaGVja05ldHdvcmtNYXRjaGVkKS5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgY29uc3QgeyBibG9ja2NoYWluTmFtZSwgc2Vzc2lvbktleUVudiB9ID0geWllbGQgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfRXRoZXJldW1Qcm92aWRlcl9pbnN0YW5jZXMsIFwibVwiLCBfRXRoZXJldW1Qcm92aWRlcl9nZXRCbG9jdG9Qcm9wZXJ0aWVzKS5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgY29uc3QgeyBhY2NvdW50cyB9ID0geWllbGQgdGhpcy5ibG9jdG9BcGkoYC9hY2NvdW50c2ApO1xuICAgICAgICAgICAgc2V0RXZtQWRkcmVzcyhzZXNzaW9uS2V5RW52LCBibG9ja2NoYWluTmFtZSwgYWNjb3VudHMpO1xuICAgICAgICAgICAgcmV0dXJuIGFjY291bnRzO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgaGFuZGxlUmVhZFJlcXVlc3RzKHBheWxvYWQpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0V0aGVyZXVtUHJvdmlkZXJfaW5zdGFuY2VzLCBcIm1cIiwgX0V0aGVyZXVtUHJvdmlkZXJfY2hlY2tOZXR3b3JrTWF0Y2hlZCkuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIHJldHVybiBmZXRjaCh0aGlzLnJwYywge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KE9iamVjdC5hc3NpZ24oeyBpZDogMSwganNvbnJwYzogJzIuMCcgfSwgcGF5bG9hZCkpLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigocmVzcG9uc2UpID0+IHJlc3BvbnNlLmpzb24oKSlcbiAgICAgICAgICAgICAgICAuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgICAgICAgICB0aHJvdyBkaXN0LmV0aEVycm9ycy5ycGMuaW50ZXJuYWwoZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGhhbmRsZVNpZ24oeyBtZXRob2QsIHBhcmFtcyB9KSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBsZXQgbWVzc2FnZSA9ICcnO1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocGFyYW1zKSkge1xuICAgICAgICAgICAgICAgIGlmIChtZXRob2QgPT09ICdwZXJzb25hbF9zaWduJykge1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlID0gaXNIZXhTdHJpbmcocGFyYW1zWzBdKVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBwYXJhbXNbMF0uc2xpY2UoMilcbiAgICAgICAgICAgICAgICAgICAgICAgIDogdXRmOFRvSGV4KHBhcmFtc1swXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKFtcbiAgICAgICAgICAgICAgICAgICAgJ2V0aF9zaWduVHlwZWREYXRhJyxcbiAgICAgICAgICAgICAgICAgICAgJ2V0aF9zaWduVHlwZWREYXRhX3YzJyxcbiAgICAgICAgICAgICAgICAgICAgJ2V0aF9zaWduVHlwZWREYXRhX3Y0JyxcbiAgICAgICAgICAgICAgICBdLmluY2x1ZGVzKG1ldGhvZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSA9IHBhcmFtc1sxXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBkb21haW4gfSA9IEpTT04ucGFyc2UobWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0hleFN0cmluZyhkb21haW4uY2hhaW5JZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGRpc3QuZXRoRXJyb3JzLnJwYy5pbnZhbGlkUGFyYW1zKGBQcm92aWRlZCBjaGFpbklkIFwiJHtkb21haW4uY2hhaW5JZH1cIiBtdXN0IGJlIGEgbnVtYmVyYCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlQ2hhaW5JZChkb21haW4uY2hhaW5JZCkgIT09IHBhcnNlQ2hhaW5JZCh0aGlzLmNoYWluSWQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBkaXN0LmV0aEVycm9ycy5ycGMuaW52YWxpZFBhcmFtcyhgUHJvdmlkZWQgY2hhaW5JZCBcIiR7ZG9tYWluLmNoYWluSWR9XCIgbXVzdCBtYXRjaCB0aGUgYWN0aXZlIGNoYWluSWQgXCIke3BhcnNlQ2hhaW5JZCh0aGlzLmNoYWluSWQpfVwiYCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9FdGhlcmV1bVByb3ZpZGVyX2luc3RhbmNlcywgXCJtXCIsIF9FdGhlcmV1bVByb3ZpZGVyX2NoZWNrTmV0d29ya01hdGNoZWQpLmNhbGwodGhpcyk7XG4gICAgICAgICAgICBjb25zdCB7IHNpZ25hdHVyZUlkIH0gPSB5aWVsZCB0aGlzLmJsb2N0b0FwaShgL3VzZXItc2lnbmF0dXJlYCwgeyBtZXRob2Q6ICdQT1NUJywgYm9keTogSlNPTi5zdHJpbmdpZnkoeyBtZXRob2QsIG1lc3NhZ2UgfSkgfSk7XG4gICAgICAgICAgICBjb25zdCBzaWduRnJhbWUgPSB5aWVsZCB0aGlzLnNldElmcmFtZShgL3VzZXItc2lnbmF0dXJlLyR7c2lnbmF0dXJlSWR9YCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXNwb25zZUxpc3RlbmVyKHNpZ25GcmFtZSwgJ3NpZ25hdHVyZScpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgaGFuZGxlU3dpdGNoQ2hhaW4odGFyZ2V0Q2hhaW5JZCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKCF0YXJnZXRDaGFpbklkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZGlzdC5ldGhFcnJvcnMucnBjLmludmFsaWRQYXJhbXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHsgd2FsbGV0U2VydmVyLCBibG9ja2NoYWluTmFtZSwgc2Vzc2lvbktleUVudiwgc3dpdGNoYWJsZU5ldHdvcmsgfSA9IHlpZWxkIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0V0aGVyZXVtUHJvdmlkZXJfaW5zdGFuY2VzLCBcIm1cIiwgX0V0aGVyZXVtUHJvdmlkZXJfZ2V0QmxvY3RvUHJvcGVydGllcykuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIGNvbnN0IG9sZEFjY291bnQgPSAoX2EgPSBnZXRFdm1BZGRyZXNzKHNlc3Npb25LZXlFbnYsIGJsb2NrY2hhaW5OYW1lKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hWzBdO1xuICAgICAgICAgICAgY29uc3Qgb2xkQ2hhaW5JZCA9IHBhcnNlQ2hhaW5JZCh0aGlzLmNoYWluSWQpO1xuICAgICAgICAgICAgY29uc3QgbmV3Q2hhaW5JZCA9IHBhcnNlQ2hhaW5JZCh0YXJnZXRDaGFpbklkKTtcbiAgICAgICAgICAgIGlmIChvbGRDaGFpbklkID09PSBuZXdDaGFpbklkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXN3aXRjaGFibGVOZXR3b3JrW25ld0NoYWluSWRdKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZGlzdC5ldGhFcnJvcnMucHJvdmlkZXIuY3VzdG9tKHtcbiAgICAgICAgICAgICAgICAgICAgY29kZTogNDkwMixcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogYFVucmVjb2duaXplZCBjaGFpbiBJRCBcIiR7bmV3Q2hhaW5JZH1cIi4gVHJ5IGFkZGluZyB0aGUgY2hhaW4gdXNpbmcgd2FsbGV0X2FkZEV0aGVyZXVtQ2hhaW4gZmlyc3QuYCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubmV0d29ya1ZlcnNpb24gPSBgJHtuZXdDaGFpbklkfWA7XG4gICAgICAgICAgICB0aGlzLmNoYWluSWQgPSBgMHgke25ld0NoYWluSWQudG9TdHJpbmcoMTYpfWA7XG4gICAgICAgICAgICB0aGlzLnJwYyA9IHN3aXRjaGFibGVOZXR3b3JrW25ld0NoYWluSWRdLnJwY191cmw7XG4gICAgICAgICAgICB0aGlzLl9ibG9jdG8gPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMuX2Jsb2N0byksIHsgYmxvY2tjaGFpbk5hbWU6ICcnLCBuZXR3b3JrVHlwZTogJycgfSk7XG4gICAgICAgICAgICBpZiAoIW9sZEFjY291bnQpIHtcbiAgICAgICAgICAgICAgICAoX2IgPSB0aGlzLmV2ZW50TGlzdGVuZXJzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2hhaW5DaGFuZ2VkLmZvckVhY2goKGxpc3RlbmVyKSA9PiBsaXN0ZW5lcih0aGlzLmNoYWluSWQpKTtcbiAgICAgICAgICAgICAgICB5aWVsZCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9FdGhlcmV1bVByb3ZpZGVyX2luc3RhbmNlcywgXCJtXCIsIF9FdGhlcmV1bVByb3ZpZGVyX2dldEJsb2N0b1Byb3BlcnRpZXMpLmNhbGwodGhpcyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBHbyBsb2dpbiBmbG93IHdoZW4gc3dpdGNoaW5nIHRvIGEgZGlmZmVyZW50IGJsb2N0byBzZXJ2ZXJcbiAgICAgICAgICAgIGlmIChzd2l0Y2hhYmxlTmV0d29ya1tuZXdDaGFpbklkXS53YWxsZXRfd2ViX3VybCAhPT1cbiAgICAgICAgICAgICAgICBzd2l0Y2hhYmxlTmV0d29ya1tvbGRDaGFpbklkXS53YWxsZXRfd2ViX3VybCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVuYWJsZSgpXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKChbbmV3QWNjb3VudF0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmV3QWNjb3VudCAhPT0gb2xkQWNjb3VudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgKF9hID0gdGhpcy5ldmVudExpc3RlbmVycykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmFjY291bnRzQ2hhbmdlZC5mb3JFYWNoKChsaXN0ZW5lcikgPT4gbGlzdGVuZXIoW25ld0FjY291bnRdKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ldmVudExpc3RlbmVycy5jaGFpbkNoYW5nZWQuZm9yRWFjaCgobGlzdGVuZXIpID0+IGxpc3RlbmVyKHRoaXMuY2hhaW5JZCkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubmV0d29ya1ZlcnNpb24gPSBgJHtvbGRDaGFpbklkfWA7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2hhaW5JZCA9IGAweCR7b2xkQ2hhaW5JZC50b1N0cmluZygxNil9YDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ycGMgPSBzd2l0Y2hhYmxlTmV0d29ya1tvbGRDaGFpbklkXS5ycGNfdXJsO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9ibG9jdG8gPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMuX2Jsb2N0byksIHsgYmxvY2tjaGFpbk5hbWU6ICcnLCBuZXR3b3JrVHlwZTogJycgfSk7XG4gICAgICAgICAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0V0aGVyZXVtUHJvdmlkZXJfaW5zdGFuY2VzLCBcIm1cIiwgX0V0aGVyZXVtUHJvdmlkZXJfZ2V0QmxvY3RvUHJvcGVydGllcykuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzd2l0Y2hDaGFpbkZyYW1lID0geWllbGQgdGhpcy5zZXRJZnJhbWUoYC9zd2l0Y2gtY2hhaW4/dG89JHtzd2l0Y2hhYmxlTmV0d29ya1tuZXdDaGFpbklkXS5uYW1lfWAsIHN3aXRjaGFibGVOZXR3b3JrW29sZENoYWluSWRdLm5hbWUpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICBhZGRTZWxmUmVtb3ZhYmxlSGFuZGxlcignbWVzc2FnZScsIChldmVudCwgcmVtb3ZlTGlzdGVuZXIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nLCBfaDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZSA9IGV2ZW50O1xuICAgICAgICAgICAgICAgICAgICBpZiAoZS5vcmlnaW4gPT09IHdhbGxldFNlcnZlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGUuZGF0YS50eXBlID09PSAnRVRIOkZSQU1FOlJFU1BPTlNFJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZUxpc3RlbmVyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGV0YXRjaEZyYW1lKHN3aXRjaENoYWluRnJhbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoKF9hID0gZS5kYXRhKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYWRkcikgJiYgb2xkQWNjb3VudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRBY2NvdW50U3RvcmFnZShzZXNzaW9uS2V5RW52LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiAoX2IgPSBlLmRhdGEpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jb2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZtOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW3N3aXRjaGFibGVOZXR3b3JrW25ld0NoYWluSWRdLm5hbWVdOiBbZS5kYXRhLmFkZHJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgKF9jID0gZS5kYXRhKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuZXhwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGUuZGF0YS5hZGRyICE9PSBvbGRBY2NvdW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoX2QgPSB0aGlzLmV2ZW50TGlzdGVuZXJzKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuYWNjb3VudHNDaGFuZ2VkLmZvckVhY2goKGxpc3RlbmVyKSA9PiBsaXN0ZW5lcihbZS5kYXRhLmFkZHJdKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKF9lID0gdGhpcy5ldmVudExpc3RlbmVycykgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lLmNoYWluQ2hhbmdlZC5mb3JFYWNoKChsaXN0ZW5lcikgPT4gbGlzdGVuZXIodGhpcy5jaGFpbklkKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfRXRoZXJldW1Qcm92aWRlcl9pbnN0YW5jZXMsIFwibVwiLCBfRXRoZXJldW1Qcm92aWRlcl9nZXRCbG9jdG9Qcm9wZXJ0aWVzKS5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUobnVsbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZS5kYXRhLnR5cGUgPT09ICdFVEg6RlJBTUU6Q0xPU0UnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlTGlzdGVuZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXRhdGNoRnJhbWUoc3dpdGNoQ2hhaW5GcmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChfZiA9IGUuZGF0YSkgPT09IG51bGwgfHwgX2YgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9mLmhhc0FwcHJvdmVkU3dpdGNoQ2hhaW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKF9nID0gdGhpcy5ldmVudExpc3RlbmVycykgPT09IG51bGwgfHwgX2cgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9nLmNoYWluQ2hhbmdlZC5mb3JFYWNoKChsaXN0ZW5lcikgPT4gbGlzdGVuZXIodGhpcy5jaGFpbklkKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZUFsbEV2bUFkZHJlc3Moc2Vzc2lvbktleUVudik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChfaCA9IHRoaXMuZXZlbnRMaXN0ZW5lcnMpID09PSBudWxsIHx8IF9oID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfaC5kaXNjb25uZWN0LmZvckVhY2goKGxpc3RlbmVyKSA9PiBsaXN0ZW5lcihkaXN0LmV0aEVycm9ycy5wcm92aWRlci5kaXNjb25uZWN0ZWQoKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9FdGhlcmV1bVByb3ZpZGVyX2luc3RhbmNlcywgXCJtXCIsIF9FdGhlcmV1bVByb3ZpZGVyX2dldEJsb2N0b1Byb3BlcnRpZXMpLmNhbGwodGhpcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUobnVsbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5ldHdvcmtWZXJzaW9uID0gYCR7b2xkQ2hhaW5JZH1gO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNoYWluSWQgPSBgMHgke29sZENoYWluSWQudG9TdHJpbmcoMTYpfWA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucnBjID0gc3dpdGNoYWJsZU5ldHdvcmtbb2xkQ2hhaW5JZF0ucnBjX3VybDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fYmxvY3RvID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLl9ibG9jdG8pLCB7IGJsb2NrY2hhaW5OYW1lOiAnJywgbmV0d29ya1R5cGU6ICcnIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9FdGhlcmV1bVByb3ZpZGVyX2luc3RhbmNlcywgXCJtXCIsIF9FdGhlcmV1bVByb3ZpZGVyX2dldEJsb2N0b1Byb3BlcnRpZXMpLmNhbGwodGhpcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChkaXN0LmV0aEVycm9ycy5wcm92aWRlci51c2VyUmVqZWN0ZWRSZXF1ZXN0KCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBoYW5kbGVTZW5kVHJhbnNhY3Rpb24ocGF5bG9hZCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9FdGhlcmV1bVByb3ZpZGVyX2luc3RhbmNlcywgXCJtXCIsIF9FdGhlcmV1bVByb3ZpZGVyX2NoZWNrTmV0d29ya01hdGNoZWQpLmNhbGwodGhpcyk7XG4gICAgICAgICAgICBjb25zdCB7IGlzVmFsaWQsIGludmFsaWRNc2cgfSA9IGlzVmFsaWRUcmFuc2FjdGlvbigoX2EgPSBwYXlsb2FkLnBhcmFtcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hWzBdKTtcbiAgICAgICAgICAgIGlmICghaXNWYWxpZCkge1xuICAgICAgICAgICAgICAgIHRocm93IGRpc3QuZXRoRXJyb3JzLnJwYy5pbnZhbGlkUGFyYW1zKGludmFsaWRNc2cpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0V0aGVyZXVtUHJvdmlkZXJfaW5zdGFuY2VzLCBcIm1cIiwgX0V0aGVyZXVtUHJvdmlkZXJfY3JlYXRlQXV0aHpGcmFtZSkuY2FsbCh0aGlzLCBwYXlsb2FkLnBhcmFtcyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBoYW5kbGVTZW5kQmF0Y2hUcmFuc2FjdGlvbihwYXlsb2FkKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9FdGhlcmV1bVByb3ZpZGVyX2luc3RhbmNlcywgXCJtXCIsIF9FdGhlcmV1bVByb3ZpZGVyX2NoZWNrTmV0d29ya01hdGNoZWQpLmNhbGwodGhpcyk7XG4gICAgICAgICAgICBsZXQgb3JpZ2luYWxQYXJhbXMsIHJldmVydEZsYWc7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwYXlsb2FkLnBhcmFtcykgJiYgcGF5bG9hZC5wYXJhbXMubGVuZ3RoID49IDIpIHtcbiAgICAgICAgICAgICAgICBbb3JpZ2luYWxQYXJhbXMsIHJldmVydEZsYWddID0gcGF5bG9hZC5wYXJhbXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBvcmlnaW5hbFBhcmFtcyA9IHBheWxvYWQucGFyYW1zO1xuICAgICAgICAgICAgICAgIHJldmVydEZsYWcgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJldmVydCA9IHJldmVydEZsYWcgPyByZXZlcnRGbGFnIDogZmFsc2U7XG4gICAgICAgICAgICBjb25zdCB7IGlzVmFsaWQsIGludmFsaWRNc2cgfSA9IGlzVmFsaWRUcmFuc2FjdGlvbnMob3JpZ2luYWxQYXJhbXMpO1xuICAgICAgICAgICAgaWYgKCFpc1ZhbGlkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZGlzdC5ldGhFcnJvcnMucnBjLmludmFsaWRQYXJhbXMoaW52YWxpZE1zZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfRXRoZXJldW1Qcm92aWRlcl9pbnN0YW5jZXMsIFwibVwiLCBfRXRoZXJldW1Qcm92aWRlcl9jcmVhdGVBdXRoekZyYW1lKS5jYWxsKHRoaXMsIG9yaWdpbmFsUGFyYW1zLCByZXZlcnQpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgaGFuZGxlU2VuZFVzZXJPcGVyYXRpb24ocGF5bG9hZCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfRXRoZXJldW1Qcm92aWRlcl9pbnN0YW5jZXMsIFwibVwiLCBfRXRoZXJldW1Qcm92aWRlcl9jaGVja05ldHdvcmtNYXRjaGVkKS5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgY29uc3QgeyBhdXRob3JpemF0aW9uSWQgfSA9IHlpZWxkIHRoaXMuYmxvY3RvQXBpKGAvdXNlci1vcGVyYXRpb25gLCB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkocGF5bG9hZC5wYXJhbXMpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCB1c2VyT1BGcmFtZSA9IHlpZWxkIHRoaXMuc2V0SWZyYW1lKGAvdXNlci1vcGVyYXRpb24vJHthdXRob3JpemF0aW9uSWR9YCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXNwb25zZUxpc3RlbmVyKHVzZXJPUEZyYW1lLCAndXNlck9wSGFzaCcpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgaGFuZGxlQnVuZGxlcihwYXlsb2FkKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9FdGhlcmV1bVByb3ZpZGVyX2luc3RhbmNlcywgXCJtXCIsIF9FdGhlcmV1bVByb3ZpZGVyX2NoZWNrTmV0d29ya01hdGNoZWQpLmNhbGwodGhpcyk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ibG9jdG9BcGkoYC9ycGMvYnVuZGxlcmAsIHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShPYmplY3QuYXNzaWduKHsgaWQ6IDEsIGpzb25ycGM6ICcyLjAnIH0sIHBheWxvYWQpKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgaGFuZGxlRGlzY29ubmVjdCgpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmICgoX2EgPSB0aGlzLmV4aXN0ZWRTREspID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5pc0Jsb2N0bykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmV4aXN0ZWRTREsucmVxdWVzdCh7IG1ldGhvZDogJ3dhbGxldF9kaXNjb25uZWN0JyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHsgc2Vzc2lvbktleUVudiB9ID0geWllbGQgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfRXRoZXJldW1Qcm92aWRlcl9pbnN0YW5jZXMsIFwibVwiLCBfRXRoZXJldW1Qcm92aWRlcl9nZXRCbG9jdG9Qcm9wZXJ0aWVzKS5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgcmVtb3ZlQWxsRXZtQWRkcmVzcyhzZXNzaW9uS2V5RW52KTtcbiAgICAgICAgICAgIChfYiA9IHRoaXMuZXZlbnRMaXN0ZW5lcnMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5kaXNjb25uZWN0LmZvckVhY2goKGxpc3RlbmVyKSA9PiBsaXN0ZW5lcihkaXN0LmV0aEVycm9ycy5wcm92aWRlci5kaXNjb25uZWN0ZWQoKSkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgbG9hZFN3aXRjaGFibGVOZXR3b3JrKG5ldHdvcmtMaXN0KSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAvLyBzZXR1cCBzd2l0Y2hhYmxlIGxpc3QgaWYgdXNlciBzZXQgbmV0d29ya0xpc3RcbiAgICAgICAgICAgIGlmIChuZXR3b3JrTGlzdCA9PT0gbnVsbCB8fCBuZXR3b3JrTGlzdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogbmV0d29ya0xpc3QubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbGlzdFRvQWRkID0gbmV0d29ya0xpc3QubWFwKCh7IGNoYWluSWQsIHJwY1VybHMgfSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWNoYWluSWQpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBkaXN0LmV0aEVycm9ycy5ycGMuaW52YWxpZFBhcmFtcygnRW1wdHkgY2hhaW5JZCcpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXJzZWRDaGFpbklkID0gYCR7cGFyc2VDaGFpbklkKGNoYWluSWQpfWA7XG4gICAgICAgICAgICAgICAgICAgIC8vIHNraXAgaWYgY2hhaW5JZCBhbHJlYWR5IGV4aXN0c1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fYmxvY3RvLnN3aXRjaGFibGVOZXR3b3JrW3BhcnNlZENoYWluSWRdKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcnNlZFJwYyA9IChycGNVcmxzID09PSBudWxsIHx8IHJwY1VybHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJwY1VybHNbMF0pIHx8IEVUSF9SUENfTElTVFtwYXJzZWRDaGFpbklkXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFwYXJzZWRScGMpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBkaXN0LmV0aEVycm9ycy5ycGMuaW52YWxpZFBhcmFtcygncnBjVXJscyByZXF1aXJlZCcpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfRXRoZXJldW1Qcm92aWRlcl9pbnN0YW5jZXMsIFwibVwiLCBfRXRoZXJldW1Qcm92aWRlcl9hZGRUb1N3aXRjaGFibGUpLmNhbGwodGhpcywge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hhaW5JZDogcGFyc2VkQ2hhaW5JZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJwY1VybHM6IFtwYXJzZWRScGNdLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwobGlzdFRvQWRkKS50aGVuKCgpID0+IG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZGlzdC5ldGhFcnJvcnMucnBjLmludmFsaWRQYXJhbXMoJ0VtcHR5IG5ldHdvcmtMaXN0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzdXBwb3J0Q2hhaW5MaXN0KCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3Qgc3VwcG9ydE5ldHdvcmtMaXN0ID0geWllbGQgZ2V0RXZtU3VwcG9ydCgpLmNhdGNoKChlKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZGlzdC5ldGhFcnJvcnMucHJvdmlkZXIuY3VzdG9tKHtcbiAgICAgICAgICAgICAgICAgICAgY29kZTogMTAwMSxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogYEdldCBibG9jdG8gc2VydmVyIGZhaWxlZDogJHtlLm1lc3NhZ2V9YCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHN1cHBvcnROZXR3b3JrTGlzdCkubWFwKChjaGFpbklkKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBkaXNwbGF5X25hbWUgfSA9IHN1cHBvcnROZXR3b3JrTGlzdFtjaGFpbklkXTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBjaGFpbklkLFxuICAgICAgICAgICAgICAgICAgICBjaGFpbk5hbWU6IGRpc3BsYXlfbmFtZSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBvbihldmVudCwgbGlzdGVuZXIpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAoKF9hID0gdGhpcy5leGlzdGVkU0RLKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaXNCbG9jdG8pXG4gICAgICAgICAgICB0aGlzLmV4aXN0ZWRTREsub24oZXZlbnQsIGxpc3RlbmVyKTtcbiAgICAgICAgc3VwZXIub24oZXZlbnQsIGxpc3RlbmVyKTtcbiAgICB9XG4gICAgcmVtb3ZlTGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKChfYSA9IHRoaXMuZXhpc3RlZFNESykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmlzQmxvY3RvKVxuICAgICAgICAgICAgdGhpcy5leGlzdGVkU0RLLm9mZihldmVudCwgbGlzdGVuZXIpO1xuICAgICAgICBzdXBlci5yZW1vdmVMaXN0ZW5lcihldmVudCwgbGlzdGVuZXIpO1xuICAgIH1cbn1cbl9FdGhlcmV1bVByb3ZpZGVyX2luc3RhbmNlcyA9IG5ldyBXZWFrU2V0KCksIF9FdGhlcmV1bVByb3ZpZGVyX2dldEJsb2N0b1Byb3BlcnRpZXMgPSBmdW5jdGlvbiBfRXRoZXJldW1Qcm92aWRlcl9nZXRCbG9jdG9Qcm9wZXJ0aWVzKCkge1xuICAgIHZhciBfYSwgX2I7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgaWYgKChfYSA9IHRoaXMuX2Jsb2N0bykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnVubG9hZGVkTmV0d29yaykge1xuICAgICAgICAgICAgeWllbGQgdGhpcy5sb2FkU3dpdGNoYWJsZU5ldHdvcmsodGhpcy5fYmxvY3RvLnVubG9hZGVkTmV0d29yayk7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fYmxvY3RvLnVubG9hZGVkTmV0d29yaztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fYmxvY3RvLnNlc3Npb25LZXlFbnYgJiZcbiAgICAgICAgICAgIHRoaXMuX2Jsb2N0by53YWxsZXRTZXJ2ZXIgJiZcbiAgICAgICAgICAgIHRoaXMuX2Jsb2N0by5ibG9ja2NoYWluTmFtZSAmJlxuICAgICAgICAgICAgdGhpcy5fYmxvY3RvLm5ldHdvcmtUeXBlICYmXG4gICAgICAgICAgICB0aGlzLl9ibG9jdG8uc3dpdGNoYWJsZU5ldHdvcmspIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9ibG9jdG87XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3VwcG9ydE5ldHdvcmtMaXN0ID0geWllbGQgZ2V0RXZtU3VwcG9ydCgpLmNhdGNoKChlKSA9PiB7XG4gICAgICAgICAgICB0aHJvdyBkaXN0LmV0aEVycm9ycy5wcm92aWRlci5jdXN0b20oe1xuICAgICAgICAgICAgICAgIGNvZGU6IDEwMDEsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogYEdldCBibG9jdG8gc2VydmVyIGZhaWxlZDogJHtlLm1lc3NhZ2V9YCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgeyBjaGFpbl9pZCwgbmFtZSwgbmV0d29ya190eXBlLCBibG9jdG9fc2VydmljZV9lbnZpcm9ubWVudCwgZGlzcGxheV9uYW1lLCB9ID0gKF9iID0gc3VwcG9ydE5ldHdvcmtMaXN0W3RoaXMubmV0d29ya1ZlcnNpb25dKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB7fTtcbiAgICAgICAgaWYgKCFjaGFpbl9pZCkge1xuICAgICAgICAgICAgdGhyb3cgZGlzdC5ldGhFcnJvcnMucHJvdmlkZXIudW5zdXBwb3J0ZWRNZXRob2QoYEdldCBzdXBwb3J0IGNoYWluIGZhaWxlZDogJHt0aGlzLm5ldHdvcmtWZXJzaW9ufSBtaWdodCBub3QgYmUgc3VwcG9ydGVkIHlldC5gKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB3YWxsZXRTZXJ2ZXIgPSB0aGlzLmluamVjdGVkV2FsbGV0U2VydmVyIHx8XG4gICAgICAgICAgICBFVEhfRU5WX1dBTExFVF9TRVJWRVJfTUFQUElOR1tibG9jdG9fc2VydmljZV9lbnZpcm9ubWVudF07XG4gICAgICAgIHRoaXMuX2Jsb2N0byA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5fYmxvY3RvKSwgeyBzZXNzaW9uS2V5RW52OiBFVEhfU0VTU0lPTl9LRVlfTUFQUElOR1tibG9jdG9fc2VydmljZV9lbnZpcm9ubWVudF0sIHdhbGxldFNlcnZlciwgYmxvY2tjaGFpbk5hbWU6IG5hbWUsIG5ldHdvcmtUeXBlOiBuZXR3b3JrX3R5cGUsIHN3aXRjaGFibGVOZXR3b3JrOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMuX2Jsb2N0by5zd2l0Y2hhYmxlTmV0d29yayksIHsgW2NoYWluX2lkXToge1xuICAgICAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgICAgICBkaXNwbGF5X25hbWUsXG4gICAgICAgICAgICAgICAgICAgIG5ldHdvcmtfdHlwZSxcbiAgICAgICAgICAgICAgICAgICAgd2FsbGV0X3dlYl91cmw6IHdhbGxldFNlcnZlcixcbiAgICAgICAgICAgICAgICAgICAgcnBjX3VybDogdGhpcy5ycGMsXG4gICAgICAgICAgICAgICAgfSB9KSB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Jsb2N0bztcbiAgICB9KTtcbn0sIF9FdGhlcmV1bVByb3ZpZGVyX2FkZFRvU3dpdGNoYWJsZSA9IGZ1bmN0aW9uIF9FdGhlcmV1bVByb3ZpZGVyX2FkZFRvU3dpdGNoYWJsZSh7IGNoYWluSWQsIHJwY1VybHMsIH0pIHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgeWllbGQgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfRXRoZXJldW1Qcm92aWRlcl9pbnN0YW5jZXMsIFwibVwiLCBfRXRoZXJldW1Qcm92aWRlcl9nZXRCbG9jdG9Qcm9wZXJ0aWVzKS5jYWxsKHRoaXMpO1xuICAgICAgICBjb25zdCBzdXBwb3J0TmV0d29ya0xpc3QgPSB5aWVsZCBnZXRFdm1TdXBwb3J0KCkuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgICAgIHRocm93IGRpc3QuZXRoRXJyb3JzLnByb3ZpZGVyLmN1c3RvbSh7XG4gICAgICAgICAgICAgICAgY29kZTogMTAwMSxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBgR2V0IGJsb2N0byBzZXJ2ZXIgZmFpbGVkOiAke2UubWVzc2FnZX1gLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCB7IGNoYWluX2lkLCBuYW1lLCBkaXNwbGF5X25hbWUsIG5ldHdvcmtfdHlwZSwgYmxvY3RvX3NlcnZpY2VfZW52aXJvbm1lbnQsIH0gPSAoX2EgPSBzdXBwb3J0TmV0d29ya0xpc3RbY2hhaW5JZF0pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHt9O1xuICAgICAgICBpZiAoIWNoYWluX2lkKVxuICAgICAgICAgICAgdGhyb3cgZGlzdC5ldGhFcnJvcnMucHJvdmlkZXIudW5zdXBwb3J0ZWRNZXRob2QoYEdldCBzdXBwb3J0IGNoYWluIGZhaWxlZDogJHtjaGFpbklkfSBtaWdodCBub3QgYmUgc3VwcG9ydGVkIHlldC5gKTtcbiAgICAgICAgY29uc3Qgd2FsbGV0X3dlYl91cmwgPSBFVEhfRU5WX1dBTExFVF9TRVJWRVJfTUFQUElOR1tibG9jdG9fc2VydmljZV9lbnZpcm9ubWVudF07XG4gICAgICAgIHRoaXMuX2Jsb2N0by5zd2l0Y2hhYmxlTmV0d29ya1tjaGFpbl9pZF0gPSB7XG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgZGlzcGxheV9uYW1lLFxuICAgICAgICAgICAgbmV0d29ya190eXBlLFxuICAgICAgICAgICAgd2FsbGV0X3dlYl91cmwsXG4gICAgICAgICAgICBycGNfdXJsOiBycGNVcmxzWzBdLFxuICAgICAgICB9O1xuICAgIH0pO1xufSwgX0V0aGVyZXVtUHJvdmlkZXJfY2hlY2tOZXR3b3JrTWF0Y2hlZCA9IGZ1bmN0aW9uIF9FdGhlcmV1bVByb3ZpZGVyX2NoZWNrTmV0d29ya01hdGNoZWQoKSB7XG4gICAgdmFyIF9hO1xuICAgIGlmICgoKF9hID0gdGhpcy5leGlzdGVkU0RLKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaXNCbG9jdG8pICYmXG4gICAgICAgIHBhcnNlQ2hhaW5JZCh0aGlzLmV4aXN0ZWRTREsuY2hhaW5JZCkgIT09IHBhcnNlQ2hhaW5JZCh0aGlzLmNoYWluSWQpKSB7XG4gICAgICAgIHRocm93IGRpc3QuZXRoRXJyb3JzLnByb3ZpZGVyLmNoYWluRGlzY29ubmVjdGVkKCk7XG4gICAgfVxufSwgX0V0aGVyZXVtUHJvdmlkZXJfY3JlYXRlQXV0aHpGcmFtZSA9IGZ1bmN0aW9uIF9FdGhlcmV1bVByb3ZpZGVyX2NyZWF0ZUF1dGh6RnJhbWUocGFyYW1zLCByZXZlcnQgPSB0cnVlKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgY29uc3QgeyBhdXRob3JpemF0aW9uSWQgfSA9IHlpZWxkIHRoaXMuYmxvY3RvQXBpKGAvYXV0aHpgLCB7XG4gICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KFtwYXJhbXMsIHJldmVydF0pLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgaWZyYW1lUGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpO1xuICAgICAgICBpZnJhbWVQYXJhbXMuc2V0KCdsNm4nLCB3aW5kb3cubG9jYXRpb24ub3JpZ2luKTtcbiAgICAgICAgaWZyYW1lUGFyYW1zLnNldCgncScsIGAke3dpbmRvdy5sb2NhdGlvbi5wYXRobmFtZX0ke3dpbmRvdy5sb2NhdGlvbi5zZWFyY2h9YCk7XG4gICAgICAgIGNvbnN0IGF1dGh6RnJhbWUgPSB5aWVsZCB0aGlzLnNldElmcmFtZShgL2F1dGh6LyR7YXV0aG9yaXphdGlvbklkfT8ke2lmcmFtZVBhcmFtcy50b1N0cmluZygpfWApO1xuICAgICAgICByZXR1cm4gdGhpcy5yZXNwb25zZUxpc3RlbmVyKGF1dGh6RnJhbWUsICd0eEhhc2gnKTtcbiAgICB9KTtcbn07XG5cbmNvbnN0IGNoZWNrTWVzc2FnZVBheWxvYWRGb3JtYXQgPSAocGF5bG9hZCkgPT4ge1xuICAgIHZhciBfYSwgX2I7XG4gICAgY29uc3QgZm9ybWF0dGVkUGF5bG9hZCA9IE9iamVjdC5hc3NpZ24oe30sIHBheWxvYWQpO1xuICAgIGNvbnN0IHsgbWVzc2FnZSwgbm9uY2UsIGFkZHJlc3MsIGFwcGxpY2F0aW9uLCBjaGFpbklkIH0gPSBwYXlsb2FkO1xuICAgIGlmICh0eXBlb2YgbWVzc2FnZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgZm9ybWF0dGVkUGF5bG9hZC5tZXNzYWdlID0gKF9hID0gU3RyaW5nKG1lc3NhZ2UpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAnJztcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBub25jZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgZm9ybWF0dGVkUGF5bG9hZC5ub25jZSA9IChfYiA9IFN0cmluZyhub25jZSkpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6ICcnO1xuICAgIH1cbiAgICBpZiAoYWRkcmVzcyAmJiB0eXBlb2YgYWRkcmVzcyAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIGZvcm1hdHRlZFBheWxvYWQuYWRkcmVzcyA9ICEhYWRkcmVzcztcbiAgICB9XG4gICAgaWYgKGFwcGxpY2F0aW9uICYmIHR5cGVvZiBhcHBsaWNhdGlvbiAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIGZvcm1hdHRlZFBheWxvYWQuYXBwbGljYXRpb24gPSAhIWFwcGxpY2F0aW9uO1xuICAgIH1cbiAgICBpZiAoY2hhaW5JZCAmJiB0eXBlb2YgY2hhaW5JZCAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIGZvcm1hdHRlZFBheWxvYWQuY2hhaW5JZCA9ICEhY2hhaW5JZDtcbiAgICB9XG4gICAgcmV0dXJuIGZvcm1hdHRlZFBheWxvYWQ7XG59O1xuY2xhc3MgQXB0b3NQcm92aWRlciBleHRlbmRzIEJsb2N0b1Byb3ZpZGVyIHtcbiAgICBnZXQgZXhpc3RlZFNESygpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKVxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIHdpbmRvdy5ibG9jdG9BcHRvcztcbiAgICB9XG4gICAgY29uc3RydWN0b3IoeyBjaGFpbklkLCBzZXJ2ZXIsIGFwcElkIH0pIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5wdWJsaWNLZXkgPSBbXTtcbiAgICAgICAgdGhpcy5hdXRoS2V5ID0gJyc7XG4gICAgICAgIHRoaXMub2ZmID0gdGhpcy5yZW1vdmVMaXN0ZW5lcjtcbiAgICAgICAgaW52YXJpYW50KGNoYWluSWQsIFwiJ2NoYWluSWQnIGlzIHJlcXVpcmVkXCIpO1xuICAgICAgICBpbnZhcmlhbnQoYXBwSWQsICdJdCBpcyBuZWNlc3NhcnkgdG8gaW50ZXJhY3Qgd2l0aCBCbG9jdG8gd2FsbGV0IHZpYSB5b3VyIGFwcCBpZC4gUGxlYXNlIHZpc2l0IGh0dHBzOi8vZGV2ZWxvcGVycy5ibG9jdG8uYXBwIGZvciBtb3JlIGRldGFpbHMuJyk7XG4gICAgICAgIHRoaXMuY2hhaW5JZCA9IGNoYWluSWQ7XG4gICAgICAgIHRoaXMubmV0d29ya05hbWUgPSBBUFRfQ0hBSU5fSURfTkFNRV9NQVBQSU5HW2NoYWluSWRdO1xuICAgICAgICB0aGlzLmFwaSA9IEFQVF9DSEFJTl9JRF9SUENfTUFQUElOR1tjaGFpbklkXTtcbiAgICAgICAgdGhpcy5zZXNzaW9uS2V5ID0gQVBUX1NFU1NJT05fS0VZX01BUFBJTkdbY2hhaW5JZF07XG4gICAgICAgIGNvbnN0IGRlZmF1bHRTZXJ2ZXIgPSBBUFRfQ0hBSU5fSURfU0VSVkVSX01BUFBJTkdbY2hhaW5JZF07XG4gICAgICAgIHRoaXMuYXBwSWQgPSBhcHBJZCB8fCBERUZBVUxUX0FQUF9JRDtcbiAgICAgICAgdGhpcy5zZXJ2ZXIgPSBzZXJ2ZXIgfHwgZGVmYXVsdFNlcnZlciB8fCAnJztcbiAgICB9XG4gICAgZ2V0IHB1YmxpY0FjY291bnQoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGFkZHJlc3M6ICgoX2EgPSBnZXRDaGFpbkFkZHJlc3ModGhpcy5zZXNzaW9uS2V5LCBDSEFJTi5BUFRPUykpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVswXSkgfHwgbnVsbCxcbiAgICAgICAgICAgIHB1YmxpY0tleTogdGhpcy5wdWJsaWNLZXkubGVuZ3RoID8gdGhpcy5wdWJsaWNLZXkgOiBudWxsLFxuICAgICAgICAgICAgLy8gQHRvZG86IHByb3ZpZGUgYXV0aGtleVxuICAgICAgICAgICAgYXV0aEtleTogbnVsbCxcbiAgICAgICAgICAgIG1pbktleXNSZXF1aXJlZDogMixcbiAgICAgICAgfTtcbiAgICB9XG4gICAgbmV0d29yaygpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbmFtZTogdGhpcy5uZXR3b3JrTmFtZSxcbiAgICAgICAgICAgICAgICBhcGk6IHRoaXMuYXBpLFxuICAgICAgICAgICAgICAgIGNoYWluSWQ6IHRoaXMuY2hhaW5JZC50b1N0cmluZygpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGlzQ29ubmVjdGVkKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gISEoKF9hID0gZ2V0Q2hhaW5BZGRyZXNzKHRoaXMuc2Vzc2lvbktleSwgQ0hBSU4uQVBUT1MpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubGVuZ3RoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNpZ25UcmFuc2FjdGlvbih0cmFuc2FjdGlvbikge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5leGlzdGVkU0RLKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXhpc3RlZFNESy5zaWduVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaGFzQ29ubmVjdGVkID0geWllbGQgdGhpcy5pc0Nvbm5lY3RlZCgpO1xuICAgICAgICAgICAgaWYgKCFoYXNDb25uZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICB5aWVsZCB0aGlzLmNvbm5lY3QoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghKChfYSA9IGdldENoYWluQWRkcmVzcyh0aGlzLnNlc3Npb25LZXksIENIQUlOLkFQVE9TKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxlbmd0aCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWwgdG8gZ2V0IGFjY291bnQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc2lnblRyYW5zYWN0aW9uIG1ldGhvZCBub3Qgc3VwcG9ydGVkLicpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZGlzY29ubmVjdCgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZXhpc3RlZFNESykge1xuICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMuZXhpc3RlZFNESy5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVtb3ZlQ2hhaW5BZGRyZXNzKHRoaXMuc2Vzc2lvbktleSwgQ0hBSU4uQVBUT1MpO1xuICAgICAgICAgICAgKF9hID0gdGhpcy5ldmVudExpc3RlbmVycykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRpc2Nvbm5lY3QuZm9yRWFjaCgobGlzdGVuZXIpID0+IGxpc3RlbmVyKHtcbiAgICAgICAgICAgICAgICBjb2RlOiA0OTAwLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdXYWxsZXQgZGlzY29ubmVjdGVkJyxcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNpZ25BbmRTdWJtaXRUcmFuc2FjdGlvbih0cmFuc2FjdGlvbiwgdHhPcHRpb25zID0ge30pIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmV4aXN0ZWRTREspIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5leGlzdGVkU0RLLnNpZ25BbmRTdWJtaXRUcmFuc2FjdGlvbih0cmFuc2FjdGlvbiwgdHhPcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGhhc0Nvbm5lY3RlZCA9IHlpZWxkIHRoaXMuaXNDb25uZWN0ZWQoKTtcbiAgICAgICAgICAgIGlmICghaGFzQ29ubmVjdGVkKSB7XG4gICAgICAgICAgICAgICAgeWllbGQgdGhpcy5jb25uZWN0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoISgoX2EgPSBnZXRDaGFpbkFkZHJlc3ModGhpcy5zZXNzaW9uS2V5LCBDSEFJTi5BUFRPUykpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sZW5ndGgpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsIHRvIGdldCBhY2NvdW50Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzZXNzaW9uSWQgPSAoKF9iID0gZ2V0QWNjb3VudFN0b3JhZ2UodGhpcy5zZXNzaW9uS2V5KSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNvZGUpIHx8ICcnO1xuICAgICAgICAgICAgY29uc3QgeyBhdXRob3JpemF0aW9uSWQgfSA9IHlpZWxkIGZldGNoKGAke3RoaXMuc2VydmVyfS9hcGkvYXB0b3MvYXV0aHpgLCB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICAgICAgICAgICAvLyBXZSBhbHJlYWR5IGNoZWNrIHRoZSBleGlzdGVuY2UgaW4gdGhlIGNvbnN0cnVjdG9yXG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICAgICAgICAgICAgICAgICdCbG9jdG8tQXBwbGljYXRpb24tSWRlbnRpZmllcic6IHRoaXMuYXBwSWQsXG4gICAgICAgICAgICAgICAgICAgICdCbG9jdG8tU2Vzc2lvbi1JZGVudGlmaWVyJzogc2Vzc2lvbklkLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0cmFuc2FjdGlvbiksIHR4T3B0aW9ucykpLFxuICAgICAgICAgICAgfSkudGhlbigocmVzcG9uc2UpID0+IHJlc3BvbnNlU2Vzc2lvbkd1YXJkKHJlc3BvbnNlLCB0aGlzLnNlc3Npb25LZXkpKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ3VycmVudGx5IG9ubHkgc3VwcG9ydGVkIGluIGJyb3dzZXInKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGF1dGh6RnJhbWUgPSBjcmVhdGVGcmFtZShgJHt0aGlzLnNlcnZlcn0vJHt0aGlzLmFwcElkfS9hcHRvcy9hdXRoei8ke2F1dGhvcml6YXRpb25JZH1gKTtcbiAgICAgICAgICAgIGF0dGFjaEZyYW1lKGF1dGh6RnJhbWUpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IGFkZFNlbGZSZW1vdmFibGVIYW5kbGVyKCdtZXNzYWdlJywgKGV2ZW50LCByZW1vdmVFdmVudExpc3RlbmVyKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgZSA9IGV2ZW50O1xuICAgICAgICAgICAgICAgIGlmIChlLm9yaWdpbiA9PT0gdGhpcy5zZXJ2ZXIgJiZcbiAgICAgICAgICAgICAgICAgICAgZS5kYXRhLnR5cGUgPT09ICdBUFRPUzpGUkFNRTpSRVNQT05TRScpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUuZGF0YS5zdGF0dXMgPT09ICdBUFBST1ZFRCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZUV2ZW50TGlzdGVuZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRldGF0Y2hGcmFtZShhdXRoekZyYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoeyBoYXNoOiBlLmRhdGEudHhIYXNoIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChlLmRhdGEuc3RhdHVzID09PSAnREVDTElORUQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVFdmVudExpc3RlbmVyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZXRhdGNoRnJhbWUoYXV0aHpGcmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZS5kYXRhLmVycm9yQ29kZSA9PT0gJ2luY29ycmVjdF9zZXNzaW9uX2lkJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihlLmRhdGEuZXJyb3JNZXNzYWdlKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzaWduTWVzc2FnZShwYXlsb2FkKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBmb3JtYXR0ZWRQYXlsb2FkID0gY2hlY2tNZXNzYWdlUGF5bG9hZEZvcm1hdChwYXlsb2FkKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmV4aXN0ZWRTREspIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5leGlzdGVkU0RLLnNpZ25NZXNzYWdlKGZvcm1hdHRlZFBheWxvYWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaGFzQ29ubmVjdGVkID0geWllbGQgdGhpcy5pc0Nvbm5lY3RlZCgpO1xuICAgICAgICAgICAgaWYgKCFoYXNDb25uZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICB5aWVsZCB0aGlzLmNvbm5lY3QoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghKChfYSA9IGdldENoYWluQWRkcmVzcyh0aGlzLnNlc3Npb25LZXksIENIQUlOLkFQVE9TKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxlbmd0aCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWwgdG8gZ2V0IGFjY291bnQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ3VycmVudGx5IG9ubHkgc3VwcG9ydGVkIGluIGJyb3dzZXInKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHNlc3Npb25JZCA9ICgoX2IgPSBnZXRBY2NvdW50U3RvcmFnZSh0aGlzLnNlc3Npb25LZXkpKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY29kZSkgfHwgJyc7XG4gICAgICAgICAgICBjb25zdCB7IHNpZ25hdHVyZUlkIH0gPSB5aWVsZCBmZXRjaChgJHt0aGlzLnNlcnZlcn0vYXBpL2FwdG9zL3VzZXItc2lnbmF0dXJlYCwge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgYWxyZWFkeSBjaGVjayB0aGUgZXhpc3RlbmNlIGluIHRoZSBjb25zdHJ1Y3RvclxuICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgICAgICAgICAgICAgICAnQmxvY3RvLUFwcGxpY2F0aW9uLUlkZW50aWZpZXInOiB0aGlzLmFwcElkLFxuICAgICAgICAgICAgICAgICAgICAnQmxvY3RvLVNlc3Npb24tSWRlbnRpZmllcic6IHNlc3Npb25JZCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGZvcm1hdHRlZFBheWxvYWQpLFxuICAgICAgICAgICAgfSkudGhlbigocmVzcG9uc2UpID0+IHJlc3BvbnNlU2Vzc2lvbkd1YXJkKHJlc3BvbnNlLCB0aGlzLnNlc3Npb25LZXkpKTtcbiAgICAgICAgICAgIGNvbnN0IHVybCA9IGAke3RoaXMuc2VydmVyfS8ke3RoaXMuYXBwSWR9L2FwdG9zL3VzZXItc2lnbmF0dXJlLyR7c2lnbmF0dXJlSWR9YDtcbiAgICAgICAgICAgIGNvbnN0IHNpZ25GcmFtZSA9IGNyZWF0ZUZyYW1lKHVybCk7XG4gICAgICAgICAgICBhdHRhY2hGcmFtZShzaWduRnJhbWUpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IGFkZFNlbGZSZW1vdmFibGVIYW5kbGVyKCdtZXNzYWdlJywgKGV2ZW50LCByZW1vdmVFdmVudExpc3RlbmVyKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgZSA9IGV2ZW50O1xuICAgICAgICAgICAgICAgIGlmIChlLm9yaWdpbiA9PT0gdGhpcy5zZXJ2ZXIgJiZcbiAgICAgICAgICAgICAgICAgICAgZS5kYXRhLnR5cGUgPT09ICdBUFRPUzpGUkFNRTpSRVNQT05TRScpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUuZGF0YS5zdGF0dXMgPT09ICdBUFBST1ZFRCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZUV2ZW50TGlzdGVuZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRldGF0Y2hGcmFtZShzaWduRnJhbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShlLmRhdGEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChlLmRhdGEuc3RhdHVzID09PSAnREVDTElORUQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVFdmVudExpc3RlbmVyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZXRhdGNoRnJhbWUoc2lnbkZyYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlLmRhdGEuZXJyb3JDb2RlID09PSAnaW5jb3JyZWN0X3Nlc3Npb25faWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKGUuZGF0YS5lcnJvck1lc3NhZ2UpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNvbm5lY3QoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5leGlzdGVkU0RLKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IFxuICAgICAgICAgICAgICAgIC8vIGFkZCBhIHNtYWxsIGRlbGF5IHRvIG1ha2Ugc3VyZSB0aGUgbmV0d29yayBoYXMgYmVlbiBzd2l0Y2hlZFxuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gdGhpcy5leGlzdGVkU0RLLmNvbm5lY3QoKS50aGVuKHJlc29sdmUpLmNhdGNoKHJlamVjdCksIDEwKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QoJ0N1cnJlbnRseSBvbmx5IHN1cHBvcnRlZCBpbiBicm93c2VyJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICgoX2EgPSBnZXRDaGFpbkFkZHJlc3ModGhpcy5zZXNzaW9uS2V5LCBDSEFJTi5BUFRPUykpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRkcmVzczogKChfYiA9IGdldENoYWluQWRkcmVzcyh0aGlzLnNlc3Npb25LZXksIENIQUlOLkFQVE9TKSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iWzBdKSB8fCBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHVibGljS2V5OiB0aGlzLnB1YmxpY0tleSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGF1dGhLZXk6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICBtaW5LZXlzUmVxdWlyZWQ6IDIsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBsb2NhdGlvbiA9IGVuY29kZVVSSUNvbXBvbmVudCh3aW5kb3cubG9jYXRpb24ub3JpZ2luKTtcbiAgICAgICAgICAgICAgICBjb25zdCBsb2dpbkZyYW1lID0gY3JlYXRlRnJhbWUoYCR7dGhpcy5zZXJ2ZXJ9LyR7dGhpcy5hcHBJZH0vYXB0b3MvYXV0aG4/bDZuPSR7bG9jYXRpb259JnY9JHtTREtfVkVSU0lPTn19YCk7XG4gICAgICAgICAgICAgICAgYXR0YWNoRnJhbWUobG9naW5GcmFtZSk7XG4gICAgICAgICAgICAgICAgYWRkU2VsZlJlbW92YWJsZUhhbmRsZXIoJ21lc3NhZ2UnLCAoZXZlbnQsIHJlbW92ZUxpc3RlbmVyKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfYywgX2QsIF9lLCBfZjtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZSA9IGV2ZW50O1xuICAgICAgICAgICAgICAgICAgICBpZiAoZS5vcmlnaW4gPT09IHRoaXMuc2VydmVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZS5kYXRhLnR5cGUgPT09ICdBUFRPUzpGUkFNRTpSRVNQT05TRScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVMaXN0ZW5lcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRldGF0Y2hGcmFtZShsb2dpbkZyYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRBY2NvdW50U3RvcmFnZSh0aGlzLnNlc3Npb25LZXksIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogZS5kYXRhLmNvZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjY291bnRzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbQ0hBSU4uQVBUT1NdOiBbZS5kYXRhLmFkZHJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIGUuZGF0YS5leHApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoX2MgPSBlLmRhdGEpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5pc0FjY291bnRDaGFuZ2VkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbkNoYWluOiBDSEFJTi5BUFRPUyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdCTE9DVE9fU0RLOkFDQ09VTlRfQ0hBTkdFRCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRTZWxmUmVtb3ZhYmxlSGFuZGxlcignbWVzc2FnZScsIChldmVudCwgcmVtb3ZlTGlzdGVuZXIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbWVzc2FnZUV2ZW50ID0gZXZlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoKF9hID0gbWVzc2FnZUV2ZW50LmRhdGEpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50eXBlKSA9PT0gJ0JMT0NUT19TREs6QUNDT1VOVF9DSEFOR0VEJyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKChfYiA9IG1lc3NhZ2VFdmVudC5kYXRhKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iub3JpZ2luQ2hhaW4pICE9PSBDSEFJTi5BUFRPUykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVMaXN0ZW5lcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChfZCA9IGdldENoYWluQWRkcmVzcyh0aGlzLnNlc3Npb25LZXksIENIQUlOLkFQVE9TKSkgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBwdWJsaWNfa2V5czogcHVibGljS2V5cyB9ID0geWllbGQgZmV0Y2goYCR7dGhpcy5zZXJ2ZXJ9L2Jsb2N0by9hcHRvcy9hY2NvdW50cy8keyhfZSA9IGdldENoYWluQWRkcmVzcyh0aGlzLnNlc3Npb25LZXksIENIQUlOLkFQVE9TKSkgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lWzBdfWApLnRoZW4oKHJlc3BvbnNlKSA9PiByZXNwb25zZS5qc29uKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wdWJsaWNLZXkgPSBwdWJsaWNLZXlzIHx8IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkcmVzczogKChfZiA9IGdldENoYWluQWRkcmVzcyh0aGlzLnNlc3Npb25LZXksIENIQUlOLkFQVE9TKSkgPT09IG51bGwgfHwgX2YgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9mWzBdKSB8fCAnJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwdWJsaWNLZXk6IHRoaXMucHVibGljS2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF1dGhLZXk6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWluS2V5c1JlcXVpcmVkOiAyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQHRvZG86IGJldHRlciBlcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGUuZGF0YS50eXBlID09PSAnQVBUT1M6RlJBTUU6Q0xPU0UnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlTGlzdGVuZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXRhdGNoRnJhbWUobG9naW5GcmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignVXNlciBkZWNsaW5lZCB0aGUgbG9naW4gcmVxdWVzdCcpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZmV0Y2hBZGRyZXNzKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBzZXNzaW9uSWQgPSAoKF9hID0gZ2V0QWNjb3VudFN0b3JhZ2UodGhpcy5zZXNzaW9uS2V5KSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNvZGUpIHx8ICcnO1xuICAgICAgICAgICAgY29uc3QgeyBhY2NvdW50cyB9ID0geWllbGQgZmV0Y2goYCR7dGhpcy5zZXJ2ZXJ9L2FwaS9hcHRvcy9hY2NvdW50c2AsIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIGFscmVhZHkgY2hlY2sgdGhlIGV4aXN0ZW5jZSBpbiB0aGUgY29uc3RydWN0b3JcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cbiAgICAgICAgICAgICAgICAgICAgJ0Jsb2N0by1BcHBsaWNhdGlvbi1JZGVudGlmaWVyJzogdGhpcy5hcHBJZCxcbiAgICAgICAgICAgICAgICAgICAgJ0Jsb2N0by1TZXNzaW9uLUlkZW50aWZpZXInOiBzZXNzaW9uSWQsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pLnRoZW4oKHJlc3BvbnNlKSA9PiByZXNwb25zZVNlc3Npb25HdWFyZChyZXNwb25zZSwgdGhpcy5zZXNzaW9uS2V5KSk7XG4gICAgICAgICAgICBzZXRDaGFpbkFkZHJlc3ModGhpcy5zZXNzaW9uS2V5LCBDSEFJTi5BUFRPUywgYWNjb3VudHMpO1xuICAgICAgICAgICAgcmV0dXJuIChhY2NvdW50cyA9PT0gbnVsbCB8fCBhY2NvdW50cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogYWNjb3VudHNbMF0pIHx8ICcnO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgb24oZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgICAgIGlmICh0aGlzLmV4aXN0ZWRTREspXG4gICAgICAgICAgICB0aGlzLmV4aXN0ZWRTREsub24oZXZlbnQsIGxpc3RlbmVyKTtcbiAgICAgICAgc3VwZXIub24oZXZlbnQsIGxpc3RlbmVyKTtcbiAgICB9XG4gICAgcmVtb3ZlTGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgICAgIGlmICh0aGlzLmV4aXN0ZWRTREspXG4gICAgICAgICAgICB0aGlzLmV4aXN0ZWRTREsub2ZmKGV2ZW50LCBsaXN0ZW5lcik7XG4gICAgICAgIHN1cGVyLnJlbW92ZUxpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lcik7XG4gICAgfVxufVxuXG5jbGFzcyBCbG9jdG9TREsge1xuICAgIGNvbnN0cnVjdG9yKHsgYXBwSWQsIGV0aGVyZXVtLCBhcHRvcyB9KSB7XG4gICAgICAgIGlmIChldGhlcmV1bSkge1xuICAgICAgICAgICAgdGhpcy5ldGhlcmV1bSA9IG5ldyBFdGhlcmV1bVByb3ZpZGVyKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZXRoZXJldW0pLCB7IGFwcElkIH0pKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXB0b3MpIHtcbiAgICAgICAgICAgIHRoaXMuYXB0b3MgPSBuZXcgQXB0b3NQcm92aWRlcihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGFwdG9zKSwgeyBhcHBJZCB9KSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCB7IEJsb2N0b1NESyBhcyBkZWZhdWx0IH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@blocto/sdk/dist/blocto-sdk.module.js\n");

/***/ })

};
;